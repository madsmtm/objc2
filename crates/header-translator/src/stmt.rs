use std::borrow::Cow;
use std::collections::BTreeMap;
use std::collections::BTreeSet;
use std::collections::HashSet;
use std::fmt;
use std::iter;
use std::mem;

use clang::{Entity, EntityKind, EntityVisitResult};

use crate::availability::Availability;
use crate::config::{ClassData, MethodData};
use crate::context::Context;
use crate::display_helper::FormatterFn;
use crate::expr::Expr;
use crate::id::cfg_gate_ln;
use crate::id::ItemIdentifier;
use crate::id::Location;
use crate::immediate_children;
use crate::method::{handle_reserved, Method};
use crate::rust_type::Ty;
use crate::thread_safety::ThreadSafety;
use crate::unexposed_attr::UnexposedAttr;

#[derive(serde::Deserialize, Debug, Clone, PartialEq, Eq)]
pub struct Derives(Cow<'static, str>);

impl Default for Derives {
    fn default() -> Self {
        Derives("Debug, PartialEq, Eq, Hash".into())
    }
}

impl fmt::Display for Derives {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if !self.0.is_empty() {
            write!(f, "#[derive({})]", self.0)?;
        }
        Ok(())
    }
}

/// Find all protocols, protocol's protocols and superclass' protocols.
fn parse_protocols<'tu>(
    entity: &Entity<'tu>,
    protocols: &mut BTreeMap<ItemIdentifier, Entity<'tu>>,
    context: &Context<'_>,
) {
    immediate_children(entity, |entity, _span| match entity.get_kind() {
        EntityKind::ObjCProtocolRef => {
            let entity = entity
                .get_reference()
                .expect("ObjCProtocolRef to reference entity");
            if protocols
                .insert(ItemIdentifier::new(&entity, context), entity)
                .is_none()
            {
                // Only recurse if we haven't already seen this protocol
                parse_protocols(&entity, protocols, context);
            }
        }
        EntityKind::ObjCSuperClassRef => {
            let entity = entity
                .get_reference()
                .expect("ObjCSuperClassRef to reference entity");
            parse_protocols(&entity, protocols, context);
        }
        _ => {}
    });
}

pub(crate) fn parse_direct_protocols<'clang>(
    entity: &Entity<'clang>,
    _context: &Context<'_>,
) -> Vec<Entity<'clang>> {
    let mut protocols = Vec::new();

    #[allow(clippy::single_match)]
    immediate_children(entity, |entity, _span| match entity.get_kind() {
        EntityKind::ObjCProtocolRef => {
            let entity = entity
                .get_reference()
                .expect("ObjCProtocolRef to reference entity");
            protocols.push(entity);
        }
        _ => {}
    });

    protocols
}

pub(crate) fn parse_superclasses<'ty>(
    entity: &Entity<'ty>,
    context: &Context<'_>,
) -> Vec<(ItemIdentifier, Vec<String>, Entity<'ty>)> {
    let mut current_entity = *entity;
    let mut superclasses = vec![];

    loop {
        let mut superclass = None;
        let mut applied_generics = Vec::new();

        immediate_children(&current_entity, |entity, _span| match entity.get_kind() {
            EntityKind::ObjCSuperClassRef => {
                superclass = Some(
                    entity
                        .get_reference()
                        .expect("ObjCSuperClassRef to reference entity"),
                );
            }
            EntityKind::TypeRef => {
                let name = entity.get_name().expect("typeref name");
                applied_generics.push(name);
            }
            _ => {}
        });

        if let Some(superclass) = superclass {
            current_entity = superclass;
            superclasses.push((
                ItemIdentifier::new(&superclass, context),
                applied_generics,
                superclass,
            ));
        } else {
            return superclasses;
        }
    }
}

fn parse_class_generics(entity: &Entity<'_>, _context: &Context<'_>) -> Vec<String> {
    let mut generics = Vec::new();

    #[allow(clippy::single_match)]
    immediate_children(entity, |entity, _span| match entity.get_kind() {
        EntityKind::TemplateTypeParameter => {
            // TODO: Generics with bounds (like NSMeasurement<UnitType: NSUnit *>)
            // let ty = entity.get_type().expect("template type");
            let name = entity.get_name().expect("template name");
            generics.push(name);
        }
        _ => {}
    });

    generics
}

/// Deduplicate methods that are autogenerated from properties.
///
/// Guaranteed to only contain `ObjCInstanceMethodDecl`, `ObjCClassMethodDecl`
/// and `ObjCPropertyDecl`.
pub(crate) fn method_or_property_entities<'tu>(
    entity: &Entity<'tu>,
    get_data: impl Fn(&str) -> MethodData,
) -> Vec<Entity<'tu>> {
    let mut entities = Vec::new();

    // Track seen properties, so that when methods are autogenerated by the
    // compiler from them, we can skip them
    let mut properties = HashSet::new();

    immediate_children(entity, |entity, _span| match entity.get_kind() {
        EntityKind::ObjCInstanceMethodDecl | EntityKind::ObjCClassMethodDecl => {
            let is_class = entity.get_kind() == EntityKind::ObjCClassMethodDecl;
            let selector = entity.get_name().expect("method selector");

            if get_data(&selector).skipped {
                return;
            }

            if !properties.remove(&(is_class, selector)) {
                entities.push(entity);
            }
        }
        EntityKind::ObjCPropertyDecl => {
            entities.push(entity);

            let partial = Method::partial_property(entity);

            // TODO: Use `get_overridden_methods` to deduplicate property
            // getters (when declared on both immutable and mutable class).

            if !get_data(&partial.getter_sel).skipped
                && !properties.insert((partial.is_class, partial.getter_sel.clone()))
            {
                error!(?partial, ?entity, "already exisiting getter property");
            }

            if let Some(setter_sel) = &partial.setter_sel {
                if !get_data(setter_sel).skipped
                    && !properties.insert((partial.is_class, setter_sel.clone()))
                {
                    error!(?partial, ?entity, "already exisiting setter property");
                }
            }
        }
        _ => {}
    });

    if !properties.is_empty() {
        error!(
            ?entities,
            ?properties,
            "did not properly add methods to properties"
        );
    }

    entities
}

fn parse_methods(
    entity: &Entity<'_>,
    get_data: impl Fn(&str) -> MethodData,
    is_mutable: bool,
    thread_safety: &ThreadSafety,
    is_pub: bool,
    context: &Context<'_>,
) -> (Vec<Method>, Vec<String>) {
    let mut methods = Vec::new();
    let mut designated_initializers = Vec::new();

    for entity in method_or_property_entities(entity, &get_data) {
        match entity.get_kind() {
            EntityKind::ObjCInstanceMethodDecl | EntityKind::ObjCClassMethodDecl => {
                let selector = entity.get_name().expect("method selector");

                let data = get_data(&selector);

                if let Some((designated_initializer, method)) = Method::parse_method(
                    entity,
                    data,
                    is_mutable,
                    thread_safety.inferred_mainthreadonly(),
                    is_pub,
                    context,
                ) {
                    if designated_initializer {
                        designated_initializers.push(method.selector.clone());
                    }
                    methods.push(method);
                }
            }
            EntityKind::ObjCPropertyDecl => {
                let partial = Method::partial_property(entity);

                // TODO: Use `get_overridden_methods` to deduplicate property
                // getters (when declared on both immutable and mutable class).

                let getter_data = get_data(&partial.getter_sel);
                let setter_data = partial
                    .setter_sel
                    .as_ref()
                    .map(|setter_sel| get_data(setter_sel));

                let (getter, setter) = Method::parse_property(
                    partial,
                    getter_data,
                    setter_data,
                    is_mutable,
                    thread_safety.inferred_mainthreadonly(),
                    is_pub,
                    context,
                );
                if let Some(getter) = getter {
                    methods.push(getter);
                }
                if let Some(setter) = setter {
                    methods.push(setter);
                }
            }
            kind => unreachable!("method/property entity {kind:?}"),
        }
    }

    (methods, designated_initializers)
}

/// Get the items required for a given interface or protocol declaration to be
/// enabled.
pub(crate) fn items_required_by_decl(
    entity: &Entity<'_>,
    context: &Context<'_>,
) -> Vec<ItemIdentifier> {
    let id = ItemIdentifier::new(entity, context);

    let mut items = Vec::new();

    match entity.get_kind() {
        EntityKind::ObjCInterfaceDecl => {
            let data = context.class_data.get(&id.name);

            for (superclass, _, _) in parse_superclasses(entity, context) {
                items.push(superclass);
            }
            if let Some(Mutability::ImmutableWithMutableSubclass(subclass)) =
                data.map(|data| &data.mutability)
            {
                items.push(subclass.clone());
            }
        }
        EntityKind::ObjCProtocolDecl => {
            for entity in parse_direct_protocols(entity, context) {
                items.extend(items_required_by_decl(&entity, context));
            }
        }
        _ => panic!("invalid required_by_decl kind {entity:?}"),
    }

    items.push(id);

    items
}

/// Takes one of:
/// - `EntityKind::ObjCInterfaceDecl`
/// - `EntityKind::ObjCProtocolDecl`
/// - `EntityKind::ObjCCategoryDecl`
fn verify_objc_decl(entity: &Entity<'_>, _context: &Context<'_>) {
    let parent_kind = entity.get_kind();

    immediate_children(entity, |entity, _span| {
        match (entity.get_kind(), parent_kind) {
            (EntityKind::ObjCExplicitProtocolImpl, EntityKind::ObjCProtocolDecl) => {
                // TODO NS_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION
            }
            (
                EntityKind::ObjCIvarDecl | EntityKind::StructDecl | EntityKind::UnionDecl,
                EntityKind::ObjCInterfaceDecl,
            ) => {
                // Explicitly ignored
            }
            (
                EntityKind::ObjCSuperClassRef | EntityKind::TypeRef,
                EntityKind::ObjCInterfaceDecl,
            ) => {
                // Parsed in parse_superclasses
            }
            (EntityKind::ObjCSubclassingRestricted, EntityKind::ObjCInterfaceDecl) => {
                // TODO: https://clang.llvm.org/docs/AttributeReference.html#objc-subclassing-restricted
            }
            (EntityKind::ObjCRootClass, EntityKind::ObjCInterfaceDecl) => {
                debug!("parsing root class");
            }
            (
                EntityKind::ObjCClassRef,
                EntityKind::ObjCInterfaceDecl | EntityKind::ObjCCategoryDecl,
            ) => {
                // debug!("ObjCClassRef: {:?}", entity.get_display_name());
            }
            (
                EntityKind::TemplateTypeParameter,
                EntityKind::ObjCInterfaceDecl | EntityKind::ObjCCategoryDecl,
            ) => {
                // Parsed in parse_class_generics
            }
            (EntityKind::ObjCProtocolRef, _) => {
                // Parsed in parse_protocols and parse_direct_protocols
            }
            (
                EntityKind::ObjCInstanceMethodDecl
                | EntityKind::ObjCClassMethodDecl
                | EntityKind::ObjCPropertyDecl,
                _,
            ) => {
                // Parsed in method_or_property_entities
            }
            (EntityKind::VisibilityAttr, _) => {
                // Already exposed as entity.get_visibility()
            }
            (EntityKind::ObjCException, EntityKind::ObjCInterfaceDecl) => {
                // Maybe useful for knowing when to implement `Error` for the type
            }
            (EntityKind::UnexposedAttr, _) => {
                // Parsed in parse_attributes
            }
            (_, parent_kind) => error!(?parent_kind, "unknown in parent"),
        }
    });
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, Default)]
pub enum Mutability {
    Immutable,
    Mutable,
    ImmutableWithMutableSubclass(ItemIdentifier),
    MutableWithImmutableSuperclass(ItemIdentifier),
    #[default]
    InteriorMutable,
    MainThreadOnly,
}

impl Mutability {
    pub fn is_mutable(&self) -> bool {
        matches!(
            self,
            Mutability::Mutable | Mutability::MutableWithImmutableSuperclass(_)
        )
    }
}

impl fmt::Display for Mutability {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Immutable => write!(f, "Immutable"),
            Self::Mutable => write!(f, "Mutable"),
            Self::ImmutableWithMutableSubclass(subclass) => {
                write!(f, "ImmutableWithMutableSubclass<{}>", subclass.path())
            }
            Self::MutableWithImmutableSuperclass(superclass) => {
                write!(f, "MutableWithImmutableSuperclass<{}>", superclass.path())
            }
            Self::InteriorMutable => write!(f, "InteriorMutable"),
            Self::MainThreadOnly => write!(f, "MainThreadOnly"),
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum Stmt {
    /// @interface name: superclass <protocols*>
    /// ->
    /// extern_class!
    ClassDecl {
        id: ItemIdentifier,
        required_items: Vec<ItemIdentifier>,
        generics: Vec<String>,
        availability: Availability,
        superclasses: Vec<(ItemIdentifier, Vec<String>)>,
        designated_initializers: Vec<String>,
        derives: Derives,
        mutability: Mutability,
        skipped: bool,
        sendable: bool,
    },
    /// @interface class_name (category_name) <protocols*>
    /// ->
    /// extern_methods!
    ExternMethods {
        location: Location,
        availability: Availability,
        cls: ItemIdentifier,
        cls_required_items: Vec<ItemIdentifier>,
        source_superclass: Option<ItemIdentifier>,
        cls_generics: Vec<String>,
        category_name: Option<String>,
        methods: Vec<Method>,
    },
    /// @interface class_name (category_name) <protocols*>
    /// ->
    /// extern_category!
    ExternCategory {
        id: ItemIdentifier,
        actual_name: Option<String>,
        availability: Availability,
        cls: ItemIdentifier,
        cls_required_items: Vec<ItemIdentifier>,
        methods: Vec<Method>,
    },
    /// @protocol name <protocols*>
    /// ->
    /// extern_protocol!
    ProtocolDecl {
        id: ItemIdentifier,
        required_items: Vec<ItemIdentifier>,
        actual_name: Option<String>,
        availability: Availability,
        protocols: BTreeSet<ItemIdentifier>,
        methods: Vec<Method>,
        required_sendable: bool,
        required_mainthreadonly: bool,
    },
    /// @interface ty: _ <protocols*>
    /// @interface ty (_) <protocols*>
    ProtocolImpl {
        location: Location,
        cls: ItemIdentifier,
        cls_required_items: Vec<ItemIdentifier>,
        protocol: ItemIdentifier,
        protocol_required_items: Vec<ItemIdentifier>,
        generics: Vec<String>,
        availability: Availability,
    },
    /// struct name {
    ///     fields*
    /// };
    ///
    /// typedef struct {
    ///     fields*
    /// } name;
    ///
    /// typedef struct _name {
    ///     fields*
    /// } name;
    StructDecl {
        id: ItemIdentifier,
        // internal objc struct name (before typedef). shows up in encoding
        // and is used in message verification.
        encoding_name: Option<String>,
        availability: Availability,
        boxable: bool,
        fields: Vec<(String, Ty)>,
        sendable: Option<bool>,
    },
    /// typedef NS_OPTIONS(type, name) {
    ///     variants*
    /// };
    ///
    /// typedef NS_ENUM(type, name) {
    ///     variants*
    /// };
    ///
    /// enum name {
    ///     variants*
    /// };
    ///
    /// enum {
    ///     variants*
    /// };
    EnumDecl {
        id: ItemIdentifier,
        availability: Availability,
        ty: Ty,
        kind: Option<UnexposedAttr>,
        variants: Vec<(String, Availability, Expr)>,
        sendable: Option<bool>,
    },
    /// Anonymous enum variants are emitted as free constants.
    ///
    /// enum {
    ///     variants*
    /// };
    ConstDecl {
        id: ItemIdentifier,
        availability: Availability,
        ty: Ty,
        value: Expr,
        // Hack to get prettier output
        is_last: bool,
    },
    /// static const ty name = expr;
    /// extern const ty name;
    VarDecl {
        id: ItemIdentifier,
        availability: Availability,
        ty: Ty,
        value: Option<Expr>,
    },
    /// extern ret name(args*);
    ///
    /// static inline ret name(args*) {
    ///     body
    /// }
    FnDecl {
        id: ItemIdentifier,
        availability: Availability,
        arguments: Vec<(String, Ty)>,
        result_type: Ty,
        // Some -> inline function.
        body: Option<()>,
        safe: bool,
    },
    /// typedef Type TypedefName;
    AliasDecl {
        id: ItemIdentifier,
        availability: Availability,
        ty: Ty,
        kind: Option<UnexposedAttr>,
    },
}

fn parse_fn_param_children(entity: &Entity<'_>, context: &Context<'_>) {
    immediate_children(entity, |entity, _span| match entity.get_kind() {
        EntityKind::UnexposedAttr => {
            if let Some(attr) = UnexposedAttr::parse(&entity, context) {
                error!(?attr, "unknown attribute");
            }
        }
        EntityKind::ObjCClassRef | EntityKind::TypeRef | EntityKind::ObjCProtocolRef => {}
        EntityKind::NSConsumed => {
            error!("found NSConsumed, which requires manual handling");
        }
        kind => error!(?kind, "unknown"),
    });
}

pub(crate) fn new_enum_id(
    entity: &Entity<'_>,
    context: &Context<'_>,
) -> ItemIdentifier<Option<String>> {
    assert_eq!(entity.get_kind(), EntityKind::EnumDecl);
    let mut id = ItemIdentifier::new_optional(entity, context);

    if id
        .name
        .as_deref()
        .map(|name| name.starts_with("enum (unnamed at"))
        .unwrap_or(false)
    {
        id.name = None;
    }

    id
}

/// Quick n' dirty logic for minimizing the enum constant name.
pub(crate) fn enum_constant_name<'a>(enum_name: &str, constant_name: &'a str) -> &'a str {
    let res = constant_name.trim_start_matches(enum_name);
    if res.starts_with(|c: char| c.is_numeric()) {
        return constant_name;
    }
    res
}

impl Stmt {
    pub fn parse(entity: &Entity<'_>, context: &Context<'_>) -> Vec<Self> {
        let _span = debug_span!(
            "stmt",
            kind = ?entity.get_kind(),
            dbg = entity.get_name(),
        )
        .entered();

        match entity.get_kind() {
            // These are inconsequential for us, since we resolve imports differently
            EntityKind::ObjCClassRef | EntityKind::ObjCProtocolRef => vec![],
            EntityKind::ObjCInterfaceDecl => {
                // entity.get_mangled_objc_names()
                let id = ItemIdentifier::new(entity, context);
                let data = context.class_data.get(&id.name);

                if data.map(|data| data.skipped).unwrap_or_default() {
                    return vec![];
                }

                let availability = Availability::parse(entity, context);
                let thread_safety = ThreadSafety::from_decl(entity, context);

                let required_items = items_required_by_decl(entity, context);

                verify_objc_decl(entity, context);
                let generics = parse_class_generics(entity, context);
                let (methods, designated_initializers) = parse_methods(
                    entity,
                    |name| ClassData::get_method_data(data, name),
                    data.map(|data| data.mutability.is_mutable())
                        .unwrap_or(false),
                    &thread_safety,
                    true,
                    context,
                );

                let mut protocols = Default::default();
                parse_protocols(entity, &mut protocols, context);
                let skipped_protocols = data
                    .map(|data| data.skipped_protocols.clone())
                    .unwrap_or_default();
                protocols.retain(|protocol, _| !skipped_protocols.contains(&protocol.name));

                let superclasses_full = parse_superclasses(entity, context);

                let superclasses: Vec<_> = superclasses_full
                    .iter()
                    .map(|(id, generics, _)| (id.clone(), generics.clone()))
                    .collect();

                // Used for duplicate checking (sometimes the subclass
                // defines the same method that the superclass did).
                let mut seen_methods: BTreeSet<_> =
                    methods.iter().map(|method| method.id()).collect();

                let superclass_methods: Vec<_> = superclasses_full
                    .iter()
                    .filter_map(|(superclass_id, _, entity)| {
                        let superclass_data = context.class_data.get(&superclass_id.name);

                        // Explicitly keep going, even if the class itself is skipped
                        // if superclass_data.skipped

                        let (mut methods, _) = parse_methods(
                            entity,
                            |name| {
                                let data = ClassData::get_method_data(data, name);
                                let superclass_data =
                                    ClassData::get_method_data(superclass_data, name);
                                data.merge_with_superclass(superclass_data)
                            },
                            data.map(|data| data.mutability.is_mutable())
                                .or(superclass_data.map(|data| data.mutability.is_mutable()))
                                .unwrap_or(false),
                            &thread_safety,
                            true,
                            context,
                        );
                        methods.retain(|method| {
                            method.emit_on_subclasses() && !seen_methods.contains(&method.id())
                        });
                        seen_methods.extend(methods.iter().map(|method| method.id()));
                        if methods.is_empty() {
                            None
                        } else {
                            Some(Self::ExternMethods {
                                location: id.location().clone(),
                                availability: Availability::parse(entity, context),
                                cls: id.clone(),
                                cls_required_items: required_items.clone(),
                                source_superclass: Some(superclass_id.clone()),
                                cls_generics: generics.clone(),
                                category_name: None,
                                methods,
                            })
                        }
                    })
                    .collect();

                let methods = Self::ExternMethods {
                    location: id.location().clone(),
                    availability: availability.clone(),
                    cls: id.clone(),
                    cls_required_items: required_items.clone(),
                    source_superclass: None,
                    cls_generics: generics.clone(),
                    category_name: None,
                    methods,
                };

                iter::once(Self::ClassDecl {
                    id: id.clone(),
                    required_items: required_items.clone(),
                    generics: generics.clone(),
                    availability: availability.clone(),
                    superclasses,
                    designated_initializers,
                    derives: data.map(|data| data.derives.clone()).unwrap_or_default(),
                    mutability: if thread_safety.inferred_mainthreadonly() {
                        Mutability::MainThreadOnly
                    } else {
                        data.map(|data| data.mutability.clone()).unwrap_or_default()
                    },
                    skipped: data.map(|data| data.definition_skipped).unwrap_or_default(),
                    // Ignore sendability on superclasses; since it's an auto
                    // trait, it's propagated to subclasses anyhow!
                    sendable: thread_safety.explicit_sendable(),
                })
                .chain(protocols.into_iter().map(|(p, entity)| Self::ProtocolImpl {
                    location: id.location().clone(),
                    cls: id.clone(),
                    cls_required_items: required_items.clone(),
                    protocol: p.map_name(|name| context.replace_protocol_name(name)),
                    protocol_required_items: items_required_by_decl(&entity, context),
                    generics: generics.clone(),
                    availability: availability.clone(),
                }))
                .chain(iter::once(methods))
                .chain(superclass_methods)
                .collect()
            }
            EntityKind::ObjCCategoryDecl => {
                let category = ItemIdentifier::new_optional(entity, context);
                let availability = Availability::parse(entity, context);

                let mut cls_entity = None;
                entity.visit_children(|entity, _parent| {
                    if entity.get_kind() == EntityKind::ObjCClassRef {
                        if cls_entity.is_some() {
                            panic!("could not find unique category class")
                        }
                        let definition = entity
                            .get_definition()
                            .expect("category class ref definition");
                        cls_entity = Some(definition);
                        EntityVisitResult::Break
                    } else {
                        EntityVisitResult::Continue
                    }
                });
                let cls_entity = cls_entity.expect("could not find category class");

                let cls_thread_safety = ThreadSafety::from_decl(&cls_entity, context);
                let cls_required_items = items_required_by_decl(&cls_entity, context);

                let cls = ItemIdentifier::new(&cls_entity, context);
                let data = context.class_data.get(&cls.name);

                if data.map(|data| data.skipped).unwrap_or_default() {
                    return vec![];
                }

                if let Some(category_name) = &category.name {
                    let category_data = data
                        .and_then(|data| data.categories.get(category_name))
                        .cloned()
                        .unwrap_or_default();

                    if category_data.skipped {
                        return vec![];
                    }
                }

                verify_objc_decl(entity, context);
                let generics = parse_class_generics(entity, context);

                let skipped_protocols = data
                    .map(|data| data.skipped_protocols.clone())
                    .unwrap_or_default();
                let protocols = parse_direct_protocols(entity, context);
                let protocols: BTreeMap<_, _> = protocols
                    .into_iter()
                    .map(|entity| (ItemIdentifier::new(&entity, context), entity))
                    .filter(|(protocol, _)| !skipped_protocols.contains(&protocol.name))
                    .collect();

                let protocol_impls = protocols.into_iter().map(|(p, entity)| Self::ProtocolImpl {
                    location: category.location().clone(),
                    cls: cls.clone(),
                    cls_required_items: cls_required_items.clone(),
                    generics: generics.clone(),
                    availability: availability.clone(),
                    protocol: p.map_name(|name| context.replace_protocol_name(name)),
                    protocol_required_items: items_required_by_decl(&entity, context),
                });

                // For ease-of-use, if the category is defined in the same
                // library as the class, we just emit it as `extern_methods!`.
                if cls.library() == category.library() {
                    // extern_methods!

                    let (methods, designated_initializers) = parse_methods(
                        entity,
                        |name| ClassData::get_method_data(data, name),
                        data.map(|data| data.mutability.is_mutable())
                            .unwrap_or(false),
                        &cls_thread_safety,
                        true,
                        context,
                    );

                    if !designated_initializers.is_empty() {
                        warn!(
                            ?designated_initializers,
                            "designated initializer in category"
                        );
                    }

                    let extra_methods = if let Mutability::ImmutableWithMutableSubclass(subclass) =
                        data.map(|data| data.mutability.clone()).unwrap_or_default()
                    {
                        let subclass_data = context.class_data.get(&subclass.name);
                        assert!(!subclass_data.map(|data| data.skipped).unwrap_or_default());

                        let (mut methods, _) = parse_methods(
                            entity,
                            |name| {
                                let data = ClassData::get_method_data(data, name);
                                let subclass_data = ClassData::get_method_data(subclass_data, name);
                                subclass_data.merge_with_superclass(data)
                            },
                            data.map(|data| data.mutability.is_mutable())
                                .or(subclass_data.map(|data| data.mutability.is_mutable()))
                                .unwrap_or(false),
                            &cls_thread_safety,
                            true,
                            context,
                        );
                        methods.retain(|method| method.emit_on_subclasses());
                        if methods.is_empty() {
                            None
                        } else {
                            Some(Self::ExternMethods {
                                location: category.location().clone(),
                                source_superclass: Some(cls.clone()),
                                // Assume that immutable/mutable pairs have the
                                // same availability ...
                                availability: availability.clone(),
                                cls: subclass,
                                // ... the same required items ...
                                cls_required_items: cls_required_items.clone(),
                                // ... and that they have the same amount of generics.
                                cls_generics: generics.clone(),
                                category_name: category.name.clone(),
                                methods,
                            })
                        }
                    } else {
                        None
                    };

                    iter::once(Self::ExternMethods {
                        location: category.location().clone(),
                        availability: availability.clone(),
                        cls: cls.clone(),
                        cls_required_items: cls_required_items.clone(),
                        source_superclass: None,
                        cls_generics: generics.clone(),
                        category_name: category.name.clone(),
                        methods,
                    })
                    .chain(extra_methods)
                    .chain(protocol_impls)
                    .collect()
                } else {
                    // extern_category!

                    if !generics.is_empty() {
                        panic!("external category: cannot handle generics");
                    }

                    // Rough heuristic to determine category name.
                    //
                    // Note: There isn't really a good way to do this, as
                    // category names are not part of the public API in
                    // Objective-C.
                    let id = category.clone().map_name(|name| match name {
                        None => format!("{}Category", cls.name),
                        Some(name) => {
                            if name.contains(&cls.name)
                                || name.contains(&cls.name.replace("Mutable", ""))
                            {
                                name.clone()
                            } else {
                                format!("{}{}", cls.name, name)
                            }
                        }
                    });

                    let (methods, designated_initializers) = parse_methods(
                        entity,
                        |name| ClassData::get_method_data(data, name),
                        false,
                        &cls_thread_safety,
                        false,
                        context,
                    );

                    if !designated_initializers.is_empty() {
                        warn!(
                            ?designated_initializers,
                            "designated initializer in category"
                        );
                    }

                    // Categories are often used to implement protocols for a
                    // type, so as an optimization let's not emit empty
                    // external declarations.
                    //
                    // Additionally, if all methods are deprecated, then there
                    // really isn't a need for us to emit the category
                    // (especially on NSObject, as that just adds a bunch of
                    // clutter).
                    if methods
                        .iter()
                        .all(|method| method.availability.is_deprecated())
                    {
                        None
                    } else {
                        Some(Self::ExternCategory {
                            id,
                            actual_name: category.name.clone(),
                            availability: availability.clone(),
                            cls: cls.clone(),
                            cls_required_items: cls_required_items.clone(),
                            methods,
                        })
                    }
                    .into_iter()
                    .chain(protocol_impls)
                    .collect()
                }
            }
            EntityKind::ObjCProtocolDecl => {
                let actual_id = ItemIdentifier::new(entity, context);
                let data = context.protocol_data.get(&actual_id.name);
                let actual_name = data
                    .map(|data| data.renamed.is_some())
                    .unwrap_or_default()
                    .then(|| actual_id.name.clone());

                let id = actual_id.map_name(|name| context.replace_protocol_name(name));

                if data.map(|data| data.skipped).unwrap_or_default() {
                    return vec![];
                }

                let availability = Availability::parse(entity, context);
                let thread_safety = ThreadSafety::from_decl(entity, context);

                verify_objc_decl(entity, context);
                let protocols = parse_direct_protocols(entity, context);
                let protocols: BTreeSet<_> = protocols
                    .into_iter()
                    .map(|protocol| {
                        ItemIdentifier::new(&protocol, context)
                            .map_name(|name| context.replace_protocol_name(name))
                    })
                    .collect();
                let (methods, designated_initializers) = parse_methods(
                    entity,
                    |name| {
                        data.and_then(|data| data.methods.get(name))
                            .copied()
                            .unwrap_or_default()
                    },
                    false,
                    &thread_safety,
                    false,
                    context,
                );

                if !designated_initializers.is_empty() {
                    warn!(
                        ?designated_initializers,
                        "designated initializer in protocol"
                    )
                }

                vec![Self::ProtocolDecl {
                    id,
                    required_items: items_required_by_decl(entity, context),
                    actual_name,
                    availability,
                    protocols,
                    methods,
                    required_sendable: thread_safety.explicit_sendable(),
                    required_mainthreadonly: thread_safety.explicit_mainthreadonly(),
                }]
            }
            EntityKind::TypedefDecl => {
                let id = ItemIdentifier::new(entity, context);
                let availability = Availability::parse(entity, context);
                let mut kind = None;

                immediate_children(entity, |entity, _span| match entity.get_kind() {
                    EntityKind::UnexposedAttr => {
                        if let Some(attr) = UnexposedAttr::parse(&entity, context) {
                            if kind.is_some() {
                                panic!("got multiple unexposed attributes {kind:?}, {attr:?}");
                            }
                            match attr {
                                // TODO
                                UnexposedAttr::Sendable => warn!("sendable on typedef"),
                                _ => kind = Some(attr),
                            }
                        }
                    }
                    EntityKind::StructDecl
                    | EntityKind::ObjCClassRef
                    | EntityKind::ObjCProtocolRef
                    | EntityKind::TypeRef
                    | EntityKind::ParmDecl => {}
                    _ => error!("unknown"),
                });

                if context
                    .typedef_data
                    .get(&id.name)
                    .map(|data| data.skipped)
                    .unwrap_or_default()
                {
                    return vec![];
                }

                let ty = entity
                    .get_typedef_underlying_type()
                    .expect("typedef underlying type");
                if let Some(ty) = Ty::parse_typedef(ty, &id.name, context) {
                    vec![Self::AliasDecl {
                        id,
                        availability,
                        ty,
                        kind,
                    }]
                } else {
                    vec![]
                }
            }
            EntityKind::StructDecl => {
                let id = ItemIdentifier::new(entity, context);

                let availability = Availability::parse(entity, context);

                if context
                    .struct_data
                    .get(&id.name)
                    .map(|data| data.skipped)
                    .unwrap_or_default()
                {
                    return vec![];
                }

                // See https://github.com/rust-lang/rust-bindgen/blob/95fd17b874910184cc0fcd33b287fa4e205d9d7a/bindgen/ir/comp.rs#L1392-L1408
                if !entity.is_definition() {
                    return vec![];
                }

                let ty = entity.get_type().unwrap();
                let enc = ty.get_objc_encoding().unwrap();
                let encoding_name = enc.strip_prefix('{').unwrap().split_once('=').unwrap().0;
                let encoding_name = if encoding_name == id.name {
                    None
                } else {
                    Some(encoding_name.to_string())
                };

                let mut boxable = false;
                let mut fields = Vec::new();
                let mut sendable = None;

                immediate_children(entity, |entity, span| match entity.get_kind() {
                    EntityKind::UnexposedAttr => {
                        if let Some(attr) = UnexposedAttr::parse(&entity, context) {
                            match attr {
                                UnexposedAttr::Sendable => sendable = Some(true),
                                UnexposedAttr::NonSendable => sendable = Some(false),
                                attr => error!(?attr, "unknown attribute"),
                            }
                        }
                    }
                    EntityKind::FieldDecl => {
                        drop(span);
                        let name = entity.get_name().expect("struct field name");
                        let _span = debug_span!("field", name).entered();

                        let ty = entity.get_type().expect("struct field type");
                        let ty = Ty::parse_struct_field(ty, context);

                        if entity.is_bit_field() {
                            error!("unsound struct bitfield");
                        }

                        fields.push((name, ty))
                    }
                    EntityKind::ObjCBoxable => {
                        boxable = true;
                    }
                    EntityKind::UnionDecl => error!("can't handle unions in structs yet"),
                    _ => error!("unknown"),
                });

                vec![Self::StructDecl {
                    id,
                    encoding_name,
                    availability,
                    boxable,
                    fields,
                    sendable,
                }]
            }
            EntityKind::EnumDecl => {
                // Enum declarations show up twice for some reason, but
                // luckily this flag is set on the least descriptive entity.
                if !entity.is_definition() {
                    return vec![];
                }

                let id = new_enum_id(entity, context);

                let data = context
                    .enum_data
                    .get(id.name.as_deref().unwrap_or("anonymous"))
                    .cloned()
                    .unwrap_or_default();
                if data.skipped {
                    return vec![];
                }

                let availability = Availability::parse(entity, context);

                let ty = entity.get_enum_underlying_type().expect("enum type");
                let is_signed = ty.is_signed_integer();
                let ty = Ty::parse_enum(ty, context);
                let mut kind = None;
                let mut variants = Vec::new();
                let mut sendable = None;

                immediate_children(entity, |entity, _span| match entity.get_kind() {
                    EntityKind::EnumConstantDecl => {
                        let name = entity.get_name().expect("enum constant name");
                        let availability = Availability::parse(&entity, context);

                        if data
                            .constants
                            .get(&name)
                            .map(|data| data.skipped)
                            .unwrap_or_default()
                        {
                            return;
                        }

                        let value = entity
                            .get_enum_constant_value()
                            .expect("enum constant value");

                        let mut expr = if is_signed {
                            Expr::Signed(value.0)
                        } else {
                            Expr::Unsigned(value.1)
                        };

                        if !data.use_value {
                            // Some enums constants don't declare a value, but
                            // let it be inferred from the position in the
                            // enum instead; in those cases, we use the value
                            // generated above.
                            immediate_children(&entity, |entity, _span| match entity.get_kind() {
                                EntityKind::UnexposedAttr => {
                                    if let Some(attr) = UnexposedAttr::parse(&entity, context) {
                                        error!(?attr, "unknown attribute");
                                    }
                                }
                                EntityKind::VisibilityAttr => {}
                                _ if entity.is_expression() => {
                                    expr = Expr::parse_enum_constant(&entity, context);
                                }
                                _ => {
                                    panic!("unknown EnumConstantDecl child in {name:?}: {entity:?}")
                                }
                            });
                        };

                        variants.push((name, availability, expr));
                    }
                    EntityKind::UnexposedAttr => {
                        if let Some(attr) = UnexposedAttr::parse(&entity, context) {
                            match attr {
                                UnexposedAttr::Sendable => sendable = Some(true),
                                UnexposedAttr::NonSendable => sendable = Some(false),
                                attr => {
                                    if let Some(kind) = &kind {
                                        assert_eq!(
                                            kind, &attr,
                                            "got differing enum kinds in {id:?}"
                                        );
                                    } else {
                                        kind = Some(attr);
                                    }
                                }
                            }
                        }
                    }
                    EntityKind::FlagEnum => {
                        let macro_ = UnexposedAttr::Options;
                        if let Some(kind) = &kind {
                            assert_eq!(kind, &macro_, "got differing enum kinds in {id:?}");
                        } else {
                            kind = Some(macro_);
                        }
                    }
                    EntityKind::VisibilityAttr => {
                        // Already exposed as entity.get_visibility()
                    }
                    _ => error!("unknown"),
                });

                if id.name.is_none() {
                    // Availability propagates to the variants automatically
                    let _ = availability;
                    // TODO: Unsure how to handle error enums
                    assert!(matches!(
                        kind,
                        None | Some(UnexposedAttr::Enum) | Some(UnexposedAttr::ErrorEnum)
                    ));
                    assert_eq!(sendable, None);
                    let variants_len = variants.len();
                    variants
                        .into_iter()
                        .enumerate()
                        .map(|(i, (name, availability, value))| Self::ConstDecl {
                            id: id.clone().map_name(|_| name),
                            availability,
                            ty: ty.clone(),
                            value,
                            is_last: i == variants_len - 1,
                        })
                        .collect()
                } else {
                    vec![Self::EnumDecl {
                        id: id.map_name(|name| name.unwrap()),
                        availability,
                        ty,
                        kind,
                        variants,
                        sendable,
                    }]
                }
            }
            EntityKind::VarDecl => {
                let id = ItemIdentifier::new(entity, context);

                if context
                    .statics
                    .get(&id.name)
                    .map(|data| data.skipped)
                    .unwrap_or_default()
                {
                    return vec![];
                }

                let availability = Availability::parse(entity, context);
                let ty = entity.get_type().expect("var type");
                let ty = Ty::parse_static(ty, context);
                let mut value = None;

                immediate_children(entity, |entity, _span| match entity.get_kind() {
                    EntityKind::UnexposedAttr => {
                        if let Some(attr) = UnexposedAttr::parse(&entity, context) {
                            error!(?attr, "unknown attribute");
                        }
                    }
                    EntityKind::VisibilityAttr => {}
                    EntityKind::ObjCClassRef => {}
                    EntityKind::TypeRef => {}
                    _ if entity.is_expression() => {
                        if value.is_none() {
                            value = Some(Expr::parse_var(&entity, context));
                        } else {
                            panic!("got variable value twice")
                        }
                    }
                    _ => panic!("unknown vardecl child in {id:?}: {entity:?}"),
                });

                vec![Self::VarDecl {
                    id,
                    availability,
                    ty,
                    value,
                }]
            }
            EntityKind::FunctionDecl => {
                let id = ItemIdentifier::new(entity, context);

                let data = context.fns.get(&id.name).cloned().unwrap_or_default();

                if data.skipped {
                    return vec![];
                }

                if entity.is_variadic() {
                    warn!("can't handle variadic function");
                    return vec![];
                }

                let availability = Availability::parse(entity, context);
                let result_type = entity.get_result_type().expect("function result type");
                let result_type = Ty::parse_function_return(result_type, context);
                let mut arguments = Vec::new();

                if entity.is_static_method() {
                    warn!("unexpected static method");
                }

                immediate_children(entity, |entity, _span| match entity.get_kind() {
                    EntityKind::UnexposedAttr => {
                        if let Some(attr) = UnexposedAttr::parse(&entity, context) {
                            error!(?attr, "unknown attribute");
                        }
                    }
                    EntityKind::ObjCClassRef
                    | EntityKind::TypeRef
                    | EntityKind::ObjCProtocolRef => {}
                    EntityKind::ParmDecl => {
                        parse_fn_param_children(&entity, context);
                        // Could also be retrieved via. `get_arguments`
                        let name = entity.get_name().unwrap_or_else(|| "_".into());
                        let ty = entity.get_type().expect("function argument type");
                        let ty = Ty::parse_function_argument(ty, context);
                        arguments.push((name, ty))
                    }
                    EntityKind::VisibilityAttr => {
                        // CG_EXTERN or UIKIT_EXTERN
                    }
                    _ => error!("unknown"),
                });

                let body = if entity.is_inline_function() {
                    Some(())
                } else {
                    None
                };

                vec![Self::FnDecl {
                    id,
                    availability,
                    arguments,
                    result_type,
                    body,
                    safe: !data.unsafe_,
                }]
            }
            EntityKind::UnionDecl => {
                let id = ItemIdentifier::new_optional(entity, context);
                error!(
                    ?id,
                    has_attributes = ?entity.has_attributes(),
                    children = ?entity.get_children(),
                    "union",
                );
                vec![]
            }
            EntityKind::UnexposedDecl => {
                // `@compatibility_alias`, can be ignored (since we don't
                // need to support older SDK versions).
                vec![]
            }
            _ => {
                error!("unknown");
                vec![]
            }
        }
    }

    pub(crate) fn provided_item(&self) -> Option<ItemIdentifier> {
        match self {
            Self::ClassDecl { id, skipped, .. } => {
                if *skipped {
                    None
                } else {
                    Some(id.clone())
                }
            }
            Self::ExternMethods { .. } => None,
            Self::ExternCategory { id, .. } => Some(id.clone()),
            Self::ProtocolDecl { id, .. } => Some(id.clone()),
            Self::ProtocolImpl { .. } => None,
            Self::StructDecl { id, .. } => Some(id.clone()),
            Self::EnumDecl { id, .. } => Some(id.clone()),
            Self::ConstDecl { id, .. } => Some(id.clone()),
            Self::VarDecl { id, .. } => Some(id.clone()),
            Self::FnDecl { id, body: None, .. } => Some(id.clone()),
            // TODO
            Self::FnDecl { body: Some(_), .. } => None,
            Self::AliasDecl { id, .. } => Some(id.clone()),
        }
    }

    pub(crate) fn location(&self) -> &Location {
        match self {
            Self::ClassDecl { id, .. } => id.location(),
            Self::ExternMethods { location, .. } => location,
            Self::ExternCategory { id, .. } => id.location(),
            Self::ProtocolDecl { id, .. } => id.location(),
            Self::ProtocolImpl { location, .. } => location,
            Self::StructDecl { id, .. } => id.location(),
            Self::EnumDecl { id, .. } => id.location(),
            Self::ConstDecl { id, .. } => id.location(),
            Self::VarDecl { id, .. } => id.location(),
            Self::FnDecl { id, .. } => id.location(),
            Self::AliasDecl { id, .. } => id.location(),
        }
    }

    /// Items required by the statement at the top-level.
    pub(crate) fn required_items(&self) -> Vec<ItemIdentifier> {
        match self {
            Self::ClassDecl { required_items, .. } => required_items.clone(),
            Self::ExternMethods {
                cls_required_items, ..
            } => cls_required_items.clone(),
            // Intentionally doesn't require anything, the impl itself is
            // cfg-gated
            Self::ExternCategory { .. } => Vec::new(),
            Self::ProtocolDecl { required_items, .. } => required_items.clone(),
            Self::ProtocolImpl {
                cls_required_items,
                protocol_required_items,
                ..
            } => {
                let mut items = Vec::new();
                items.extend(cls_required_items.clone());
                items.extend(protocol_required_items.clone());
                items
            }
            Self::StructDecl { fields, .. } => {
                let mut items = Vec::new();
                for (_, field_ty) in fields {
                    items.extend(field_ty.required_items());
                }
                items
            }
            // Variants manage required items themselves
            Self::EnumDecl { ty, .. } => ty.required_items(),
            Self::ConstDecl { ty, value, .. } => {
                let mut items = ty.required_items();
                items.extend(value.required_items());
                items
            }
            Self::VarDecl { ty, value, .. } => {
                let mut items = ty.required_items();
                if let Some(value) = value {
                    items.extend(value.required_items());
                }
                items
            }
            Self::FnDecl {
                arguments,
                result_type,
                body: None,
                ..
            } => {
                let mut items = Vec::new();
                for (_, arg_ty) in arguments {
                    items.extend(arg_ty.required_items());
                }
                items.extend(result_type.required_items());
                items
            }
            // TODO
            Self::FnDecl { body: Some(_), .. } => Vec::new(),
            Self::AliasDecl { ty, .. } => ty.required_items(),
        }
    }

    fn cfg_gate_ln(&self) -> impl fmt::Display + '_ {
        cfg_gate_ln(self.required_items(), [self.location()])
    }
}

impl fmt::Display for Stmt {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let _span = debug_span!("stmt", discriminant = ?mem::discriminant(self)).entered();

        struct GenericTyHelper<'a>(&'a [String]);

        impl fmt::Display for GenericTyHelper<'_> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                if !self.0.is_empty() {
                    write!(f, "<")?;
                    for generic in self.0 {
                        write!(f, "{generic}, ")?;
                    }
                    write!(f, ">")?;
                }
                Ok(())
            }
        }

        struct GenericParamsHelper<'a>(&'a [String], &'a str);

        impl fmt::Display for GenericParamsHelper<'_> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                if !self.0.is_empty() {
                    write!(f, "<")?;
                    for generic in self.0 {
                        write!(f, "{generic}: {}, ", self.1)?;
                    }
                    write!(f, ">")?;
                }
                Ok(())
            }
        }

        struct WhereBoundHelper<'a>(&'a [String], Option<&'a str>);

        impl fmt::Display for WhereBoundHelper<'_> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                if let Some(bound) = self.1 {
                    if !self.0.is_empty() {
                        writeln!(f, "where")?;
                        for generic in self.0 {
                            writeln!(f, "{generic}{bound},")?;
                        }
                    }
                }
                Ok(())
            }
        }

        // TODO: Derive this after https://github.com/madsmtm/objc2/issues/55
        fn unsafe_impl_encode<'a>(
            ident: impl fmt::Display + 'a,
            encoding: impl fmt::Display + 'a,
        ) -> impl fmt::Display + 'a {
            FormatterFn(move |f| {
                writeln!(f, "#[cfg(feature = \"objc2\")]")?;
                writeln!(f, "unsafe impl Encode for {ident} {{")?;
                writeln!(f, "    const ENCODING: Encoding = {encoding};")?;
                writeln!(f, "}}")?;
                Ok(())
            })
        }

        // TODO: Derive this after https://github.com/madsmtm/objc2/issues/55
        fn unsafe_impl_refencode<'a>(ident: impl fmt::Display + 'a) -> impl fmt::Display + 'a {
            FormatterFn(move |f| {
                writeln!(f, "#[cfg(feature = \"objc2\")]")?;
                writeln!(f, "unsafe impl RefEncode for {ident} {{")?;
                writeln!(
                    f,
                    "    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);"
                )?;
                writeln!(f, "}}")?;
                Ok(())
            })
        }

        match self {
            Self::ClassDecl {
                id,
                required_items: _,
                generics,
                availability,
                superclasses,
                designated_initializers: _,
                derives,
                mutability,
                skipped,
                sendable,
            } => {
                if *skipped {
                    return Ok(());
                }

                let macro_name = if generics.is_empty() {
                    "extern_class"
                } else {
                    "__inner_extern_class"
                };

                let (superclass, superclasses_rest) = superclasses.split_at(1);
                let (superclass, superclass_generics) = superclass
                    .first()
                    .expect("must have a least one superclass");

                writeln!(f, "{macro_name}!(")?;
                writeln!(f, "    {derives}")?;
                write!(f, "    {}", self.cfg_gate_ln())?;
                write!(f, "    {availability}")?;
                write!(f, "    pub struct {}", id.name)?;
                if !generics.is_empty() {
                    write!(f, "<")?;
                    for generic in generics {
                        write!(f, "{generic}: ?Sized = AnyObject, ")?;
                    }
                    write!(f, ">")?;
                };
                if generics.is_empty() {
                    writeln!(f, ";")?;
                } else {
                    writeln!(f, " {{")?;
                    writeln!(
                        f,
                        "__superclass: {}{},",
                        superclass.path_in_relation_to(id.location()),
                        GenericTyHelper(superclass_generics),
                    )?;
                    for (i, generic) in generics.iter().enumerate() {
                        // Invariant over the generic by default
                        writeln!(f, "_inner{i}: PhantomData<*mut {generic}>,")?;
                    }
                    writeln!(f, "notunwindsafe: PhantomData<&'static mut ()>,")?;
                    writeln!(f, "}}")?;
                }

                writeln!(f)?;

                write!(f, "    {}", self.cfg_gate_ln())?;
                writeln!(
                    f,
                    "    unsafe impl{} ClassType for {}{} {{",
                    GenericParamsHelper(generics, "?Sized + Message"),
                    id.name,
                    GenericTyHelper(generics),
                )?;
                if !superclasses_rest.is_empty() {
                    write!(f, "        #[inherits(")?;
                    let mut iter = superclasses_rest.iter();
                    // Using generics in here is not technically correct, but
                    // should work for our use-cases.
                    if let Some((superclass, generics)) = iter.next() {
                        write!(
                            f,
                            "{}{}",
                            superclass.path_in_relation_to(id.location()),
                            GenericTyHelper(generics)
                        )?;
                    }
                    for (superclass, generics) in iter {
                        write!(
                            f,
                            ", {}{}",
                            superclass.path_in_relation_to(id.location()),
                            GenericTyHelper(generics)
                        )?;
                    }
                    writeln!(f, ")]")?;
                }
                writeln!(
                    f,
                    "        type Super = {}{};",
                    superclass.path_in_relation_to(id.location()),
                    GenericTyHelper(superclass_generics),
                )?;
                writeln!(f, "        type Mutability = {mutability};")?;
                if !generics.is_empty() {
                    writeln!(f)?;
                    writeln!(
                        f,
                        "        fn as_super(&self) -> &Self::Super {{ &self.__superclass }}"
                    )?;
                    writeln!(f)?;
                    writeln!(f, "        fn as_super_mut(&mut self) -> &mut Self::Super {{ &mut self.__superclass }}")?;
                }
                writeln!(f, "    }}")?;
                writeln!(f, ");")?;

                if *sendable && generics.is_empty() {
                    writeln!(f)?;
                    write!(f, "{}", self.cfg_gate_ln())?;
                    writeln!(f, "unsafe impl Send for {} {{}}", id.name)?;

                    writeln!(f)?;
                    write!(f, "{}", self.cfg_gate_ln())?;
                    writeln!(f, "unsafe impl Sync for {} {{}}", id.name)?;
                }
            }
            Self::ExternMethods {
                location: _,
                availability: _,
                cls,
                cls_required_items: _,
                source_superclass,
                cls_generics,
                category_name,
                methods,
            } => {
                writeln!(f, "extern_methods!(")?;
                if let Some(source_superclass) = source_superclass {
                    writeln!(
                        f,
                        "    /// Methods declared on superclass `{}`",
                        source_superclass.name
                    )?;
                    if let Some(category_name) = category_name {
                        writeln!(f, "///")?;
                        writeln!(f, "    /// {category_name}")?;
                    }
                } else if let Some(category_name) = category_name {
                    writeln!(f, "    /// {category_name}")?;
                }
                write!(f, "    {}", self.cfg_gate_ln())?;
                // TODO: Add ?Sized here once `extern_methods!` supports it.
                writeln!(
                    f,
                    "    unsafe impl{} {}{} {{",
                    GenericParamsHelper(cls_generics, "Message"),
                    cls.path(),
                    GenericTyHelper(cls_generics),
                )?;
                let required_items = self.required_items();
                for method in methods {
                    let implied_features = required_items
                        .iter()
                        .map(|item| item.location())
                        .chain(iter::once(self.location()));
                    write!(
                        f,
                        "{}",
                        cfg_gate_ln(method.required_items(), implied_features)
                    )?;
                    writeln!(f, "{method}")?;
                }
                writeln!(f, "    }}")?;
                writeln!(f, ");")?;

                if let Some(method) = methods.iter().find(|method| method.usable_in_default_id()) {
                    writeln!(f)?;
                    // Assume `new` methods require no extra features
                    write!(f, "{}", self.cfg_gate_ln())?;
                    writeln!(
                        f,
                        "impl{} DefaultId for {}{} {{",
                        GenericParamsHelper(cls_generics, "Message"),
                        cls.path(),
                        GenericTyHelper(cls_generics),
                    )?;
                    writeln!(f, "    #[inline]")?;
                    writeln!(f, "    fn default_id() -> Id<Self> {{")?;
                    writeln!(f, "        Self::{}()", method.fn_name)?;
                    writeln!(f, "    }}")?;
                    writeln!(f, "}}")?;
                }
            }
            Self::ExternCategory {
                id,
                actual_name,
                availability,
                cls,
                cls_required_items,
                methods,
            } => {
                writeln!(f, "extern_category!(")?;

                if let Some(actual_name) = actual_name {
                    if *actual_name != id.name {
                        writeln!(f, "    /// Category \"{actual_name}\" on [`{}`].", cls.name)?;
                        writeln!(f, "    #[doc(alias = \"{actual_name}\")]")?;
                    } else {
                        writeln!(f, "    /// Category on [`{}`].", cls.name)?;
                    }
                } else {
                    writeln!(f, "    /// Category on [`{}`].", cls.name)?;
                }

                write!(f, "    {}", self.cfg_gate_ln())?;
                write!(f, "    {availability}")?;
                writeln!(f, "    pub unsafe trait {} {{", id.name)?;
                let required_items = self.required_items();
                for method in methods {
                    let implied_features = required_items
                        .iter()
                        .map(|item| item.location())
                        .chain(iter::once(self.location()));
                    write!(
                        f,
                        "{}",
                        cfg_gate_ln(method.required_items(), implied_features)
                    )?;
                    writeln!(f, "{method}")?;
                }
                writeln!(f, "    }}")?;

                writeln!(f)?;

                write!(
                    f,
                    "    {}",
                    cfg_gate_ln(cls_required_items, [self.location()])
                )?;
                writeln!(
                    f,
                    "    unsafe impl {} for {} {{}}",
                    id.name,
                    cls.path_in_relation_to(id.location()),
                )?;

                writeln!(f, ");")?;
            }
            Self::ProtocolImpl {
                location: id,
                cls,
                cls_required_items: _,
                generics,
                protocol,
                protocol_required_items: _,
                availability: _,
            } => {
                let (generic_bound, where_bound) = if !generics.is_empty() {
                    match (protocol.library(), &*protocol.name) {
                        // The object inherits from `NSObject` or `NSProxy` no
                        // matter what the generic type is, so this must be
                        // safe.
                        (_, _) if protocol.is_nsobject() => ("?Sized", None),
                        // Encoding and decoding requires that the inner types
                        // are codable as well.
                        ("Foundation", "NSCoding") => ("?Sized + NSCoding", None),
                        ("Foundation", "NSSecureCoding") => ("?Sized + NSSecureCoding", None),
                        // Copying collections is done as a shallow copy:
                        // <https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html>
                        //
                        // E.g. it does a retain count bump on the items, and
                        // hence does not require the inner type to implement
                        // `NSCopying`.
                        //
                        // The types does have to be cloneable, since generic
                        // types effectively store an `Id<T>` of the type.
                        ("Foundation", "NSCopying") => ("?Sized + IsIdCloneable", None),
                        ("Foundation", "NSMutableCopying") => ("?Sized + IsIdCloneable", None),
                        // TODO: Do we need further tweaks to this?
                        ("Foundation", "NSFastEnumeration") => ("?Sized", None),
                        // AppKit fixes. TODO: Should we add more bounds here?
                        ("AppKit", "NSCollectionViewDataSource") => ("?Sized", None),
                        ("AppKit", "NSTableViewDataSource") => ("?Sized", None),
                        _ => {
                            error!(
                                ?protocol,
                                ?cls,
                                "unknown where bound for generic protocol impl"
                            );
                            ("?Sized", None)
                        }
                    }
                } else {
                    ("InvalidGenericBound", None)
                };

                write!(f, "{}", self.cfg_gate_ln())?;
                writeln!(
                    f,
                    "unsafe impl{} {} for {}{} {}{{}}",
                    GenericParamsHelper(generics, generic_bound),
                    protocol.path_in_relation_to(id),
                    cls.path_in_relation_to(id),
                    GenericTyHelper(generics),
                    WhereBoundHelper(generics, where_bound)
                )?;
            }
            Self::ProtocolDecl {
                id,
                required_items: _,
                actual_name,
                availability,
                protocols,
                methods,
                required_sendable: _,
                required_mainthreadonly,
            } => {
                writeln!(f, "extern_protocol!(")?;

                write!(f, "    {}", self.cfg_gate_ln())?;
                write!(f, "    {availability}")?;
                write!(f, "    pub unsafe trait {}", id.name)?;
                if !protocols.is_empty() {
                    for (i, protocol) in protocols.iter().enumerate() {
                        if i == 0 {
                            write!(f, ": ")?;
                        } else {
                            write!(f, "+ ")?;
                        }
                        write!(f, "{}", protocol.path())?;
                    }
                }
                // TODO
                // if *required_sendable {
                //     if protocols.is_empty() {
                //         write!(f, ": ")?;
                //     } else {
                //         write!(f, "+ ")?;
                //     }
                //     write!(f, "Send + Sync")?;
                // }
                if *required_mainthreadonly {
                    if protocols.is_empty() {
                        write!(f, ": ")?;
                    } else {
                        write!(f, "+ ")?;
                    }
                    write!(f, "IsMainThreadOnly")?;
                }
                writeln!(f, " {{")?;

                let required_items = self.required_items();
                for method in methods {
                    let implied_features = required_items
                        .iter()
                        .map(|item| item.location())
                        .chain(iter::once(self.location()));
                    write!(
                        f,
                        "{}",
                        cfg_gate_ln(method.required_items(), implied_features)
                    )?;
                    writeln!(f, "{method}")?;
                }
                writeln!(f, "    }}")?;
                writeln!(f)?;

                write!(f, "    {}", self.cfg_gate_ln())?;
                writeln!(f, "    unsafe impl ProtocolType for dyn {} {{", id.name)?;
                if let Some(actual_name) = actual_name {
                    writeln!(f)?;
                    writeln!(f, "        const NAME: &'static str = {actual_name:?};")?;
                    write!(f, "    ")?;
                }
                writeln!(f, "}}")?;
                writeln!(f, ");")?;
            }
            Self::StructDecl {
                id,
                encoding_name,
                availability,
                boxable: _,
                fields,
                sendable,
            } => {
                write!(f, "{}", self.cfg_gate_ln())?;
                write!(f, "{availability}")?;
                write!(f, "#[repr(C)]")?;
                write!(f, "#[derive(Clone, Copy, Debug, PartialEq)]")?;
                writeln!(f, "pub struct {} {{", id.name)?;
                for (name, ty) in fields {
                    write!(f, "    ")?;
                    if !name.starts_with('_') {
                        write!(f, "pub ")?;
                    }
                    let name = handle_reserved(name);
                    writeln!(f, "{name}: {},", ty.struct_())?;
                }
                writeln!(f, "}}")?;
                writeln!(f)?;

                let encoding = FormatterFn(|f| {
                    write!(
                        f,
                        "Encoding::Struct({:?}, &[",
                        encoding_name.as_deref().unwrap_or(&id.name),
                    )?;
                    for (_, ty) in fields {
                        write!(f, "<{}>::ENCODING,", ty.struct_())?;
                    }
                    write!(f, "])")?;
                    Ok(())
                });

                // SAFETY: The struct is marked `#[repr(C)]`.
                write!(f, "{}", self.cfg_gate_ln())?;
                writeln!(f, "{}", unsafe_impl_encode(&id.name, encoding))?;
                write!(f, "{}", self.cfg_gate_ln())?;
                writeln!(f, "{}", unsafe_impl_refencode(&id.name))?;

                if let Some(true) = sendable {
                    writeln!(f)?;
                    write!(f, "{}", self.cfg_gate_ln())?;
                    writeln!(f, "unsafe impl Send for {} {{}}", id.name)?;

                    writeln!(f)?;
                    write!(f, "{}", self.cfg_gate_ln())?;
                    writeln!(f, "unsafe impl Sync for {} {{}}", id.name)?;
                }
            }
            Self::EnumDecl {
                id,
                availability,
                ty,
                kind,
                variants,
                sendable,
            } => {
                match kind {
                    // TODO: Once Rust gains support for more precisely
                    // specifying niches, use that to convert this into a
                    // native enum with a hidden variant that contains the
                    // remaining cases.
                    None
                    // Swift emits these slightly differently, with
                    // only `NS_ENUM` being a "native" enum with
                    // exhaustiveness-checking and all.
                    //
                    // <https://developer.apple.com/documentation/swift/grouping-related-objective-c-constants#Declare-Simple-Enumerations>
                    | Some(UnexposedAttr::Enum)
                    // TODO: Use bitflags! here.
                    | Some(UnexposedAttr::Options)
                    // TODO: Handle this differently.
                    | Some(UnexposedAttr::ErrorEnum) => {
                        match kind {
                            None => {}
                            Some(UnexposedAttr::Enum) => writeln!(f, "// NS_ENUM")?,
                            Some(UnexposedAttr::Options) => writeln!(f, "// NS_OPTIONS")?,
                            Some(UnexposedAttr::ErrorEnum) => writeln!(f, "// NS_ERROR_ENUM")?,
                            _ => unreachable!(),
                        }

                        write!(f, "{}", self.cfg_gate_ln())?;
                        write!(f, "{availability}")?;
                        writeln!(f, "#[repr(transparent)]")?;
                        // TODO: Implement `Debug` manually
                        writeln!(
                            f,
                            "#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]"
                        )?;
                        // External enums can be safely constructed from the
                        // raw value, and as such it is safe to expose it
                        // directly without causing unsoundess in external
                        // libraries (but it will likely lead to an exception
                        // or a crash, if the invalid value is used).
                        writeln!(f, "pub struct {}(pub {});", id.name, ty.enum_())?;

                        write!(f, "{}", self.cfg_gate_ln())?;
                        writeln!(f, "impl {} {{", id.name)?;

                        let required_items = self.required_items();
                        for (name, availability, expr) in variants {
                            let implied_features = required_items
                                .iter()
                                .map(|item| item.location())
                                .chain(iter::once(self.location()));
                            write!(f, "    {}", cfg_gate_ln(expr.required_items(), implied_features))?;
                            write!(f, "    {availability}")?;
                            let pretty_name = enum_constant_name(&id.name, name);
                            if pretty_name != name {
                                writeln!(f, "    #[doc(alias = \"{name}\")]")?;
                            }
                            writeln!(f, "    pub const {pretty_name}: Self = Self({expr});")?;
                        }
                        writeln!(f, "}}")?;
                        writeln!(f)?;
                    }
                    Some(UnexposedAttr::ClosedEnum) => {
                        // SAFETY: `NS_CLOSED_ENUM` is guaranteed to never
                        // gain additional cases, so we are allowed to use a
                        // Rust enum (which in turn will assume that the
                        // unused patterns are valid to use as a niche).
                        writeln!(f, "// NS_CLOSED_ENUM")?;
                        write!(f, "{}", self.cfg_gate_ln())?;
                        write!(f, "{availability}")?;
                        writeln!(f, "{}", ty.closed_enum_repr())?;
                        writeln!(
                            f,
                            "#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]"
                        )?;
                        writeln!(f, "pub enum {} {{", id.name)?;

                        let required_items = self.required_items();
                        for (name, availability, expr) in variants {
                            let implied_features = required_items
                                .iter()
                                .map(|item| item.location())
                                .chain(iter::once(self.location()));
                            write!(f, "    {}", cfg_gate_ln(expr.required_items(), implied_features))?;
                            write!(f, "    {availability}")?;
                            let pretty_name = enum_constant_name(&id.name, name);
                            if pretty_name != name {
                                writeln!(f, "    #[doc(alias = \"{name}\")]")?;
                            }
                            writeln!(f, "    {pretty_name} = {expr},")?;
                        }
                        writeln!(f, "}}")?;
                        writeln!(f)?;
                    }
                    _ => panic!("invalid enum kind"),
                }

                // SAFETY: The enum is either a `#[repr(transparent)]` newtype
                // over the type, or a `#[repr(REPR)]`, where REPR is a valid
                // repr with the same size and alignment as the type.
                write!(f, "{}", self.cfg_gate_ln())?;
                let encoding = format!("{}::ENCODING", ty.enum_());
                writeln!(f, "{}", unsafe_impl_encode(&id.name, encoding))?;
                write!(f, "{}", self.cfg_gate_ln())?;
                writeln!(f, "{}", unsafe_impl_refencode(&id.name))?;

                if let Some(true) = sendable {
                    writeln!(f)?;
                    write!(f, "{}", self.cfg_gate_ln())?;
                    writeln!(f, "unsafe impl Send for {} {{}}", id.name)?;

                    writeln!(f)?;
                    write!(f, "{}", self.cfg_gate_ln())?;
                    writeln!(f, "unsafe impl Sync for {} {{}}", id.name)?;
                }
            }
            Self::ConstDecl {
                id,
                availability,
                ty,
                value,
                is_last,
            } => {
                write!(f, "{}", self.cfg_gate_ln())?;
                write!(f, "{availability}")?;
                write!(f, "pub const {}: {} = {value};", id.name, ty.enum_())?;
                if *is_last {
                    writeln!(f)?;
                }
            }
            Self::VarDecl {
                id,
                availability: _,
                ty,
                value: None,
            } => {
                writeln!(f, "extern \"C\" {{")?;
                write!(f, "{}", self.cfg_gate_ln())?;
                writeln!(f, "pub static {}: {};", id.name, ty.var())?;
                writeln!(f, "}}")?;
            }
            Self::VarDecl {
                id,
                availability: _,
                ty,
                value: Some(expr),
            } => {
                write!(f, "{}", self.cfg_gate_ln())?;
                write!(f, "pub static {}: {} = ", id.name, ty.var())?;

                if ty.is_floating_through_typedef() {
                    write!(f, "{expr} as _")?;
                } else if ty.is_enum_through_typedef() {
                    write!(f, "{}({expr})", ty.var())?;
                } else {
                    write!(f, "{expr}")?;
                }
                writeln!(f, ";")?;
            }
            Self::FnDecl {
                id,
                availability: _,
                arguments,
                result_type,
                body: Some(_),
                safe: _,
            } => {
                write!(f, "// TODO: ")?;
                write!(f, "pub fn {}(", id.name)?;
                for (param, arg_ty) in arguments {
                    let param = handle_reserved(&crate::to_snake_case(param));
                    write!(f, "{param}: {},", arg_ty.fn_argument())?;
                }
                writeln!(f, "){};", result_type.fn_return())?;
            }
            Self::FnDecl {
                id,
                availability,
                arguments,
                result_type,
                body: None,
                safe: false,
            } => {
                writeln!(f, "extern \"C\" {{")?;

                write!(f, "    {}", self.cfg_gate_ln())?;
                write!(f, "    {availability}")?;
                write!(f, "    pub fn {}(", id.name)?;
                for (param, arg_ty) in arguments {
                    let param = handle_reserved(&crate::to_snake_case(param));
                    write!(f, "{param}: {},", arg_ty.fn_argument())?;
                }
                write!(f, "){}", result_type.fn_return())?;
                writeln!(f, ";")?;

                writeln!(f, "}}")?;
            }
            Self::FnDecl {
                id,
                availability,
                arguments,
                result_type,
                body: None,
                safe: true,
            } => {
                write!(f, "{}", self.cfg_gate_ln())?;
                write!(f, "{availability}")?;
                writeln!(f, "#[inline]")?;
                write!(f, "pub extern \"C\" fn {}(", id.name)?;
                for (param, arg_ty) in arguments {
                    let param = handle_reserved(&crate::to_snake_case(param));
                    write!(f, "{param}: {},", arg_ty.fn_argument())?;
                }
                writeln!(f, "){} {{", result_type.fn_return())?;

                writeln!(f, "    extern \"C\" {{")?;

                write!(f, "        fn {}(", id.name)?;
                for (param, arg_ty) in arguments {
                    let param = handle_reserved(&crate::to_snake_case(param));
                    write!(f, "{param}: {},", arg_ty.fn_argument())?;
                }
                writeln!(f, "){};", result_type.fn_return())?;

                writeln!(f, "    }}")?;

                write!(f, "    unsafe {{ {}(", id.name)?;
                for (param, _) in arguments {
                    let param = handle_reserved(&crate::to_snake_case(param));
                    write!(f, "{param},")?;
                }
                writeln!(f, ") }}")?;

                writeln!(f, "}}")?;
            }
            Self::AliasDecl {
                id,
                availability: _,
                ty,
                kind,
            } => {
                match kind {
                    Some(UnexposedAttr::TypedEnum) => {
                        // TODO: Handle this differently
                        writeln!(f, "// NS_TYPED_ENUM")?;
                        write!(f, "{}", self.cfg_gate_ln())?;
                        writeln!(f, "pub type {} = {};", id.name, ty.typedef())?;
                    }
                    Some(UnexposedAttr::TypedExtensibleEnum) => {
                        // TODO: Handle this differently
                        writeln!(f, "// NS_TYPED_EXTENSIBLE_ENUM")?;
                        write!(f, "{}", self.cfg_gate_ln())?;
                        writeln!(f, "pub type {} = {};", id.name, ty.typedef())?;
                    }
                    None | Some(UnexposedAttr::BridgedTypedef) => {
                        // "bridged" typedefs should use a normal type alias.
                        write!(f, "{}", self.cfg_gate_ln())?;
                        writeln!(f, "pub type {} = {};", id.name, ty.typedef())?;
                    }
                    kind => panic!("invalid alias kind {kind:?} for {ty:?}"),
                }
            }
        };
        Ok(())
    }
}
