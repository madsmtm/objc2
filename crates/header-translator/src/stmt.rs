use std::borrow::Cow;
use std::collections::BTreeMap;
use std::collections::BTreeSet;
use std::collections::HashMap;
use std::collections::HashSet;
use std::fmt;
use std::fmt::Display;
use std::iter;

use clang::{Entity, EntityKind, EntityVisitResult};

use crate::availability::Availability;
use crate::cfgs::PlatformCfg;
use crate::config::{ClassData, Config, LibraryConfig, MethodData};
use crate::context::Context;
use crate::display_helper::FormatterFn;
use crate::documentation::Documentation;
use crate::expr::Expr;
use crate::fn_utils::follows_create_rule;
use crate::id::cfg_gate_ln;
use crate::id::ItemIdentifier;
use crate::id::ItemTree;
use crate::id::Location;
use crate::immediate_children;
use crate::method::{handle_reserved, Method};
use crate::name_translation::enum_prefix;
use crate::name_translation::split_words;
use crate::protocol::parse_direct_protocols;
use crate::protocol::ProtocolRef;
use crate::rust_type::Ty;
use crate::thread_safety::ThreadSafety;
use crate::unexposed_attr::UnexposedAttr;

#[derive(serde::Deserialize, Debug, Clone, PartialEq, Eq)]
pub struct Derives(Cow<'static, str>);

impl Default for Derives {
    fn default() -> Self {
        Derives("Debug, PartialEq, Eq, Hash".into())
    }
}

impl fmt::Display for Derives {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if !self.0.is_empty() {
            write!(f, "#[derive({})]", self.0)?;
        }
        Ok(())
    }
}

/// Find all protocols, protocol's protocols and superclass' protocols.
fn parse_protocols<'tu>(
    entity: &Entity<'tu>,
    protocols: &mut BTreeMap<ItemIdentifier, Entity<'tu>>,
    context: &Context<'_>,
) {
    immediate_children(entity, |entity, _span| match entity.get_kind() {
        EntityKind::ObjCProtocolRef => {
            let entity = entity
                .get_reference()
                .expect("ObjCProtocolRef to reference entity");
            if protocols
                .insert(ItemIdentifier::new(&entity, context), entity)
                .is_none()
            {
                // Only recurse if we haven't already seen this protocol
                parse_protocols(&entity, protocols, context);
            }
        }
        EntityKind::ObjCSuperClassRef => {
            let entity = entity
                .get_reference()
                .expect("ObjCSuperClassRef to reference entity");
            parse_protocols(&entity, protocols, context);
        }
        _ => {}
    });
}

pub(crate) fn parse_superclasses<'ty>(
    entity: &Entity<'ty>,
    context: &Context<'_>,
) -> Vec<(ItemIdentifier, Vec<String>, Entity<'ty>)> {
    let mut current_entity = *entity;
    let mut superclasses = vec![];

    loop {
        let mut superclass = None;
        let mut applied_generics = Vec::new();

        immediate_children(&current_entity, |entity, _span| match entity.get_kind() {
            EntityKind::ObjCSuperClassRef => {
                superclass = Some(
                    entity
                        .get_reference()
                        .expect("ObjCSuperClassRef to reference entity"),
                );
            }
            EntityKind::TypeRef => {
                let name = entity.get_name().expect("typeref name");
                applied_generics.push(name);
            }
            _ => {}
        });

        if let Some(superclass) = superclass {
            current_entity = superclass;
            superclasses.push((
                ItemIdentifier::new(&superclass, context),
                applied_generics,
                superclass,
            ));
        } else {
            return superclasses;
        }
    }
}

fn parse_class_generics(entity: &Entity<'_>, _context: &Context<'_>) -> Vec<String> {
    let mut generics = Vec::new();

    #[allow(clippy::single_match)]
    immediate_children(entity, |entity, _span| match entity.get_kind() {
        EntityKind::TemplateTypeParameter => {
            // TODO: Generics with bounds (like NSMeasurement<UnitType: NSUnit *>)
            // let ty = entity.get_type().expect("template type");
            let name = entity.get_name().expect("template name");
            generics.push(name);
        }
        _ => {}
    });

    generics
}

/// Deduplicate methods that are autogenerated from properties.
///
/// Guaranteed to only contain `ObjCInstanceMethodDecl`, `ObjCClassMethodDecl`
/// and `ObjCPropertyDecl`.
pub(crate) fn method_or_property_entities<'tu>(
    entity: &Entity<'tu>,
    get_data: impl Fn(&str) -> MethodData,
) -> Vec<Entity<'tu>> {
    let mut entities = Vec::new();

    // Track seen properties, so that when methods are autogenerated by the
    // compiler from them, we can skip them
    let mut properties = HashSet::new();

    immediate_children(entity, |entity, _span| match entity.get_kind() {
        EntityKind::ObjCInstanceMethodDecl | EntityKind::ObjCClassMethodDecl => {
            let is_class = entity.get_kind() == EntityKind::ObjCClassMethodDecl;
            let selector = entity.get_name().expect("method selector");

            if get_data(&selector).skipped {
                return;
            }

            if !properties.remove(&(is_class, selector)) {
                entities.push(entity);
            }
        }
        EntityKind::ObjCPropertyDecl => {
            entities.push(entity);

            let partial = Method::partial_property(entity);

            // TODO: Use `get_overridden_methods` to deduplicate property
            // getters (when declared on both immutable and mutable class).

            if !get_data(&partial.getter_sel).skipped
                && !properties.insert((partial.is_class, partial.getter_sel.clone()))
            {
                error!(?partial, ?entity, "already existing getter property");
            }

            if let Some(setter_sel) = &partial.setter_sel {
                if !get_data(setter_sel).skipped
                    && !properties.insert((partial.is_class, setter_sel.clone()))
                {
                    error!(?partial, ?entity, "already existing setter property");
                }
            }
        }
        _ => {}
    });

    if !properties.is_empty() {
        error!(
            ?entities,
            ?properties,
            "did not properly add methods to properties"
        );
    }

    entities
}

fn parse_methods(
    entity: &Entity<'_>,
    get_data: impl Fn(&str) -> MethodData,
    thread_safety: &ThreadSafety,
    is_pub: bool,
    context: &Context<'_>,
) -> (Vec<Method>, Vec<String>) {
    let mut methods = Vec::new();
    let mut designated_initializers = Vec::new();

    for entity in method_or_property_entities(entity, &get_data) {
        match entity.get_kind() {
            EntityKind::ObjCInstanceMethodDecl | EntityKind::ObjCClassMethodDecl => {
                let selector = entity.get_name().expect("method selector");

                let data = get_data(&selector);

                if let Some((designated_initializer, method)) = Method::parse_method(
                    entity,
                    data,
                    thread_safety.inferred_mainthreadonly(),
                    is_pub,
                    context,
                ) {
                    if designated_initializer {
                        designated_initializers.push(method.selector.clone());
                    }
                    methods.push(method);
                }
            }
            EntityKind::ObjCPropertyDecl => {
                let partial = Method::partial_property(entity);

                // TODO: Use `get_overridden_methods` to deduplicate property
                // getters (when declared on both immutable and mutable class).

                let getter_data = get_data(&partial.getter_sel);
                let setter_data = partial
                    .setter_sel
                    .as_ref()
                    .map(|setter_sel| get_data(setter_sel));

                let (getter, setter) = Method::parse_property(
                    partial,
                    getter_data,
                    setter_data,
                    thread_safety.inferred_mainthreadonly(),
                    is_pub,
                    context,
                );
                if let Some(getter) = getter {
                    methods.push(getter);
                }
                if let Some(setter) = setter {
                    methods.push(setter);
                }
            }
            kind => unreachable!("method/property entity {kind:?}"),
        }
    }

    (methods, designated_initializers)
}

/// Takes one of:
/// - `EntityKind::ObjCInterfaceDecl`
/// - `EntityKind::ObjCProtocolDecl`
/// - `EntityKind::ObjCCategoryDecl`
fn verify_objc_decl(entity: &Entity<'_>, _context: &Context<'_>) {
    let parent_kind = entity.get_kind();

    immediate_children(entity, |entity, _span| {
        match (entity.get_kind(), parent_kind) {
            (EntityKind::ObjCExplicitProtocolImpl, EntityKind::ObjCProtocolDecl) => {
                // TODO NS_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION
            }
            (
                EntityKind::ObjCIvarDecl | EntityKind::StructDecl | EntityKind::UnionDecl,
                EntityKind::ObjCInterfaceDecl,
            ) => {
                // Explicitly ignored
            }
            (
                EntityKind::ObjCSuperClassRef | EntityKind::TypeRef,
                EntityKind::ObjCInterfaceDecl,
            ) => {
                // Parsed in parse_superclasses
            }
            (EntityKind::ObjCSubclassingRestricted, EntityKind::ObjCInterfaceDecl) => {
                // TODO: https://clang.llvm.org/docs/AttributeReference.html#objc-subclassing-restricted
            }
            (EntityKind::ObjCRootClass, EntityKind::ObjCInterfaceDecl) => {
                debug!("parsing root class");
            }
            (
                EntityKind::ObjCClassRef,
                EntityKind::ObjCInterfaceDecl | EntityKind::ObjCCategoryDecl,
            ) => {
                // debug!("ObjCClassRef: {:?}", entity.get_display_name());
            }
            (
                EntityKind::TemplateTypeParameter,
                EntityKind::ObjCInterfaceDecl | EntityKind::ObjCCategoryDecl,
            ) => {
                // Parsed in parse_class_generics
            }
            (EntityKind::ObjCProtocolRef, _) => {
                // Parsed in parse_protocols and parse_direct_protocols
            }
            (
                EntityKind::ObjCInstanceMethodDecl
                | EntityKind::ObjCClassMethodDecl
                | EntityKind::ObjCPropertyDecl,
                _,
            ) => {
                // Parsed in method_or_property_entities
            }
            (EntityKind::VisibilityAttr, _) => {
                // Already exposed as entity.get_visibility()
            }
            (EntityKind::ObjCException, EntityKind::ObjCInterfaceDecl) => {
                // Maybe useful for knowing when to implement `Error` for the type
            }
            (EntityKind::UnexposedAttr, _) => {
                // Parsed in parse_attributes
            }
            (_, parent_kind) => error!(?parent_kind, "unknown in parent"),
        }
    });
}

/// Whether the entity contains a bridging modifier.
pub(crate) fn is_bridged(entity: &Entity<'_>, context: &Context<'_>) -> bool {
    let mut is_bridged = false;
    immediate_children(entity, |entity, _span| {
        if let EntityKind::UnexposedAttr = entity.get_kind() {
            if let Some(attr) = UnexposedAttr::parse(&entity, context) {
                if matches!(
                    attr,
                    UnexposedAttr::Bridged
                        | UnexposedAttr::BridgedMutable
                        | UnexposedAttr::BridgedRelated
                        | UnexposedAttr::BridgedTypedef
                        | UnexposedAttr::BridgedImplicit
                ) {
                    is_bridged = true;
                }
            }
        }
    });
    is_bridged
}

pub(crate) fn anonymous_record_name(entity: &Entity<'_>, context: &Context<'_>) -> Option<String> {
    let parent = entity.get_semantic_parent()?;

    if !matches!(
        parent.get_kind(),
        EntityKind::StructDecl | EntityKind::UnionDecl
    ) {
        return None;
    }

    let parent_id = ItemIdentifier::new_optional(&parent, context)
        .map_name(|name| name.or_else(|| anonymous_record_name(&parent, context)))
        .to_option()?;

    // Find the field name for this.
    //
    // UnionDecl/StructDecl comes first, then the matching FieldDecl.
    let mut just_found_record = false;
    let mut field_name = None;
    immediate_children(&parent, |searched, _span| match searched.get_kind() {
        EntityKind::FieldDecl => {
            if just_found_record {
                field_name = Some(searched.get_name().expect("field name"));
                just_found_record = false;
            }
        }
        EntityKind::UnionDecl | EntityKind::StructDecl => {
            if searched == *entity {
                just_found_record = true;
            }
        }
        _ => {}
    });

    let field_name = field_name?;

    Some(format!("{}_{}", parent_id.name, field_name))
}

pub(crate) fn superclasses_required_items<'a, I>(
    superclasses: I,
) -> impl Iterator<Item = ItemTree> + 'a
where
    I: IntoIterator<Item = ItemIdentifier> + 'a,
    <I as IntoIterator>::IntoIter: Clone,
{
    let iter = superclasses.into_iter();
    iter.clone()
        .enumerate()
        .map(move |(i, superclass)| {
            ItemTree::new(
                superclass,
                superclasses_required_items(iter.clone().skip(i + 1).collect::<Vec<_>>()),
            )
        })
        .chain(iter::once(ItemTree::objc("__macros__")))
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, Default)]
pub enum Counterpart {
    #[default]
    NoCounterpart,
    ImmutableSuperclass(ItemIdentifier),
    MutableSubclass(ItemIdentifier),
}

#[derive(Debug, Clone, PartialEq)]
pub enum Stmt {
    /// @interface name: superclass <protocols*>
    /// ->
    /// extern_class!
    ClassDecl {
        id: ItemIdentifier,
        generics: Vec<String>,
        availability: Availability,
        /// Superclass + generics
        superclasses: Vec<(ItemIdentifier, Vec<String>)>,
        designated_initializers: Vec<String>,
        derives: Derives,
        main_thread_only: bool,
        skipped: bool,
        sendable: bool,
        documentation: Documentation,
    },
    /// @interface class_name (category_name) <protocols*>
    /// ->
    /// extern_methods!
    ExternMethods {
        location: Location,
        availability: Availability,
        cls: ItemIdentifier,
        cls_superclasses: Vec<ItemIdentifier>,
        source_superclass: Option<ItemIdentifier>,
        cls_generics: Vec<String>,
        category_name: Option<String>,
        methods: Vec<Method>,
        documentation: Option<Documentation>,
    },
    /// @interface class_name (category_name)
    /// ->
    /// impl trait category_name {
    ///     extern_methods!(...)
    /// }
    ///
    /// impl trait category_name for class_name {}
    ExternCategory {
        id: ItemIdentifier,
        actual_name: Option<String>,
        availability: Availability,
        cls: ItemIdentifier,
        cls_superclasses: Vec<ItemIdentifier>,
        cls_generics: Vec<String>,
        methods: Vec<Method>,
        documentation: Documentation,
    },
    /// @protocol name <protocols*>
    /// ->
    /// extern_protocol!
    ProtocolDecl {
        id: ItemIdentifier,
        actual_name: Option<String>,
        availability: Availability,
        super_protocols: Vec<ProtocolRef>,
        methods: Vec<Method>,
        required_sendable: bool,
        required_mainthreadonly: bool,
        documentation: Documentation,
    },
    /// @interface ty: _ <protocols*>
    /// @interface ty (_) <protocols*>
    ProtocolImpl {
        location: Location,
        cls: ItemIdentifier,
        cls_superclasses: Vec<ItemIdentifier>,
        cls_counterpart: Counterpart,
        protocol: ItemIdentifier,
        protocol_super_protocols: Vec<ProtocolRef>,
        generics: Vec<String>,
        availability: Availability,
    },
    /// struct name {
    ///     fields*
    /// };
    ///
    /// typedef struct {
    ///     fields*
    /// } name;
    ///
    /// typedef struct _name {
    ///     fields*
    /// } name;
    ///
    /// union name {
    ///     fields*
    /// };
    RecordDecl {
        id: ItemIdentifier,
        // internal objc struct name (before typedef). shows up in encoding
        // and is used in message verification.
        encoding_name: Option<String>,
        availability: Availability,
        boxable: bool,
        fields: Vec<(String, Documentation, Ty)>,
        sendable: Option<bool>,
        packed: bool,
        documentation: Documentation,
        is_union: bool,
    },
    /// typedef NS_OPTIONS(type, name) {
    ///     variants*
    /// };
    ///
    /// typedef NS_ENUM(type, name) {
    ///     variants*
    /// };
    ///
    /// enum name {
    ///     variants*
    /// };
    ///
    /// enum {
    ///     variants*
    /// };
    EnumDecl {
        id: ItemIdentifier,
        availability: Availability,
        ty: Ty,
        kind: Option<UnexposedAttr>,
        variants: Vec<(String, Documentation, Availability, Expr)>,
        sendable: Option<bool>,
        documentation: Documentation,
    },
    /// Anonymous enum variants are emitted as free constants.
    ///
    /// enum {
    ///     variants*
    /// };
    ConstDecl {
        id: ItemIdentifier,
        availability: Availability,
        ty: Ty,
        value: Expr,
        // Hack to get prettier output
        is_last: bool,
        documentation: Documentation,
    },
    /// static const ty name = expr;
    /// extern const ty name;
    VarDecl {
        id: ItemIdentifier,
        availability: Availability,
        ty: Ty,
        value: Option<Expr>,
        documentation: Documentation,
    },
    /// extern ret name(args*);
    ///
    /// static inline ret name(args*) {
    ///     body
    /// }
    FnDecl {
        id: ItemIdentifier,
        availability: Availability,
        arguments: Vec<(String, Ty)>,
        result_type: Ty,
        // Some -> inline function.
        body: Option<()>,
        safe: bool,
        must_use: bool,
        can_unwind: bool,
        link_name: Option<String>,
        returns_retained: bool,
        documentation: Documentation,
    },
    /// CFTypeID CGColorGetTypeID(void)
    FnGetTypeId {
        id: ItemIdentifier,
        cf_id: ItemIdentifier,
        result_type: Ty,
        availability: Availability,
        can_unwind: bool,
        documentation: Documentation,
    },
    /// typedef Type TypedefName;
    AliasDecl {
        id: ItemIdentifier,
        availability: Availability,
        ty: Ty,
        kind: Option<UnexposedAttr>,
        documentation: Documentation,
    },
    /// typedef struct CF_BRIDGED_TYPE(id) CGColorSpace *CGColorSpaceRef;
    OpaqueDecl {
        id: ItemIdentifier,
        generics: Vec<String>,
        encoding_name: String,
        availability: Availability,
        documentation: Documentation,
        is_cf: bool,
        superclass: Option<ItemIdentifier>,
    },
}

fn parse_fn_param_children(parent: &Entity<'_>, context: &Context<'_>) -> Option<UnexposedAttr> {
    let mut ret = None;

    immediate_children(parent, |entity, _span| match entity.get_kind() {
        EntityKind::UnexposedAttr => {
            if let Some(attr) = UnexposedAttr::parse(&entity, context) {
                if ret.is_some() {
                    error!("found multiple attributes {ret:?} and {attr:?} on fn param");
                }
                ret = Some(attr);
            }
        }
        EntityKind::ObjCClassRef
        | EntityKind::TypeRef
        | EntityKind::ObjCProtocolRef
        | EntityKind::ParmDecl => {}
        EntityKind::NSConsumed => {
            error!("found NSConsumed, which requires manual handling");
        }
        // For some reason we recurse into array types
        EntityKind::IntegerLiteral => {}
        kind => error!(?parent, ?kind, "unknown"),
    });

    ret
}

impl Stmt {
    pub fn parse(entity: &Entity<'_>, context: &Context<'_>) -> Vec<Self> {
        let _span = debug_span!(
            "stmt",
            kind = ?entity.get_kind(),
            dbg = entity.get_name(),
        )
        .entered();

        match entity.get_kind() {
            // These are inconsequential for us, since we resolve imports differently
            EntityKind::ObjCClassRef | EntityKind::ObjCProtocolRef => vec![],
            EntityKind::ObjCInterfaceDecl => {
                // entity.get_mangled_objc_names()
                let id = ItemIdentifier::new(entity, context);
                let data = context.library(&id).class_data.get(&id.name);

                if data.map(|data| data.skipped).unwrap_or_default() {
                    return vec![];
                }

                let availability = Availability::parse(entity, context);
                let thread_safety = ThreadSafety::from_decl(entity, context);

                let counterpart = data
                    .map(|data| data.counterpart.clone())
                    .unwrap_or_default();

                verify_objc_decl(entity, context);
                let generics = parse_class_generics(entity, context);
                let (methods, designated_initializers) = parse_methods(
                    entity,
                    |name| ClassData::get_method_data(data, name),
                    &thread_safety,
                    true,
                    context,
                );

                let mut protocols = Default::default();
                parse_protocols(entity, &mut protocols, context);
                let skipped_protocols = data
                    .map(|data| data.skipped_protocols.clone())
                    .unwrap_or_default();
                protocols.retain(|protocol, _| !skipped_protocols.contains(&protocol.name));

                let superclasses_full = parse_superclasses(entity, context);

                let superclasses: Vec<_> = superclasses_full
                    .iter()
                    .map(|(id, generics, _)| (id.clone(), generics.clone()))
                    .collect();
                let cls_superclasses: Vec<_> = superclasses_full
                    .iter()
                    .map(|(id, _, _)| id.clone())
                    .collect();

                // Used for duplicate checking (sometimes the subclass
                // defines the same method that the superclass did).
                let mut seen_methods: BTreeSet<_> =
                    methods.iter().map(|method| method.id()).collect();

                let superclass_methods: Vec<_> = superclasses_full
                    .iter()
                    .filter_map(|(superclass_id, _, entity)| {
                        let superclass_data = context
                            .library(superclass_id)
                            .class_data
                            .get(&superclass_id.name);

                        // Explicitly keep going, even if the class itself is skipped
                        // if superclass_data.skipped

                        let (mut methods, _) = parse_methods(
                            entity,
                            |name| {
                                let data = ClassData::get_method_data(data, name);
                                let superclass_data =
                                    ClassData::get_method_data(superclass_data, name);
                                data.merge_with_superclass(superclass_data)
                            },
                            &thread_safety,
                            true,
                            context,
                        );
                        methods.retain(|method| {
                            method.emit_on_subclasses() && !seen_methods.contains(&method.id())
                        });
                        seen_methods.extend(methods.iter().map(|method| method.id()));
                        if methods.is_empty() {
                            None
                        } else {
                            Some(Self::ExternMethods {
                                location: id.location().clone(),
                                availability: availability.clone(),
                                cls: id.clone(),
                                cls_superclasses: cls_superclasses.clone(),
                                source_superclass: Some(superclass_id.clone()),
                                cls_generics: generics.clone(),
                                category_name: None,
                                methods,
                                documentation: None,
                            })
                        }
                    })
                    .collect();

                let methods = Self::ExternMethods {
                    location: id.location().clone(),
                    availability: availability.clone(),
                    cls: id.clone(),
                    cls_superclasses: cls_superclasses.clone(),
                    source_superclass: None,
                    cls_generics: generics.clone(),
                    category_name: None,
                    methods,
                    documentation: None,
                };

                iter::once(Self::ClassDecl {
                    id: id.clone(),
                    generics: generics.clone(),
                    availability: availability.clone(),
                    superclasses,
                    designated_initializers,
                    derives: data.map(|data| data.derives.clone()).unwrap_or_default(),
                    main_thread_only: thread_safety.explicit_mainthreadonly(),
                    skipped: data.map(|data| data.definition_skipped).unwrap_or_default(),
                    // Ignore sendability on superclasses; since it's an auto
                    // trait, it's propagated to subclasses anyhow!
                    sendable: thread_safety.explicit_sendable(),
                    documentation: Documentation::from_entity(entity),
                })
                .chain(protocols.into_iter().map(|(p, entity)| Self::ProtocolImpl {
                    location: id.location().clone(),
                    cls: id.clone(),
                    cls_superclasses: cls_superclasses.clone(),
                    cls_counterpart: counterpart.clone(),
                    protocol: context.replace_protocol_name(p),
                    protocol_super_protocols: ProtocolRef::super_protocols(&entity, context),
                    generics: generics.clone(),
                    availability: availability.clone(),
                }))
                .chain(iter::once(methods))
                .chain(superclass_methods)
                .collect()
            }
            EntityKind::ObjCCategoryDecl => {
                let category = ItemIdentifier::new_optional(entity, context);
                let availability = Availability::parse(entity, context);

                let mut cls_entity = None;
                entity.visit_children(|entity, _parent| {
                    if entity.get_kind() == EntityKind::ObjCClassRef {
                        if cls_entity.is_some() {
                            panic!("could not find unique category class")
                        }
                        let definition = entity
                            .get_definition()
                            .expect("category class ref definition");
                        cls_entity = Some(definition);
                        EntityVisitResult::Break
                    } else {
                        EntityVisitResult::Continue
                    }
                });
                let cls_entity = cls_entity.expect("could not find category class");

                let cls = ItemIdentifier::new(&cls_entity, context);
                let data = context.library(&category).class_data.get(&cls.name);

                if data.map(|data| data.skipped).unwrap_or_default() {
                    return vec![];
                }

                let category_data = if let Some(category_name) = &category.name {
                    data.and_then(|data| data.categories.get(category_name))
                        .cloned()
                        .unwrap_or_default()
                } else {
                    Default::default()
                };

                if category_data.skipped {
                    return vec![];
                }

                let cls_thread_safety = ThreadSafety::from_decl(&cls_entity, context);
                let cls_superclasses: Vec<_> = parse_superclasses(&cls_entity, context)
                    .into_iter()
                    .map(|(id, _, _)| id)
                    .collect();
                let cls_counterpart = data
                    .map(|data| data.counterpart.clone())
                    .unwrap_or_default();

                verify_objc_decl(entity, context);
                let generics = parse_class_generics(entity, context);

                let skipped_protocols = data
                    .map(|data| data.skipped_protocols.clone())
                    .unwrap_or_default();
                let protocols = parse_direct_protocols(entity, context);
                let protocols: BTreeMap<_, _> = protocols
                    .into_iter()
                    .map(|entity| (ItemIdentifier::new(&entity, context), entity))
                    .filter(|(protocol, _)| !skipped_protocols.contains(&protocol.name))
                    .collect();

                let protocol_impls = protocols.into_iter().map(|(p, entity)| Self::ProtocolImpl {
                    location: category.location().clone(),
                    cls: cls.clone(),
                    cls_superclasses: cls_superclasses.clone(),
                    cls_counterpart: cls_counterpart.clone(),
                    generics: generics.clone(),
                    availability: availability.clone(),
                    protocol: context.replace_protocol_name(p),
                    protocol_super_protocols: ProtocolRef::super_protocols(&entity, context),
                });

                // For ease-of-use, if the category is defined in the same
                // library as the class, we just emit it as `extern_methods!`.
                if cls.library_name() == category.library_name() {
                    assert!(
                        category_data.renamed.is_none(),
                        "cannot rename categories emitted in same crate"
                    );

                    // extern_methods!

                    let (methods, designated_initializers) = parse_methods(
                        entity,
                        |name| ClassData::get_method_data(data, name),
                        &cls_thread_safety,
                        true,
                        context,
                    );

                    if !designated_initializers.is_empty() {
                        warn!(
                            ?designated_initializers,
                            "designated initializer in category"
                        );
                    }

                    let extra_methods = if let Counterpart::MutableSubclass(subclass) = data
                        .map(|data| data.counterpart.clone())
                        .unwrap_or_default()
                    {
                        let subclass_data =
                            context.library(&subclass).class_data.get(&subclass.name);
                        assert!(!subclass_data.map(|data| data.skipped).unwrap_or_default());

                        let (mut methods, _) = parse_methods(
                            entity,
                            |name| {
                                let data = ClassData::get_method_data(data, name);
                                let subclass_data = ClassData::get_method_data(subclass_data, name);
                                subclass_data.merge_with_superclass(data)
                            },
                            &cls_thread_safety,
                            true,
                            context,
                        );
                        methods.retain(|method| method.emit_on_subclasses());
                        if methods.is_empty() {
                            None
                        } else {
                            Some(Self::ExternMethods {
                                location: category.location().clone(),
                                source_superclass: Some(cls.clone()),
                                // Assume that immutable/mutable pairs have the
                                // same availability ...
                                availability: availability.clone(),
                                cls: subclass,
                                // ... the same required items ...
                                cls_superclasses: cls_superclasses.clone(),
                                // ... and that they have the same amount of generics.
                                cls_generics: generics.clone(),
                                category_name: category.name.clone(),
                                methods,
                                documentation: Some(Documentation::from_entity(entity)),
                            })
                        }
                    } else {
                        None
                    };

                    iter::once(Self::ExternMethods {
                        location: category.location().clone(),
                        availability: availability.clone(),
                        cls: cls.clone(),
                        cls_superclasses: cls_superclasses.clone(),
                        source_superclass: None,
                        cls_generics: generics.clone(),
                        category_name: category.name.clone(),
                        methods,
                        documentation: Some(Documentation::from_entity(entity)),
                    })
                    .chain(extra_methods)
                    .chain(protocol_impls)
                    .collect()
                } else {
                    // external category

                    // Rough heuristic to determine category name.
                    //
                    // Note: There isn't really a good way to do this, as
                    // category names are not part of the public API in
                    // Objective-C.
                    let id = category.clone().map_name(|name| {
                        if let Some(name) = category_data.renamed {
                            name
                        } else if let Some(name) = name {
                            if name.contains(&cls.name)
                                || name.contains(&cls.name.replace("Mutable", ""))
                            {
                                name.clone()
                            } else {
                                format!("{}{}", cls.name, name)
                            }
                        } else {
                            error!(?cls, "missing category name for external category");
                            format!("{}Category", cls.name)
                        }
                    });

                    let (methods, designated_initializers) = parse_methods(
                        entity,
                        |name| ClassData::get_method_data(data, name),
                        &cls_thread_safety,
                        false,
                        context,
                    );

                    if !designated_initializers.is_empty() {
                        warn!(
                            ?designated_initializers,
                            "designated initializer in category"
                        );
                    }

                    // Categories are often used to implement protocols for a
                    // type, so as an optimization let's not emit empty
                    // external declarations.
                    //
                    // Additionally, if all methods are deprecated, then there
                    // really isn't a need for us to emit the category
                    // (especially on NSObject, as that just adds a bunch of
                    // clutter).
                    if methods
                        .iter()
                        .all(|method| method.availability.is_deprecated())
                    {
                        None
                    } else {
                        Some(Self::ExternCategory {
                            id,
                            actual_name: category.name.clone(),
                            availability: availability.clone(),
                            cls: cls.clone(),
                            cls_superclasses: cls_superclasses.clone(),
                            cls_generics: generics.clone(),
                            methods,
                            documentation: Documentation::from_entity(entity),
                        })
                    }
                    .into_iter()
                    .chain(protocol_impls)
                    .collect()
                }
            }
            EntityKind::ObjCProtocolDecl => {
                let actual_id = ItemIdentifier::new(entity, context);
                let data = context
                    .library(&actual_id)
                    .protocol_data
                    .get(&actual_id.name);
                let actual_name = data
                    .map(|data| data.renamed.is_some())
                    .unwrap_or_default()
                    .then(|| actual_id.name.clone());

                let id = context.replace_protocol_name(actual_id);

                if data.map(|data| data.skipped).unwrap_or_default() {
                    return vec![];
                }

                let availability = Availability::parse(entity, context);
                let thread_safety = ThreadSafety::from_decl(entity, context);

                verify_objc_decl(entity, context);
                let (methods, designated_initializers) = parse_methods(
                    entity,
                    |name| {
                        data.and_then(|data| data.methods.get(name))
                            .copied()
                            .unwrap_or_default()
                    },
                    &thread_safety,
                    false,
                    context,
                );

                if !designated_initializers.is_empty() {
                    warn!(
                        ?designated_initializers,
                        "designated initializer in protocol"
                    )
                }

                vec![Self::ProtocolDecl {
                    id,
                    actual_name,
                    availability,
                    super_protocols: ProtocolRef::super_protocols(entity, context),
                    methods,
                    required_sendable: thread_safety.explicit_sendable(),
                    required_mainthreadonly: thread_safety.explicit_mainthreadonly(),
                    documentation: Documentation::from_entity(entity),
                }]
            }
            EntityKind::TypedefDecl => {
                let id = ItemIdentifier::new(entity, context);
                let availability = Availability::parse(entity, context);
                let documentation = Documentation::from_entity(entity);

                let data = context
                    .library(&id)
                    .typedef_data
                    .get(&id.name)
                    .cloned()
                    .unwrap_or_default();

                if data.skipped {
                    return vec![];
                }

                let mut kind = None;
                let mut inner_struct = None;

                immediate_children(entity, |entity, _span| match entity.get_kind() {
                    EntityKind::UnexposedAttr => {
                        if let Some(attr) = UnexposedAttr::parse(&entity, context) {
                            match attr {
                                // TODO
                                UnexposedAttr::Sendable => warn!("sendable typedef"),
                                UnexposedAttr::NonSendable => warn!("non-sendable typedef"),
                                UnexposedAttr::UIActor => warn!("main-thread-only typedef"),
                                _ => {
                                    if kind.is_some() {
                                        warn!(?kind, ?attr, "got multiple unexposed attributes");
                                    }
                                    kind = Some(attr);
                                }
                            }
                        }
                    }
                    EntityKind::TypeRef => {
                        inner_struct =
                            Some(entity.get_reference().expect("typeref to have reference"));
                    }
                    EntityKind::StructDecl
                    | EntityKind::UnionDecl
                    | EntityKind::ObjCClassRef
                    | EntityKind::ObjCProtocolRef
                    | EntityKind::ParmDecl
                    | EntityKind::EnumDecl
                    | EntityKind::IntegerLiteral
                    | EntityKind::BinaryOperator
                    | EntityKind::DeclRefExpr
                    | EntityKind::ParenExpr => {}
                    EntityKind::ObjCIndependentClass => {
                        // TODO: Might be interesting?
                    }
                    _ => error!(?entity, "unknown typedef child"),
                });

                let ty = entity
                    .get_typedef_underlying_type()
                    .expect("typedef underlying type");
                let ty = Ty::parse_typedef(ty, context);

                if ty.needs_simd() {
                    debug!("simd types are not yet possible in typedefs");
                    return vec![];
                }

                // No need to output a typedef if it'll just point to the same thing.
                //
                // TODO: We're discarding a slight bit of availability data this way.
                if ty.is_enum(&id.name) || ty.is_record(&id.name) {
                    return vec![];
                }

                if let Some((is_cf, encoding_name)) =
                    ty.pointer_to_opaque_struct_or_void(&id.name, is_bridged(entity, context))
                {
                    if kind.is_some() {
                        error!(?kind, "unknown kind on opaque type");
                    }

                    assert_eq!(
                        inner_struct
                            .as_ref()
                            .map(|entity| entity.get_name().unwrap())
                            .as_deref(),
                        encoding_name,
                        "inner struct must be the same that `pointer_to_opaque_struct_or_void` found",
                    );

                    if is_cf {
                        let id = context.replace_typedef_name(id, is_cf);

                        // If the class name contains the word "Mutable"
                        // exactly once per the usual word-boundary rules, a
                        // corresponding class name without the word "Mutable"
                        // will be used as the superclass if present.
                        // Otherwise, the CF type is taken to be a root object.
                        let is_mutable = split_words(&id.name)
                            .filter(|word| *word == "Mutable")
                            .count()
                            == 1;
                        let superclass = if is_mutable {
                            // Assume that class pairs are declared in the same file.
                            Some(id.clone().map_name(|name| name.replace("Mutable", "")))
                        } else {
                            None
                        };

                        return vec![Self::OpaqueDecl {
                            id,
                            generics: data.generics.clone(),
                            encoding_name: encoding_name.unwrap().to_string(),
                            availability,
                            documentation,
                            is_cf,
                            superclass,
                        }];
                    } else if let Some(entity) = inner_struct {
                        let mut record_id = ItemIdentifier::new(&entity, context);

                        // Replace module from external data if it exists.
                        if let Some(external) =
                            context.library(&record_id).external.get(&record_id.name)
                        {
                            record_id =
                                ItemIdentifier::from_raw(record_id.name, external.module.clone());
                        }

                        return vec![
                            Self::OpaqueDecl {
                                id: record_id,
                                generics: data.generics.clone(),
                                encoding_name: encoding_name.unwrap().to_string(),
                                availability: Availability::parse(&entity, context),
                                documentation: Documentation::from_entity(&entity),
                                is_cf,
                                superclass: None,
                            },
                            Self::AliasDecl {
                                id,
                                availability,
                                ty,
                                kind,
                                documentation,
                            },
                        ];
                    }
                }

                vec![Self::AliasDecl {
                    id: context.replace_typedef_name(id, ty.is_cf_type_ptr()),
                    availability,
                    ty,
                    kind,
                    documentation,
                }]
            }
            EntityKind::StructDecl | EntityKind::UnionDecl => {
                let is_union = entity.get_kind() == EntityKind::UnionDecl;
                let id = ItemIdentifier::new_optional(entity, context)
                    .map_name(|name| name.or_else(|| anonymous_record_name(entity, context)))
                    .to_option();
                let Some(mut id) = id else {
                    warn!(?entity, "skipped anonymous union/struct");
                    return vec![];
                };
                let availability = Availability::parse(entity, context);

                let library = context.library(&id);
                let data = if is_union {
                    &library.union_data
                } else {
                    &library.struct_data
                }
                .get(&id.name)
                .cloned()
                .unwrap_or_default();

                if data.skipped {
                    return vec![];
                }

                // See https://github.com/rust-lang/rust-bindgen/blob/95fd17b874910184cc0fcd33b287fa4e205d9d7a/bindgen/ir/comp.rs#L1392-L1408
                if !entity.is_definition() {
                    return vec![];
                }

                let ty = entity.get_type().unwrap();
                let enc = ty.get_objc_encoding().expect("record has encoding");
                let encoding_name = enc
                    .strip_prefix('{')
                    .unwrap_or_else(|| {
                        enc.strip_prefix('(')
                            .expect("record has { or ( in encoding")
                    })
                    .split_once('=')
                    .unwrap()
                    .0;
                let encoding_name = if encoding_name == id.name {
                    None
                } else {
                    Some(encoding_name.to_string())
                };

                let mut boxable = false;
                let mut fields = Vec::new();
                let mut sendable = None;
                let mut packed = false;

                let mut res = vec![];

                immediate_children(entity, |entity, span| match entity.get_kind() {
                    EntityKind::UnexposedAttr => {
                        if let Some(attr) = UnexposedAttr::parse(&entity, context) {
                            match attr {
                                UnexposedAttr::Sendable => sendable = Some(true),
                                UnexposedAttr::NonSendable => sendable = Some(false),
                                attr => error!(?attr, "unknown attribute on struct/union"),
                            }
                        }
                    }
                    EntityKind::FieldDecl => {
                        drop(span);
                        let name = entity.get_name().unwrap_or_else(|| "__unknown__".into());
                        let _span = debug_span!("field", name).entered();

                        let ty = entity.get_type().expect("struct/union field type");
                        let ty = Ty::parse_record_field(ty, context);

                        if entity.is_bit_field() {
                            error!("unsound struct/union bitfield");
                        }

                        let documentation = Documentation::from_entity(&entity);
                        fields.push((name, documentation, ty))
                    }
                    EntityKind::ObjCBoxable => {
                        boxable = true;
                    }
                    EntityKind::UnionDecl | EntityKind::StructDecl => {
                        // Recursively parse inner unions and structs, but
                        // emit them at the top-level.
                        res.extend(Self::parse(&entity, context));
                    }
                    EntityKind::PackedAttr => packed = true,
                    EntityKind::VisibilityAttr => {}
                    _ => error!(?entity, "unknown struct/union child"),
                });

                if fields.iter().any(|(_, _, field_ty)| field_ty.needs_simd()) {
                    debug!("simd types are not yet possible in struct/union");
                    return res;
                }

                // Replace module from external data if it exists.
                if let Some(external) = context.library(&id).external.get(&id.name) {
                    id = ItemIdentifier::from_raw(id.name, external.module.clone());
                }

                res.push(Self::RecordDecl {
                    id,
                    encoding_name,
                    availability,
                    boxable,
                    fields,
                    sendable,
                    packed,
                    documentation: Documentation::from_entity(entity),
                    is_union,
                });

                res
            }
            EntityKind::EnumDecl => {
                // Enum declarations show up twice for some reason, but
                // luckily this flag is set on the least descriptive entity.
                if !entity.is_definition() {
                    return vec![];
                }

                let id = ItemIdentifier::new_optional(entity, context);

                let data = context
                    .library(&id)
                    .enum_data
                    .get(id.name.as_deref().unwrap_or("__anonymous__"))
                    .cloned()
                    .unwrap_or_default();
                if data.skipped {
                    return vec![];
                }

                let availability = Availability::parse(entity, context);

                let ty = entity.get_enum_underlying_type().expect("enum type");
                let mut ty = Ty::parse_enum(ty, context);
                let is_signed = ty.is_signed().unwrap_or_else(|| {
                    error!(?ty, "cannot determine signed-ness of enum");
                    false
                });
                let mut kind = None;
                let mut variants = Vec::new();
                let mut sendable = None;

                immediate_children(entity, |entity, _span| match entity.get_kind() {
                    EntityKind::EnumConstantDecl => {
                        let name = entity.get_name().expect("enum constant name");
                        let availability = Availability::parse(&entity, context);

                        let const_data = context
                            .library(&id)
                            .const_data
                            .get(&name)
                            .cloned()
                            .unwrap_or_default();

                        if const_data.skipped.unwrap_or(false) {
                            return;
                        }

                        let value = entity
                            .get_enum_constant_value()
                            .expect("enum constant value");

                        let mut expr = if is_signed {
                            Expr::Signed(value.0)
                        } else {
                            Expr::Unsigned(value.1)
                        };

                        if !(const_data.use_value.or(data.use_value).unwrap_or(false)) {
                            // Some enums constants don't declare a value, but
                            // let it be inferred from the position in the
                            // enum instead; in those cases, we use the value
                            // generated above.
                            immediate_children(&entity, |entity, _span| match entity.get_kind() {
                                EntityKind::UnexposedAttr => {
                                    if let Some(attr) = UnexposedAttr::parse(&entity, context) {
                                        match attr {
                                            UnexposedAttr::Enum
                                            | UnexposedAttr::Options
                                            | UnexposedAttr::ClosedEnum
                                            | UnexposedAttr::ErrorEnum => {
                                                if kind.as_ref() != Some(&attr) {
                                                    error!(?kind, ?attr, "enum child had attribute that parent did not");
                                                }
                                            }
                                            attr => {
                                                error!(?attr, "unknown attribute on enum constant")
                                            }
                                        }
                                    }
                                }
                                EntityKind::VisibilityAttr => {}
                                _ if entity.is_expression() => {
                                    expr = Expr::parse_enum_constant(&entity, context);
                                }
                                _ => {
                                    panic!("unknown EnumConstantDecl child in {name:?}: {entity:?}")
                                }
                            });
                        };

                        let documentation = Documentation::from_entity(&entity);

                        if ty.is_simple_uint() {
                            ty = expr.guess_type(id.location());
                        }

                        variants.push((name, documentation, availability, expr));
                    }
                    EntityKind::UnexposedAttr => {
                        if let Some(attr) = UnexposedAttr::parse(&entity, context) {
                            match attr {
                                UnexposedAttr::Sendable => sendable = Some(true),
                                UnexposedAttr::NonSendable => sendable = Some(false),
                                attr => {
                                    if let Some(kind) = &kind {
                                        assert_eq!(
                                            kind, &attr,
                                            "got differing enum kinds in {id:?}"
                                        );
                                    } else {
                                        kind = Some(attr);
                                    }
                                }
                            }
                        }
                    }
                    EntityKind::FlagEnum => {
                        let macro_ = UnexposedAttr::Options;
                        if let Some(kind) = &kind {
                            assert_eq!(kind, &macro_, "got differing enum kinds in {id:?}");
                        } else {
                            kind = Some(macro_);
                        }
                    }
                    EntityKind::VisibilityAttr => {
                        // Already exposed as entity.get_visibility()
                    }
                    _ => error!("unknown"),
                });

                if id.name.is_none() {
                    // Availability propagates to the variants automatically
                    let _ = availability;
                    // TODO: Unsure how to handle error enums
                    assert!(matches!(
                        kind,
                        None | Some(UnexposedAttr::Enum) | Some(UnexposedAttr::ErrorEnum)
                    ));
                    assert_eq!(sendable, None);
                    let variants_len = variants.len();
                    variants
                        .into_iter()
                        .enumerate()
                        .map(
                            |(i, (name, documentation, availability, value))| Self::ConstDecl {
                                id: id.clone().map_name(|_| name),
                                availability,
                                ty: ty.clone(),
                                value,
                                is_last: i == variants_len - 1,
                                documentation,
                            },
                        )
                        .collect()
                } else {
                    vec![Self::EnumDecl {
                        id: id.map_name(|name| name.unwrap()),
                        availability,
                        ty,
                        kind,
                        variants,
                        sendable,
                        documentation: Documentation::from_entity(entity),
                    }]
                }
            }
            EntityKind::VarDecl => {
                let id = ItemIdentifier::new(entity, context);

                let data = context
                    .library(&id)
                    .statics
                    .get(&id.name)
                    .cloned()
                    .unwrap_or_default();

                if data.skipped {
                    return vec![];
                }

                if id.name == "NDR_record" {
                    return vec![];
                }

                let availability = Availability::parse(entity, context);
                let ty = entity.get_type().expect("var type");
                let ty = Ty::parse_static(ty, context);
                let mut value = None;

                if ty.needs_simd() {
                    debug!("simd types are not yet possible in statics");
                    return vec![];
                }

                immediate_children(entity, |entity, _span| match entity.get_kind() {
                    EntityKind::UnexposedAttr => {
                        if let Some(attr) = UnexposedAttr::parse(&entity, context) {
                            match attr {
                                // Swift makes some statics associated with a
                                // certain type, which means it needs this to
                                // allow accessing them from any thread. We
                                // don't generally restrict statics in this
                                // fashion, so it shouldn't matter for us.
                                UnexposedAttr::NonIsolated => {}
                                attr => error!(?attr, "unknown attribute on var"),
                            }
                        }
                    }
                    EntityKind::VisibilityAttr => {}
                    EntityKind::ObjCClassRef => {}
                    EntityKind::TypeRef => {}
                    _ if entity.is_expression() => {
                        if value.is_none() {
                            if data.use_value {
                                value = Some(Expr::from_evaluated(&entity));
                            } else {
                                value = Some(Expr::parse_var(&entity, context));
                            }
                        } else {
                            error!(?value, ?entity, "got variable value twice");
                        }
                    }
                    _ => error!(?id, ?entity, "unknown vardecl child"),
                });

                vec![Self::VarDecl {
                    id,
                    availability,
                    ty,
                    value,
                    documentation: Documentation::from_entity(entity),
                }]
            }
            EntityKind::FunctionDecl => {
                let id = ItemIdentifier::new(entity, context);

                let data = context
                    .library(&id)
                    .fns
                    .get(&id.name)
                    .cloned()
                    .unwrap_or_default();

                if data.skipped {
                    return vec![];
                }

                if entity.is_variadic() {
                    warn!("can't handle variadic function");
                    return vec![];
                }

                let availability = Availability::parse(entity, context);
                let documentation = Documentation::from_entity(entity);
                let result_type = entity.get_result_type().expect("function result type");
                let result_type = Ty::parse_function_return(result_type, context);
                let mut arguments = Vec::new();
                let mut must_use = false;
                // Assume by default that functions can unwind.
                let mut can_unwind = true;
                let mut link_name = None;

                if entity.is_static_method() {
                    warn!("unexpected static method");
                }

                let mut returns_retained = follows_create_rule(&id.name);

                immediate_children(entity, |entity, _span| match entity.get_kind() {
                    EntityKind::UnexposedAttr => {
                        if let Some(attr) = UnexposedAttr::parse(&entity, context) {
                            match attr {
                                // TODO
                                UnexposedAttr::UIActor => {
                                    warn!("unhandled UIActor on function declaration")
                                }
                                UnexposedAttr::BridgedImplicit => {}
                                UnexposedAttr::ReturnsRetained => {
                                    // Override the inferred value.
                                    returns_retained = true;
                                }
                                UnexposedAttr::ReturnsNotRetained => {
                                    // Override the inferred value.
                                    returns_retained = false;
                                }
                                UnexposedAttr::NoThrow => {
                                    can_unwind = false;
                                }
                                _ => error!(?attr, "unknown attribute on function"),
                            }
                        }
                    }
                    EntityKind::ObjCClassRef
                    | EntityKind::TypeRef
                    | EntityKind::ObjCProtocolRef => {}
                    EntityKind::ParmDecl => {
                        let attr = parse_fn_param_children(&entity, context);
                        // Could also be retrieved via `get_arguments`
                        let name = entity.get_name().unwrap_or_else(|| "_".into());
                        let ty = entity.get_type().expect("function argument type");
                        let ty = Ty::parse_function_argument(ty, attr, context);
                        arguments.push((name, ty))
                    }
                    EntityKind::WarnUnusedResultAttr => {
                        must_use = true;
                    }
                    EntityKind::PureAttr | EntityKind::ConstAttr => {
                        // Ignore, we currently have no way of marking
                        // external functions as pure in Rust.
                    }
                    EntityKind::AsmLabelAttr => {
                        let name = entity.get_name().expect("asm label to have name");
                        let name = if let Some(name) = name.strip_prefix('_') {
                            name.to_string()
                        } else {
                            error!(?name, "symbol did not start with _");
                            name
                        };
                        link_name = Some(name);
                    }
                    EntityKind::VisibilityAttr => {
                        // CG_EXTERN or UIKIT_EXTERN
                    }
                    _ => error!("unknown"),
                });

                if result_type.needs_simd()
                    || arguments.iter().any(|(_, arg_ty)| arg_ty.needs_simd())
                {
                    debug!("simd types are not yet possible in functions");
                    return vec![];
                }

                if let Some((_, first_ty)) = arguments.first_mut() {
                    first_ty.fix_fn_first_argument_cf_nullability(&id.name);
                }

                // Don't map `CFRetain`, `CFRelease`, `CFAutorelease`, as well
                // as custom ones like as `CGColorRelease`, but not things
                // like `CMBufferQueueDequeueAndRetain`.
                //
                // Roughly the same as what Swift does:
                // <https://github.com/swiftlang/swift/blob/swift-6.0.3-RELEASE/lib/ClangImporter/ImportDecl.cpp#L8435-L8452>
                //
                // Users can achieve (almost) the same by using `CFRetained`
                // and `ManuallyDrop`, and this is clearer and safer.
                //
                // Besides, these do not have the necessary memory management
                // attributes (cf_consumed/cf_returns_retained), and as such
                // cannot be mapped correctly without extra hacks.
                if (id.name.ends_with("Retain")
                    || id.name.ends_with("Release")
                    || id.name.ends_with("Autorelease"))
                    && !id.name.ends_with("AndRetain")
                {
                    if let Some((_, first_arg_ty)) = arguments.first() {
                        if first_arg_ty.is_cf_type_ptr() {
                            return vec![];
                        }
                    }
                }

                let body = if entity.is_inline_function() {
                    Some(())
                } else {
                    None
                };

                if id.name.ends_with("GetTypeID") && id.name != "CFGetTypeID" {
                    assert!(arguments.is_empty(), "{id:?} must have no arguments");
                    assert!(result_type.is_cf_type_id(), "{id:?} must return CFTypeID");
                    assert!(body.is_none(), "{id:?} must not be inline");
                    assert!(
                        data.unsafe_,
                        "{id:?} must not have manually modified safety"
                    );
                    assert!(!must_use, "{id:?} must not have must_use");
                    assert!(link_name.is_none(), "{id:?} must not have link_name");
                    assert!(!returns_retained, "{id:?} must not have returns_retained");

                    return vec![Self::FnGetTypeId {
                        id,
                        // Will get replaced in global_analysis with the actual id.
                        cf_id: ItemIdentifier::dummy(0),
                        result_type,
                        availability,
                        can_unwind,
                        documentation,
                    }];
                }

                vec![Self::FnDecl {
                    id,
                    availability,
                    arguments,
                    result_type,
                    body,
                    safe: !data.unsafe_,
                    must_use,
                    can_unwind,
                    link_name,
                    returns_retained,
                    documentation,
                }]
            }
            EntityKind::UnexposedDecl => {
                // `@compatibility_alias`, can be ignored (since we don't
                // need to support older SDK versions).
                vec![]
            }
            _ => {
                error!("unknown");
                vec![]
            }
        }
    }

    /// Ideally, we'd import macros in a similar fashion as Swift does:
    /// <https://github.com/swiftlang/swift/blob/swift-6.0.3-RELEASE/docs/HowSwiftImportsCAPIs.md#macros>
    /// <https://developer.apple.com/documentation/swift/using-imported-c-macros-in-swift>
    ///
    /// I couldn't figure out a clean way to do that though, so our impl is a bit messy.
    pub fn parse_macro_definition(entity: &Entity<'_>, context: &Context<'_>) -> Option<Self> {
        let id = ItemIdentifier::new(entity, context);

        if entity.is_function_like_macro() {
            // Ignore function-like macros for now.
            return None;
        };

        let data = context
            .library(&id)
            .const_data
            .get(&id.name)
            .cloned()
            .unwrap_or_default();

        if data.skipped.unwrap_or(false) {
            return None;
        }

        if data.skipped.is_none()
            && !id.name.starts_with('k')
            && !id.name.to_lowercase().contains("version")
        {
            // By default, we want to map macros that start with "k", or
            // contain the word "version". Seems to get us most of the things
            // we want, without emitting weird things like `CG_INLINE`.
            return None;
        }

        let mut value = Expr::parse_macro_definition(entity, context)?;
        let _ = value.update_idents(&context.ident_mapping);

        let ty = value.guess_type(id.location());

        if ty.is_cf_type_ptr() || ty.is_object_like_ptr() {
            // cf_string! and ns_string! are not supported (since they cannot
            // yet be used in `const`).
            return None;
        }

        Some(Self::ConstDecl {
            id,
            // macro definitions cannot have availability.
            availability: Availability::default(),
            ty,
            value,
            is_last: false,
            documentation: Documentation::from_entity(entity),
        })
    }

    pub fn get_ident_mapping(&self) -> HashMap<String, Expr> {
        let mut mapping = HashMap::new();

        match self {
            Stmt::EnumDecl {
                id,
                ty,
                kind,
                variants,
                ..
            } => {
                let mut relevant_enum_cases = variants
                    .iter()
                    .filter(|(_, _, availability, _)| availability.is_available_non_deprecated())
                    .map(|(name, _, _, _)| &**name)
                    .peekable();
                let prefix = if relevant_enum_cases.peek().is_some() {
                    enum_prefix(&id.name, relevant_enum_cases)
                } else {
                    enum_prefix(&id.name, variants.iter().map(|(name, _, _, _)| &**name))
                };

                for (name, ..) in variants {
                    mapping.insert(
                        name.clone(),
                        Expr::Enum {
                            id: id.clone(),
                            variant: name.strip_prefix(prefix).unwrap_or(name).to_string(),
                            ty: ty.clone(),
                            attrs: kind.iter().cloned().collect(),
                        },
                    );
                }
            }
            Stmt::ConstDecl { id, ty, .. } => {
                mapping.insert(
                    id.name.clone(),
                    Expr::Const {
                        id: id.clone(),
                        ty: ty.clone(),
                    },
                );
            }
            Stmt::VarDecl { id, ty, .. } => {
                mapping.insert(
                    id.name.clone(),
                    Expr::Var {
                        id: id.clone(),
                        ty: ty.clone(),
                    },
                );
            }
            _ => {}
        }

        mapping
    }

    pub(crate) fn provided_item(&self) -> Option<ItemIdentifier> {
        match self {
            Self::ClassDecl { id, skipped, .. } => {
                if *skipped {
                    None
                } else {
                    Some(id.clone())
                }
            }
            Self::ExternMethods { .. } => None,
            Self::ExternCategory { id, .. } => Some(id.clone()),
            Self::ProtocolDecl { id, .. } => Some(id.clone()),
            Self::ProtocolImpl { .. } => None,
            Self::RecordDecl { id, .. } => Some(id.clone()),
            Self::EnumDecl { id, .. } => Some(id.clone()),
            Self::ConstDecl { id, .. } => Some(id.clone()),
            Self::VarDecl { id, .. } => Some(id.clone()),
            Self::FnDecl { id, body: None, .. } => Some(id.clone()),
            // TODO
            Self::FnDecl { body: Some(_), .. } => None,
            Self::FnGetTypeId { .. } => None, // Emits a trait impl
            Self::AliasDecl { id, .. } => Some(id.clone()),
            Self::OpaqueDecl { id, .. } => Some(id.clone()),
        }
    }

    pub(crate) fn location(&self) -> &Location {
        match self {
            Self::ClassDecl { id, .. } => id.location(),
            Self::ExternMethods { location, .. } => location,
            Self::ExternCategory { id, .. } => id.location(),
            Self::ProtocolDecl { id, .. } => id.location(),
            Self::ProtocolImpl { location, .. } => location,
            Self::RecordDecl { id, .. } => id.location(),
            Self::EnumDecl { id, .. } => id.location(),
            Self::ConstDecl { id, .. } => id.location(),
            Self::VarDecl { id, .. } => id.location(),
            Self::FnDecl { id, .. } => id.location(),
            Self::FnGetTypeId { id, .. } => id.location(),
            Self::AliasDecl { id, .. } => id.location(),
            Self::OpaqueDecl { id, .. } => id.location(),
        }
    }

    /// Items required by the statement at the top-level.
    pub(crate) fn required_items(&self) -> impl Iterator<Item = ItemTree> {
        let items: Vec<ItemTree> = match self {
            Self::ClassDecl { superclasses, .. } => iter::once(ItemTree::objc("__macros__"))
                .chain(superclasses_required_items(
                    superclasses.iter().map(|(s, _)| s.clone()),
                ))
                .collect(),
            Self::ExternMethods {
                cls,
                cls_superclasses,
                ..
            } => vec![
                ItemTree::objc("__macros__"),
                ItemTree::new(
                    cls.clone(),
                    superclasses_required_items(cls_superclasses.iter().cloned()),
                ),
            ],
            // Intentionally doesn't require anything, the impl itself is
            // cfg-gated
            Self::ExternCategory { .. } => {
                vec![ItemTree::objc("__macros__")]
            }
            Self::ProtocolDecl {
                super_protocols, ..
            } => iter::once(ItemTree::objc("__macros__"))
                .chain(super_protocols.iter().flat_map(|p| p.required_items()))
                .collect(),
            Self::ProtocolImpl {
                cls,
                cls_superclasses,
                protocol,
                protocol_super_protocols,
                ..
            } => vec![
                ItemTree::new(
                    cls.clone(),
                    superclasses_required_items(cls_superclasses.iter().cloned()),
                ),
                ItemTree::new(
                    protocol.clone(),
                    protocol_super_protocols
                        .iter()
                        .flat_map(|p| p.required_items()),
                ),
            ],
            Self::RecordDecl { fields, .. } => fields
                .iter()
                .flat_map(|(_, _, field_ty)| field_ty.required_items())
                .collect(),
            // Variants manage required items themselves
            Self::EnumDecl { ty, .. } => ty.required_items().collect(),
            Self::ConstDecl { ty, value, .. } => {
                ty.required_items().chain(value.required_items()).collect()
            }
            Self::VarDecl { ty, value, .. } => ty
                .required_items()
                .chain(value.iter().flat_map(|value| value.required_items()))
                .collect(),
            Self::FnDecl {
                arguments,
                result_type,
                body: None,
                ..
            } => {
                let mut items = Vec::new();
                for (_, arg_ty) in arguments {
                    items.extend(arg_ty.required_items());
                }
                items.extend(result_type.fn_return_required_items());
                items
            }
            // TODO
            Self::FnDecl { body: Some(_), .. } => Vec::new(),
            Self::FnGetTypeId {
                cf_id, result_type, ..
            } => {
                let mut items = vec![
                    ItemTree::from_id(cf_id.clone()),
                    ItemTree::cf("ConcreteType"),
                ];
                items.extend(result_type.fn_return_required_items());
                items
            }
            Self::AliasDecl { ty, .. } => ty.required_items().collect(),
            Self::OpaqueDecl {
                generics,
                superclass,
                ..
            } => {
                let mut items = vec![ItemTree::unsafecell(), ItemTree::phantoms()];
                if let Some(superclass) = superclass {
                    items.push(ItemTree::new(superclass.clone(), items.clone()));
                }
                if !generics.is_empty() {
                    items.push(ItemTree::core_ffi("c_void"));
                }
                items
            }
        };

        items.into_iter()
    }

    /// Items required for any part of the statement.
    pub(crate) fn required_items_inner(&self) -> impl Iterator<Item = ItemTree> {
        let required_by_inner: Vec<ItemTree> = match self {
            Self::ExternCategory {
                cls,
                cls_superclasses,
                methods,
                ..
            } => iter::once(ItemTree::new(
                cls.clone(),
                superclasses_required_items(cls_superclasses.iter().cloned()),
            ))
            .chain(methods.iter().flat_map(|method| method.required_items()))
            .collect(),
            Self::ExternMethods { methods, .. } | Self::ProtocolDecl { methods, .. } => methods
                .iter()
                .flat_map(|method| method.required_items())
                .collect(),
            Self::RecordDecl { .. } => vec![],
            Self::EnumDecl { kind, variants, .. } => {
                let mut items: Vec<_> = variants
                    .iter()
                    .flat_map(|(_, _, _, expr)| expr.required_items())
                    .collect();
                if let Some(UnexposedAttr::Options) = kind {
                    items.push(ItemTree::bitflags());
                }
                // items.push(ItemTree::objc("Encoding"));
                items
            }
            Self::OpaqueDecl { is_cf, .. } => {
                if *is_cf {
                    vec![ItemTree::cf("cf_type"), ItemTree::objc("cf_objc2_type")]
                } else {
                    vec![]
                }
            }
            _ => vec![],
        };
        self.required_items().chain(required_by_inner)
    }

    fn cfg_gate_ln<'a>(&'a self, config: &'a Config) -> impl fmt::Display + 'a {
        self.cfg_gate_ln_for(self.required_items(), config)
    }

    fn cfg_gate_ln_for<'a>(
        &'a self,
        required_items: impl IntoIterator<Item = ItemTree> + 'a,
        config: &'a Config,
    ) -> impl fmt::Display + 'a {
        cfg_gate_ln(required_items, [] as [ItemTree; 0], config, self.location())
    }

    fn cfg_gate_ln_inner<'a>(
        &'a self,
        required_items: impl IntoIterator<Item = ItemTree> + 'a,
        config: &'a Config,
    ) -> impl fmt::Display + 'a {
        cfg_gate_ln(
            required_items,
            self.required_items(),
            config,
            self.location(),
        )
    }

    pub fn fmt<'a>(&'a self, config: &'a Config) -> impl fmt::Display + 'a {
        FormatterFn(move |f| {
            let _span = debug_span!("stmt", provided_item = ?self.provided_item()).entered();

            struct GenericTyHelper<'a>(&'a [String]);

            impl fmt::Display for GenericTyHelper<'_> {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    let mut iter = self.0.iter();
                    if let Some(first) = iter.next() {
                        write!(f, "<{first}")?;
                        for generic in iter {
                            write!(f, ", {generic}")?;
                        }
                        write!(f, ">")?;
                    }
                    Ok(())
                }
            }

            struct GenericParamsHelper<'a>(&'a [String], &'a str);

            impl fmt::Display for GenericParamsHelper<'_> {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    let mut iter = self.0.iter();
                    if let Some(first) = iter.next() {
                        write!(f, "<{first}: {}", self.1)?;
                        for generic in iter {
                            write!(f, ", {generic}: {}", self.1)?;
                        }
                        write!(f, ">")?;
                    }
                    Ok(())
                }
            }

            struct WhereBoundHelper<'a>(&'a [String], Option<&'a str>);

            impl fmt::Display for WhereBoundHelper<'_> {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    if let Some(bound) = self.1 {
                        if !self.0.is_empty() {
                            writeln!(f, "where")?;
                            for generic in self.0 {
                                writeln!(f, "{generic}{bound},")?;
                            }
                        }
                    }
                    Ok(())
                }
            }

            // TODO: Derive this after https://github.com/madsmtm/objc2/issues/55
            fn unsafe_impl_encode<'a>(
                ident: impl fmt::Display + 'a,
                encoding: impl fmt::Display + 'a,
            ) -> impl fmt::Display + 'a {
                FormatterFn(move |f| {
                    writeln!(f, "unsafe impl Encode for {ident} {{")?;
                    writeln!(f, "    const ENCODING: Encoding = {encoding};")?;
                    writeln!(f, "}}")?;
                    Ok(())
                })
            }

            // TODO: Derive this after https://github.com/madsmtm/objc2/issues/55
            fn unsafe_impl_refencode<'a>(ident: impl fmt::Display + 'a) -> impl fmt::Display + 'a {
                FormatterFn(move |f| {
                    writeln!(f, "unsafe impl RefEncode for {ident} {{")?;
                    writeln!(
                        f,
                        "    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);"
                    )?;
                    writeln!(f, "}}")?;
                    Ok(())
                })
            }

            match self {
                Self::ClassDecl {
                    id,
                    generics,
                    availability,
                    superclasses,
                    designated_initializers: _,
                    derives,
                    main_thread_only,
                    skipped,
                    sendable,
                    documentation,
                } => {
                    if *skipped {
                        return Ok(());
                    }

                    let cfg = self.cfg_gate_ln_for([ItemTree::objc("extern_class")], config);
                    write!(f, "{cfg}")?;
                    writeln!(f, "extern_class!(")?;
                    write!(f, "{}", documentation.fmt(Some(id)))?;
                    write!(f, "    #[unsafe(super(")?;
                    for (i, (superclass, generics)) in superclasses.iter().enumerate() {
                        if 0 < i {
                            write!(f, ", ")?;
                        }
                        write!(
                            f,
                            "{}{}",
                            superclass.path_in_relation_to(id.location()),
                            GenericTyHelper(generics)
                        )?;
                    }
                    writeln!(f, "))]")?;
                    if *main_thread_only {
                        writeln!(f, "    #[thread_kind = MainThreadOnly]")?;
                    }
                    writeln!(f, "    {derives}")?;
                    write!(f, "    {}", self.cfg_gate_ln(config))?;
                    write!(f, "    {availability}")?;
                    write!(f, "    pub struct {}", id.name)?;
                    if !generics.is_empty() {
                        write!(f, "<")?;
                        for generic in generics {
                            write!(f, "{generic}: ?Sized = AnyObject, ")?;
                        }
                        write!(f, ">")?;
                    };
                    writeln!(f, ";")?;
                    writeln!(f, ");")?;

                    if *sendable && generics.is_empty() {
                        writeln!(f)?;
                        write!(f, "{}", self.cfg_gate_ln(config))?;
                        writeln!(f, "unsafe impl Send for {} {{}}", id.name)?;

                        writeln!(f)?;
                        write!(f, "{}", self.cfg_gate_ln(config))?;
                        writeln!(f, "unsafe impl Sync for {} {{}}", id.name)?;
                    }
                }
                Self::ExternMethods {
                    location: _,
                    availability: _,
                    cls,
                    cls_superclasses: _,
                    source_superclass,
                    cls_generics,
                    category_name,
                    methods,
                    documentation,
                } => {
                    if let Some(source_superclass) = source_superclass {
                        writeln!(
                            f,
                            "/// Methods declared on superclass `{}`.",
                            source_superclass.name
                        )?;
                        if let Some(category_name) = category_name {
                            writeln!(f, "///")?;
                            writeln!(f, "/// {category_name}.")?;
                        }
                    } else if let Some(category_name) = category_name {
                        writeln!(f, "/// {category_name}.")?;
                    }
                    // FIXME: Merge with `source_superclass`/`category_name`
                    if let Some(documentation) = documentation {
                        write!(f, "{}", documentation.fmt(None))?;
                    }
                    write!(f, "{}", self.cfg_gate_ln(config))?;
                    // TODO: Add ?Sized here once `extern_methods!` supports it.
                    writeln!(
                        f,
                        "impl{} {}{} {{",
                        GenericParamsHelper(cls_generics, "Message"),
                        cls.path(),
                        GenericTyHelper(cls_generics),
                    )?;
                    writeln!(f, "    extern_methods!(")?;
                    for method in methods {
                        write!(
                            f,
                            "{}",
                            self.cfg_gate_ln_inner(method.required_items(), config)
                        )?;
                        writeln!(f, "{method}")?;
                    }
                    writeln!(f, "    );")?;
                    writeln!(f, "}}")?;

                    if let Some(method) = methods
                        .iter()
                        .find(|method| method.usable_in_default_retained())
                    {
                        writeln!(f)?;
                        // Assume `new` methods require no extra features
                        write!(f, "{}", self.cfg_gate_ln(config))?;
                        writeln!(
                            f,
                            "impl{} DefaultRetained for {}{} {{",
                            GenericParamsHelper(cls_generics, "Message"),
                            cls.path(),
                            GenericTyHelper(cls_generics),
                        )?;
                        writeln!(f, "    #[inline]")?;
                        writeln!(f, "    fn default_retained() -> Retained<Self> {{")?;
                        writeln!(f, "        Self::{}()", method.fn_name)?;
                        writeln!(f, "    }}")?;
                        writeln!(f, "}}")?;
                    }
                }
                Self::ExternCategory {
                    id,
                    actual_name,
                    availability,
                    cls,
                    cls_superclasses,
                    cls_generics,
                    methods,
                    documentation,
                } => {
                    // Helper module to seal the trait.
                    writeln!(f, "mod private_{} {{", id.name)?;
                    writeln!(f, "    pub trait Sealed {{}}")?;
                    writeln!(f, "}}")?;

                    writeln!(f)?;

                    if let Some(actual_name) = actual_name {
                        if *actual_name != id.name {
                            writeln!(f, "/// Category \"{actual_name}\" on [`{}`].", cls.name)?;
                            writeln!(f, "#[doc(alias = \"{actual_name}\")]")?;
                        } else {
                            writeln!(f, "/// Category on [`{}`].", cls.name)?;
                        }
                    } else {
                        writeln!(f, "/// Category on [`{}`].", cls.name)?;
                    }
                    write!(f, "{}", documentation.fmt(None))?;

                    write!(f, "{}", self.cfg_gate_ln(config))?;
                    write!(f, "{availability}")?;
                    writeln!(
                        f,
                        "pub unsafe trait {}{}: ClassType + Sized + private_{}::Sealed {{",
                        id.name,
                        GenericParamsHelper(cls_generics, "Message"),
                        id.name,
                    )?;
                    writeln!(f, "    extern_methods!(")?;
                    for method in methods {
                        write!(
                            f,
                            "{}",
                            self.cfg_gate_ln_inner(method.required_items(), config)
                        )?;
                        writeln!(f, "{method}")?;
                    }
                    writeln!(f, "    );")?;
                    writeln!(f, "}}")?;

                    writeln!(f)?;

                    let impl_cfg = self.cfg_gate_ln_for(
                        [ItemTree::new(
                            cls.clone(),
                            superclasses_required_items(cls_superclasses.iter().cloned()),
                        )],
                        config,
                    );

                    write!(f, "{impl_cfg}")?;
                    writeln!(
                        f,
                        "impl{} private_{}::Sealed for {}{} {{}}",
                        GenericParamsHelper(cls_generics, "Message"),
                        id.name,
                        cls.path_in_relation_to(id.location()),
                        GenericTyHelper(cls_generics),
                    )?;

                    write!(f, "{impl_cfg}")?;
                    writeln!(
                        f,
                        "unsafe impl{} {}{} for {}{} {{}}",
                        GenericParamsHelper(cls_generics, "Message"),
                        id.name,
                        GenericTyHelper(cls_generics),
                        cls.path_in_relation_to(id.location()),
                        GenericTyHelper(cls_generics),
                    )?;
                }
                Self::ProtocolImpl {
                    location: id,
                    cls,
                    cls_superclasses: _,
                    cls_counterpart,
                    generics,
                    protocol,
                    protocol_super_protocols: _,
                    availability: _,
                } => {
                    let (generic_bound, where_bound) = if !generics.is_empty() {
                        match (protocol.library_name(), &*protocol.name) {
                            // The object inherits from `NSObject` or `NSProxy` no
                            // matter what the generic type is, so this must be
                            // safe.
                            ("ObjectiveC", "NSObjectProtocol") => ("?Sized", None),
                            // Encoding and decoding requires that the inner types
                            // are codable as well.
                            ("Foundation", "NSCoding") => ("?Sized + NSCoding", None),
                            ("Foundation", "NSSecureCoding") => ("?Sized + NSSecureCoding", None),
                            // Copying collections is done as a shallow copy:
                            // <https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html>
                            //
                            // E.g. it does a retain count bump on the items, and
                            // hence does not require the inner type to implement
                            // `NSCopying`.
                            ("Foundation", "NSCopying") => ("?Sized", None),
                            ("Foundation", "NSMutableCopying") => ("?Sized", None),
                            // TODO: Do we need further tweaks to this?
                            ("Foundation", "NSFastEnumeration") => ("?Sized", None),
                            // AppKit/UIKit fixes. TODO: Should we add more bounds here?
                            ("AppKit", "NSCollectionViewDataSource") => ("?Sized", None),
                            ("UIKit", "UICollectionViewDataSource") => ("?Sized + Message", None),
                            ("AppKit", "NSTableViewDataSource") => ("?Sized", None),
                            ("UIKit", "UITableViewDataSource") => ("?Sized + Message", None),
                            _ => {
                                error!(
                                    ?protocol,
                                    ?cls,
                                    "unknown where bound for generic protocol impl"
                                );
                                ("?Sized", None)
                            }
                        }
                    } else {
                        ("InvalidGenericBound", None)
                    };

                    write!(f, "{}", self.cfg_gate_ln(config))?;
                    writeln!(
                        f,
                        "unsafe impl{} {} for {}{} {}{{}}",
                        GenericParamsHelper(generics, generic_bound),
                        protocol.path_in_relation_to(id),
                        cls.path_in_relation_to(id),
                        GenericTyHelper(generics),
                        WhereBoundHelper(generics, where_bound)
                    )?;

                    // To make `NSCopying` and `NSMutableCopying` work, we
                    // need to emit `CopyingHelper` impls to tell Rust which
                    // return types they have.
                    if matches!(&*protocol.name, "NSCopying" | "NSMutableCopying") {
                        let copy_helper = ItemIdentifier::copyhelper(protocol.name != "NSCopying");

                        let mut required_items: Vec<_> = self.required_items().collect();

                        // Assume counterparts have the same generics.
                        let ty = match (cls_counterpart, &*protocol.name) {
                            (Counterpart::ImmutableSuperclass(superclass), "NSCopying") => {
                                // REMARK: Already part of required items.
                                format!(
                                    "{}{}",
                                    superclass.path_in_relation_to(id),
                                    GenericTyHelper(generics)
                                )
                            }
                            (Counterpart::MutableSubclass(subclass), "NSMutableCopying") => {
                                required_items.push(ItemTree::from_id(subclass.clone()));
                                format!(
                                    "{}{}",
                                    subclass.path_in_relation_to(id),
                                    GenericTyHelper(generics)
                                )
                            }
                            _ => "Self".into(),
                        };

                        writeln!(f)?;
                        write!(f, "{}", self.cfg_gate_ln_for(required_items, config))?;
                        writeln!(
                            f,
                            "unsafe impl{} {} for {}{} {{",
                            GenericParamsHelper(generics, "?Sized + Message"),
                            copy_helper.path_in_relation_to(id),
                            cls.path_in_relation_to(id),
                            GenericTyHelper(generics),
                        )?;

                        writeln!(f, "    type Result = {ty};")?;

                        writeln!(f, "}}")?;
                    }

                    if protocol.name == "NSMutableCopying"
                        && *cls_counterpart == Counterpart::NoCounterpart
                    {
                        error!(
                            ?cls,
                            "Class implements NSMutableCopying, \
                                but does not have a counterpart. You should \
                                define the counterpart for this class, or \
                                ignore the NSMutableCopying implementation"
                        );
                    }
                }
                Self::ProtocolDecl {
                    id,
                    actual_name,
                    availability,
                    super_protocols,
                    methods,
                    required_sendable: _,
                    required_mainthreadonly,
                    documentation,
                } => {
                    let cfg = self.cfg_gate_ln_for([ItemTree::objc("extern_protocol")], config);
                    write!(f, "{cfg}")?;
                    writeln!(f, "extern_protocol!(")?;

                    write!(f, "{}", documentation.fmt(Some(id)))?;
                    write!(f, "    {}", self.cfg_gate_ln(config))?;
                    write!(f, "    {availability}")?;
                    if let Some(actual_name) = actual_name {
                        writeln!(f, "    #[name = {actual_name:?}]")?;
                    }
                    write!(f, "    pub unsafe trait {}", id.name)?;
                    if !super_protocols.is_empty() {
                        for (i, protocol) in super_protocols.iter().enumerate() {
                            if i == 0 {
                                write!(f, ": ")?;
                            } else {
                                write!(f, "+ ")?;
                            }
                            write!(f, "{}", protocol.id.path())?;
                        }
                    }
                    // TODO
                    // if *required_sendable {
                    //     if protocols.is_empty() {
                    //         write!(f, ": ")?;
                    //     } else {
                    //         write!(f, "+ ")?;
                    //     }
                    //     write!(f, "Send + Sync")?;
                    // }
                    if *required_mainthreadonly {
                        if super_protocols.is_empty() {
                            write!(f, ": ")?;
                        } else {
                            write!(f, "+ ")?;
                        }
                        write!(f, "MainThreadOnly")?;
                    }
                    writeln!(f, " {{")?;

                    for method in methods {
                        write!(
                            f,
                            "{}",
                            self.cfg_gate_ln_inner(method.required_items(), config)
                        )?;
                        writeln!(f, "{method}")?;
                    }
                    writeln!(f, "    }}")?;
                    writeln!(f)?;
                    writeln!(f, ");")?;
                }
                Self::RecordDecl {
                    id,
                    encoding_name,
                    availability,
                    boxable: _,
                    fields,
                    sendable,
                    packed,
                    documentation,
                    is_union,
                } => {
                    write!(f, "{}", documentation.fmt(Some(id)))?;
                    write!(f, "{}", self.cfg_gate_ln(config))?;
                    write!(f, "{availability}")?;
                    if *packed {
                        writeln!(f, "#[repr(C, packed)]")?;
                    } else {
                        writeln!(f, "#[repr(C)]")?;
                    }
                    if *is_union || fields.iter().any(|(_, _, field)| field.contains_union()) {
                        writeln!(f, "#[derive(Clone, Copy)]")?;
                    } else {
                        writeln!(f, "#[derive(Clone, Copy, Debug, PartialEq)]")?;
                    }
                    if *is_union {
                        writeln!(f, "pub union {} {{", id.name)?;
                    } else {
                        writeln!(f, "pub struct {} {{", id.name)?;
                    }
                    for (name, documentation, ty) in fields {
                        write!(f, "{}", documentation.fmt(None))?;
                        write!(f, "    ")?;
                        if name.starts_with('_') {
                            write!(f, "pub(crate) ")?;
                        } else {
                            write!(f, "pub ")?;
                        }
                        let name = handle_reserved(name);
                        writeln!(f, "{name}: {},", ty.record())?;
                    }
                    writeln!(f, "}}")?;
                    writeln!(f)?;

                    let required_items = self
                        .required_items()
                        .chain(iter::once(ItemTree::objc("Encoding")));
                    let cfg_encoding = self.cfg_gate_ln_for(required_items, config);

                    let encoding = FormatterFn(|f| {
                        if *is_union {
                            write!(f, "Encoding::Union")?;
                        } else {
                            write!(f, "Encoding::Struct")?;
                        }
                        writeln!(f, "({:?}, &[", encoding_name.as_deref().unwrap_or(&id.name),)?;
                        for (_, _, ty) in fields {
                            writeln!(f, "        {},", ty.record_encoding())?;
                        }
                        write!(f, "    ])")?;
                        Ok(())
                    });

                    // SAFETY: The struct/union is marked `#[repr(C)]`.
                    // write!(f, "{cfg_encoding}")?;
                    // writeln!(f, "{}", unsafe_impl_encode(&id.name, encoding))?;
                    // write!(f, "{cfg_encoding}")?;
                    // writeln!(f, "{}", unsafe_impl_refencode(&id.name))?;

                    if let Some(true) = sendable {
                        writeln!(f)?;
                        write!(f, "{}", self.cfg_gate_ln(config))?;
                        writeln!(f, "unsafe impl Send for {} {{}}", id.name)?;

                        writeln!(f)?;
                        write!(f, "{}", self.cfg_gate_ln(config))?;
                        writeln!(f, "unsafe impl Sync for {} {{}}", id.name)?;
                    }
                }
                Self::EnumDecl {
                    id,
                    availability,
                    ty,
                    kind,
                    variants,
                    sendable,
                    documentation,
                } => {
                    write!(f, "{}", documentation.fmt(Some(id)))?;

                    let mut relevant_enum_cases = variants
                        .iter()
                        .filter(|(_, _, availability, _)| {
                            availability.is_available_non_deprecated()
                        })
                        .map(|(name, _, _, _)| &**name)
                        .peekable();
                    let prefix = if relevant_enum_cases.peek().is_some() {
                        enum_prefix(&id.name, relevant_enum_cases)
                    } else {
                        enum_prefix(&id.name, variants.iter().map(|(name, _, _, _)| &**name))
                    };

                    match kind {
                    // TODO: Once Rust gains support for more precisely
                    // specifying niches, use that to convert this into a
                    // native enum with a hidden variant that contains the
                    // remaining cases.
                    None
                    // Swift emits these slightly differently, with
                    // only `NS_ENUM` being a "native" enum with
                    // exhaustiveness-checking and all.
                    //
                    // <https://developer.apple.com/documentation/swift/grouping-related-objective-c-constants#Declare-Simple-Enumerations>
                    | Some(UnexposedAttr::Enum)
                    // TODO: Handle this differently.
                    | Some(UnexposedAttr::ErrorEnum) => {
                        match kind {
                            None => {}
                            Some(UnexposedAttr::Enum) => writeln!(f, "// NS_ENUM")?,
                            Some(UnexposedAttr::ErrorEnum) => writeln!(f, "// NS_ERROR_ENUM")?,
                            _ => unreachable!(),
                        }

                        write!(f, "{}", self.cfg_gate_ln(config))?;
                        write!(f, "{availability}")?;
                        writeln!(f, "#[repr(transparent)]")?;
                        // TODO: Implement `Debug` manually
                        writeln!(
                            f,
                            "#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]"
                        )?;
                        // External enums can be safely constructed from the
                        // raw value, and as such it is safe to expose it
                        // directly without causing unsoundess in external
                        // libraries (but it will likely lead to an exception
                        // or a crash, if the invalid value is used).
                        //
                        // Note: This cannot be a Rust `enum`, since that
                        // assumes that the enum is exhaustive ABI-wise, even
                        // with `#[non_exhaustive]`, see:
                        // <https://play.rust-lang.org/?version=stable&mode=release&edition=2021&gist=3a19fcb4267d6fdb0d26b0c9defd946a>
                        //
                        // What we really need here is some way to specify
                        // niches of integers, then a hacky solution to this
                        // would be doable.
                        writeln!(f, "pub struct {}(pub {});", id.name, ty.enum_())?;

                        write!(f, "{}", self.cfg_gate_ln(config))?;
                        writeln!(f, "impl {} {{", id.name)?;

                        for (name, documentation, availability, expr) in variants {
                            write!(f, "{}", documentation.fmt(None))?;
                            write!(f, "    {}", self.cfg_gate_ln_inner(expr.required_items(), config))?;
                            write!(f, "    {availability}")?;
                            let pretty_name = name.strip_prefix(prefix).unwrap_or(name);
                            if pretty_name != name {
                                writeln!(f, "    #[doc(alias = \"{name}\")]")?;
                            }
                            writeln!(f, "    pub const {pretty_name}: Self = Self({expr});")?;
                        }
                        writeln!(f, "}}")?;
                        writeln!(f)?;
                    }
                    Some(UnexposedAttr::Options) => {
                        writeln!(f, "// NS_OPTIONS")?;

                        write!(f, "{}", self.cfg_gate_ln(config))?;
                        write!(f, "{availability}")?;
                        writeln!(f, "#[repr(transparent)]")?;
                        writeln!(
                            f,
                            "#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]"
                        )?;
                        // TODO(breaking): Make the inner field private
                        writeln!(f, "pub struct {}(pub {});", id.name, ty.enum_())?;

                        write!(f, "{}", self.cfg_gate_ln(config))?;
                        writeln!(f, "bitflags::bitflags! {{")?;

                        writeln!(f, "    impl {}: {} {{", id.name, ty.enum_())?;

                        for (name, documentation, availability, expr) in variants {
                            write!(f, "{}", documentation.fmt(None))?;
                            write!(f, "{}", self.cfg_gate_ln_inner(expr.required_items(), config))?;
                            write!(f, "{availability}")?;
                            let pretty_name = name.strip_prefix(prefix).unwrap_or(name);
                            if pretty_name != name {
                                writeln!(f, "        #[doc(alias = \"{name}\")]")?;
                            }
                            writeln!(f, "        const {pretty_name} = {expr};")?;
                        }
                        writeln!(f, "    }}")?;
                        writeln!(f, "}}")?;
                        writeln!(f)?;
                    }
                    Some(UnexposedAttr::ClosedEnum) => {
                        // SAFETY: `NS_CLOSED_ENUM` is guaranteed to never
                        // gain additional cases, so we are allowed to use a
                        // Rust enum (which in turn will assume that the
                        // unused patterns are valid to use as a niche).
                        writeln!(f, "// NS_CLOSED_ENUM")?;
                        write!(f, "{}", self.cfg_gate_ln(config))?;
                        write!(f, "{availability}")?;
                        writeln!(f, "{}", ty.closed_enum_repr())?;
                        writeln!(
                            f,
                            "#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]"
                        )?;
                        writeln!(f, "pub enum {} {{", id.name)?;

                        for (name, documentation, availability, expr) in variants {
                            write!(f, "{}", documentation.fmt(None))?;
                            write!(f, "    {}", self.cfg_gate_ln_inner(expr.required_items(), config))?;
                            write!(f, "    {availability}")?;
                            let pretty_name = name.strip_prefix(prefix).unwrap_or(name);
                            if pretty_name != name {
                                writeln!(f, "    #[doc(alias = \"{name}\")]")?;
                            }
                            writeln!(f, "    {pretty_name} = {expr},")?;
                        }
                        writeln!(f, "}}")?;
                        writeln!(f)?;
                    }
                    _ => panic!("invalid enum kind"),
                }

                    let required_items = self
                        .required_items()
                        .chain(iter::once(ItemTree::objc("Encoding")));
                    let cfg_encoding = self.cfg_gate_ln_for(required_items, config);

                    // SAFETY: The enum is either a `#[repr(transparent)]` newtype
                    // over the type, or a `#[repr(REPR)]`, where REPR is a valid
                    // repr with the same size and alignment as the type.
                    // write!(f, "{cfg_encoding}")?;
                    // writeln!(f, "{}", unsafe_impl_encode(&id.name, ty.enum_encoding()))?;
                    // write!(f, "{cfg_encoding}")?;
                    // writeln!(f, "{}", unsafe_impl_refencode(&id.name))?;

                    if let Some(true) = sendable {
                        writeln!(f)?;
                        write!(f, "{}", self.cfg_gate_ln(config))?;
                        writeln!(f, "unsafe impl Send for {} {{}}", id.name)?;

                        writeln!(f)?;
                        write!(f, "{}", self.cfg_gate_ln(config))?;
                        writeln!(f, "unsafe impl Sync for {} {{}}", id.name)?;
                    }
                }
                Self::ConstDecl {
                    id,
                    availability,
                    ty,
                    value,
                    is_last,
                    documentation,
                } => {
                    write!(f, "{}", documentation.fmt(Some(id)))?;
                    write!(f, "{}", self.cfg_gate_ln(config))?;
                    write!(f, "{availability}")?;
                    write!(f, "pub const {}: {} = {value};", id.name, ty.const_())?;
                    if *is_last {
                        writeln!(f)?;
                    }
                }
                Self::VarDecl {
                    id,
                    availability: _,
                    ty,
                    value: None,
                    documentation,
                } => {
                    writeln!(f, "extern \"C\" {{")?;
                    write!(f, "{}", documentation.fmt(Some(id)))?;
                    write!(f, "{}", self.cfg_gate_ln(config))?;
                    writeln!(f, "    pub static {}: {};", id.name, ty.var())?;
                    writeln!(f, "}}")?;
                }
                Self::VarDecl {
                    id,
                    availability: _,
                    ty,
                    value: Some(expr),
                    documentation,
                } => {
                    write!(f, "{}", documentation.fmt(Some(id)))?;
                    write!(f, "{}", self.cfg_gate_ln(config))?;
                    write!(f, "pub static {}: {} = ", id.name, ty.var())?;

                    if ty.is_floating_through_typedef() {
                        write!(f, "{expr} as _")?;
                    } else if ty.is_enum_through_typedef() {
                        write!(f, "{}({expr})", ty.var())?;
                    } else {
                        write!(f, "{expr}")?;
                    }
                    writeln!(f, ";")?;
                }
                Self::FnDecl {
                    id,
                    arguments,
                    result_type,
                    body: Some(_),
                    returns_retained,
                    ..
                } => {
                    write!(f, "// TODO: ")?;
                    write!(f, "pub fn {}(", id.name)?;
                    for (param, arg_ty) in arguments {
                        let param = handle_reserved(&crate::to_snake_case(param));
                        write!(f, "{param}: {},", arg_ty.fn_argument())?;
                    }
                    let (ret, _) = result_type.fn_return(*returns_retained);
                    writeln!(f, "){ret};")?;
                }
                Self::FnDecl {
                    id,
                    availability,
                    arguments,
                    result_type,
                    body: None,
                    safe,
                    must_use,
                    can_unwind,
                    link_name,
                    returns_retained,
                    documentation,
                } => {
                    let abi = if *can_unwind { "C-unwind" } else { "C" };

                    let (ret, return_converter) = result_type.fn_return(*returns_retained);

                    let needs_wrapper = *safe
                        || return_converter.is_some()
                        || arguments
                            .iter()
                            .any(|(_, arg)| arg.fn_argument_converter().is_some());

                    let raw_fn_decl = |f: &mut fmt::Formatter<'_>, vis| {
                        if let Some(link_name) = link_name {
                            // NOTE: Currently only used on Apple targets.
                            writeln!(
                                f,
                                "#[cfg_attr(target_vendor = \"apple\", link_name = {link_name:?})]"
                            )?;
                        }
                        write!(f, "{vis}fn {}(", id.name)?;
                        for (param, arg_ty) in arguments {
                            let param = handle_reserved(&crate::to_snake_case(param));
                            write!(f, "{param}: {},", arg_ty.fn_argument())?;
                        }
                        writeln!(f, "){ret};")?;

                        Ok(())
                    };

                    if needs_wrapper {
                        write!(f, "{}", documentation.fmt(None))?;
                        write!(f, "{}", self.cfg_gate_ln(config))?;
                        write!(f, "{availability}")?;
                        if *must_use {
                            writeln!(f, "#[must_use]")?;
                        }
                        writeln!(f, "#[inline]")?;
                        let unsafe_ = if *safe { "" } else { "unsafe " };
                        write!(f, "pub {unsafe_}extern {abi:?} fn {}(", id.name)?;
                        for (param, arg_ty) in arguments {
                            let param = handle_reserved(&crate::to_snake_case(param));
                            write!(f, "{param}: ")?;
                            if let Some((converted_ty, _, _)) = arg_ty.fn_argument_converter() {
                                write!(f, "{converted_ty}")?;
                            } else {
                                write!(f, "{}", arg_ty.fn_argument())?;
                            }
                            write!(f, ",")?;
                        }
                        write!(f, ")")?;
                        if let Some((ty, _, _)) = &return_converter {
                            write!(f, "{ty}")?;
                        } else {
                            write!(f, "{ret}")?;
                        }
                        writeln!(f, " {{")?;

                        // Emit raw
                        writeln!(f, "    extern {abi:?} {{")?;
                        raw_fn_decl(f, "")?;
                        writeln!(f, "    }}")?;

                        // Call raw
                        write!(f, "    ")?;
                        if let Some((_, converter_start, _)) = &return_converter {
                            write!(f, "{converter_start}")?;
                        }
                        write!(f, "unsafe {{ {}(", id.name)?;
                        for (param, ty) in arguments {
                            let param = handle_reserved(&crate::to_snake_case(param));
                            if let Some((_, converter_start, converter_end)) =
                                ty.fn_argument_converter()
                            {
                                write!(f, "{converter_start}{param}{converter_end}")?;
                            } else {
                                write!(f, "{param}")?;
                            }
                            write!(f, ",")?;
                        }
                        write!(f, ") }}")?;
                        if let Some((_, _, converter_end)) = &return_converter {
                            write!(f, "{converter_end}")?;
                        }
                        writeln!(f)?;

                        writeln!(f, "}}")?;
                    } else {
                        writeln!(f, "extern {abi:?} {{")?;

                        write!(f, "{}", documentation.fmt(None))?;
                        write!(f, "    {}", self.cfg_gate_ln(config))?;
                        write!(f, "    {availability}")?;
                        if *must_use {
                            writeln!(f, "    #[must_use]")?;
                        }

                        raw_fn_decl(f, "pub ")?;

                        writeln!(f, "}}")?;
                    }
                }
                Self::FnGetTypeId {
                    id,
                    cf_id,
                    result_type,
                    availability: _, // #[deprecated] is useless on traits.
                    can_unwind,
                    documentation,
                } => {
                    let abi = if *can_unwind { "C-unwind" } else { "C" };

                    let (ret, _) = result_type.fn_return(false);

                    // Only emit for base types, not for mutable subclasses,
                    // as it's unclear whether it's safe to downcast to
                    // mutable subclasses. Similarly, we only implement this
                    // for the base generic type (`CFArray<c_void>`).
                    write!(f, "{}", self.cfg_gate_ln(config))?;
                    writeln!(f, "unsafe impl ConcreteType for {} {{", cf_id.path())?;

                    write!(f, "{}", documentation.fmt(None))?;
                    writeln!(f, "    #[doc(alias = {:?})]", id.name)?;
                    writeln!(f, "    #[inline]")?;
                    writeln!(f, "    fn type_id(){ret} {{")?;

                    writeln!(f, "        extern {abi:?} {{")?;
                    writeln!(f, "            fn {}(){ret};", id.name,)?;
                    writeln!(f, "        }}")?;

                    writeln!(f, "        unsafe {{ {}() }}", id.name)?;

                    writeln!(f, "    }}")?;
                    writeln!(f, "}}")?;
                    return Ok(());
                }
                Self::AliasDecl {
                    id,
                    availability: _,
                    ty,
                    kind,
                    documentation,
                } => {
                    write!(f, "{}", documentation.fmt(Some(id)))?;
                    match kind {
                        Some(UnexposedAttr::TypedEnum) => {
                            // TODO: Handle this differently
                            writeln!(f, "// NS_TYPED_ENUM")?;
                            write!(f, "{}", self.cfg_gate_ln(config))?;
                            writeln!(f, "pub type {} = {};", id.name, ty.typedef())?;
                        }
                        Some(UnexposedAttr::TypedExtensibleEnum) => {
                            // TODO: Handle this differently
                            writeln!(f, "// NS_TYPED_EXTENSIBLE_ENUM")?;
                            write!(f, "{}", self.cfg_gate_ln(config))?;
                            writeln!(f, "pub type {} = {};", id.name, ty.typedef())?;
                        }
                        kind => {
                            if !matches!(
                                kind,
                                None | Some(UnexposedAttr::BridgedTypedef | UnexposedAttr::Bridged)
                            ) {
                                error!("invalid alias kind {kind:?} for {ty:?}");
                            }
                            // "bridged" typedefs should use a normal type alias.
                            write!(f, "{}", self.cfg_gate_ln(config))?;
                            writeln!(f, "pub type {} = {};", id.name, ty.typedef())?;
                        }
                    }
                }
                Self::OpaqueDecl {
                    id,
                    generics,
                    encoding_name,
                    availability,
                    documentation,
                    is_cf,
                    superclass,
                } => {
                    write!(f, "{}", documentation.fmt(Some(id)))?;
                    write!(f, "{availability}")?;
                    write!(f, "{}", self.cfg_gate_ln(config))?;
                    writeln!(f, "#[repr(C)]")?;
                    if !*is_cf {
                        // To avoid warnings, though mostly useless.
                        writeln!(f, "#[derive(Debug)]")?;
                    }
                    // Default generics to `Opaque` helper type.
                    writeln!(
                        f,
                        "pub struct {}{} {{",
                        id.name,
                        GenericParamsHelper(generics, "?Sized = Opaque")
                    )?;
                    // Make the type be considered FFI-safe.
                    writeln!(f, "    inner: [u8; 0],")?;
                    // Same as objc2::ffi::OpaqueData, almost equivalent to using `extern type`.
                    writeln!(
                        f,
                        "    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,"
                    )?;
                    if !generics.is_empty() {
                        write!(f, "    _generics: PhantomData<(")?;
                        for generic in generics {
                            // Make generics invariant (like in `objc2::extern_class!`).
                            write!(f, "*mut {generic}, ")?;
                        }
                        writeln!(f, ")>,")?;
                    }
                    writeln!(f, "}}")?;

                    writeln!(f)?;

                    // Similar to the output of extern_class!
                    if *is_cf {
                        let required_items = self
                            .required_items()
                            .chain(iter::once(ItemTree::cf("cf_type")));
                        let cfg_cf = self.cfg_gate_ln_for(required_items, config);
                        write!(f, "{cfg_cf}")?;
                        // SAFETY: The type is a CoreFoundation type, and
                        // correctly declared as a #[repr(C)] ZST.
                        writeln!(f, "cf_type!(")?;

                        // SAFETY: It's fine to implement helper traits for
                        // all generics (e.g. all of `CFArray<u32>`,
                        // `CFArray<CFString>` and `CFArray<Box<String>>`),
                        // since unlike e.g. `NSArray<u32>`, these are all
                        // perfectly valid types (their correct construction
                        // is controlled with CFArrayCallBacks).
                        write!(
                            f,
                            "    unsafe impl{} {}{}",
                            GenericParamsHelper(generics, "?Sized"),
                            id.name,
                            GenericTyHelper(generics),
                        )?;
                        if let Some(superclass) = superclass {
                            write!(f, ": {}{}", superclass.name, GenericTyHelper(generics))?;
                        }
                        writeln!(f, " {{}}")?;
                        writeln!(f, ");")?;

                        let required_items = self
                            .required_items()
                            .chain(iter::once(ItemTree::objc("cf_objc2_type")));
                        let cfg_objc2 = self.cfg_gate_ln_for(required_items, config);
                        write!(f, "{cfg_objc2}")?;
                        writeln!(f, "cf_objc2_type!(")?;
                        // SAFETY: The type is a CoreFoundation type.
                        writeln!(
                            f,
                            "    unsafe impl{} RefEncode<{encoding_name:?}> for {}{} {{}}",
                            GenericParamsHelper(generics, "?Sized"),
                            id.name,
                            GenericTyHelper(generics),
                        )?;
                        writeln!(f, ");")?;
                    } else {
                        let required_items = self
                            .required_items()
                            .chain(iter::once(ItemTree::objc("Encoding")));
                        let cfg_encoding = self.cfg_gate_ln_for(required_items, config);
                        // SAFETY: The struct is a ZST type marked `#[repr(C)]`.
                        write!(f, "{cfg_encoding}")?;
                        writeln!(
                            f,
                            "unsafe impl{} RefEncode for {}{} {{",
                            GenericParamsHelper(generics, "UnknownBound"),
                            id.name,
                            GenericTyHelper(generics)
                        )?;
                        write!(f, "    const ENCODING_REF: Encoding = ")?;
                        writeln!(f, "Encoding::Pointer(&Encoding::Struct(")?;
                        writeln!(f, "        {encoding_name:?},")?;
                        writeln!(f, "        &[],")?;
                        writeln!(f, "    ));")?;
                        writeln!(f, "}}")?;
                    }
                }
            };
            Ok(())
        })
    }

    pub(crate) fn encoding_test<'a>(&'a self, config: &'a Config) -> Option<impl Display + 'a> {
        let (data, availability, cls, cls_generics, methods) = match self {
            Stmt::ExternMethods {
                location,
                availability,
                cls,
                cls_generics,
                methods,
                ..
            } => (
                config.library(location),
                availability,
                cls,
                &**cls_generics,
                methods,
            ),
            Stmt::ExternCategory {
                id,
                availability,
                cls,
                cls_generics,
                methods,
                ..
            } => (
                config.library(id),
                availability,
                cls,
                &**cls_generics,
                methods,
            ),
            // TODO: Test protocols too
            _ => return None,
        };

        Some(FormatterFn(move |f| {
            write!(
                f,
                "{}",
                simple_platform_gate(data, self.required_items(), [], config)
            )?;
            if let Some(check) = availability.check_is_available() {
                writeln!(f, "    if {check} ")?;
            }
            writeln!(f, "    {{")?;
            for generic in cls_generics {
                writeln!(f, "        type {generic} = AnyObject;")?;
            }
            write!(f, "        type This = {}<", cls.path())?;
            for generic in cls_generics {
                write!(f, "{generic}, ")?;
            }
            writeln!(f, ">;")?;
            writeln!(f, "        let cls = This::class();")?;
            writeln!(f, "        let metaclass = cls.metaclass();")?;

            for method in methods {
                write!(
                    f,
                    "{}",
                    simple_platform_gate(
                        data,
                        method.required_items(),
                        self.required_items(),
                        config
                    )
                )?;
                write!(f, "{}", method.encoding_test(false))?;
            }

            writeln!(f, "    }}")?;

            Ok(())
        }))
    }

    pub(crate) fn static_test<'a>(&'a self, config: &'a Config) -> Option<impl Display + 'a> {
        match self {
            Self::VarDecl {
                id,
                availability,
                ty,
                value: None,
                ..
            } => {
                if !availability.is_available_host() {
                    return None;
                }
                Some(FormatterFn(move |f| {
                    write!(
                        f,
                        "{}",
                        simple_platform_gate(config.library(id), self.required_items(), [], config,)
                    )?;
                    let ty = ty.var().to_string();
                    if ty.starts_with("&'static") {
                        writeln!(f, "    check_static_nonnull(unsafe {{ {} }});", id.path())?;
                    } else {
                        writeln!(f, "    let _ = unsafe {{ {} }};", id.path())?;
                    }

                    Ok(())
                }))
            }
            _ => None,
        }
    }
}

fn simple_platform_gate(
    data: &LibraryConfig,
    required_items: impl IntoIterator<Item = ItemTree>,
    implied_items: impl IntoIterator<Item = ItemTree>,
    config: &Config,
) -> impl Display {
    let mut platform_cfg = PlatformCfg::from_config(data);

    for item in required_items {
        platform_cfg.dependency(config.library(item.id()));
    }

    for item in implied_items {
        platform_cfg.implied(config.library(item.id()));
    }

    FormatterFn(move |f| {
        if let Some(cfg) = platform_cfg.cfgs() {
            writeln!(f, "#[cfg({cfg})]")?;
        }

        Ok(())
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_superclasses_required_items() {
        let superclasses = [
            ItemIdentifier::dummy(1),
            ItemIdentifier::dummy(2),
            ItemIdentifier::dummy(3),
        ];
        let required_items = [
            ItemTree::new(
                ItemIdentifier::dummy(1),
                [
                    ItemTree::new(
                        ItemIdentifier::dummy(2),
                        [
                            ItemTree::new(ItemIdentifier::dummy(3), [ItemTree::objc("__macros__")]),
                            ItemTree::objc("__macros__"),
                        ],
                    ),
                    ItemTree::new(ItemIdentifier::dummy(3), [ItemTree::objc("__macros__")]),
                    ItemTree::objc("__macros__"),
                ],
            ),
            ItemTree::new(
                ItemIdentifier::dummy(2),
                [
                    ItemTree::new(ItemIdentifier::dummy(3), [ItemTree::objc("__macros__")]),
                    ItemTree::objc("__macros__"),
                ],
            ),
            ItemTree::new(ItemIdentifier::dummy(3), [ItemTree::objc("__macros__")]),
            ItemTree::objc("__macros__"),
        ];
        assert_eq!(
            superclasses_required_items(superclasses).collect::<Vec<_>>(),
            required_items
        );
    }
}
