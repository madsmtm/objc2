use std::borrow::Cow;
use std::collections::BTreeSet;
use std::collections::HashSet;
use std::fmt;
use std::iter;
use std::mem;

use clang::{Entity, EntityKind, EntityVisitResult};

use crate::availability::{Availability, Unavailable};
use crate::config::{ClassData, MethodData};
use crate::context::Context;
use crate::expr::Expr;
use crate::id::ItemIdentifier;
use crate::immediate_children;
use crate::method::{handle_reserved, Method};
use crate::rust_type::{Ownership, Ty};
use crate::unexposed_attr::UnexposedAttr;

#[derive(serde::Deserialize, Debug, Clone, PartialEq, Eq)]
pub struct Derives(Cow<'static, str>);

impl Default for Derives {
    fn default() -> Self {
        Derives("Debug, PartialEq, Eq, Hash".into())
    }
}

impl fmt::Display for Derives {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if !self.0.is_empty() {
            write!(f, "#[derive({})]", self.0)?;
        }
        Ok(())
    }
}

/// Find all protocols, protocol's protocols and superclass' protocols.
fn parse_protocols(
    entity: &Entity<'_>,
    protocols: &mut BTreeSet<ItemIdentifier>,
    context: &Context<'_>,
) {
    immediate_children(entity, |entity, _span| match entity.get_kind() {
        EntityKind::ObjCProtocolRef => {
            let entity = entity
                .get_reference()
                .expect("ObjCProtocolRef to reference entity");
            if protocols.insert(
                ItemIdentifier::new(&entity, context)
                    .map_name(|name| context.replace_protocol_name(name)),
            ) {
                // Only recurse if we haven't already seen this protocol
                parse_protocols(&entity, protocols, context);
            }
        }
        EntityKind::ObjCSuperClassRef => {
            let entity = entity
                .get_reference()
                .expect("ObjCSuperClassRef to reference entity");
            parse_protocols(&entity, protocols, context);
        }
        _ => {}
    });
}

fn parse_superclass<'ty>(
    entity: &Entity<'ty>,
    context: &Context<'_>,
) -> Option<(Entity<'ty>, ItemIdentifier, Vec<String>)> {
    let mut superclass = None;
    let mut generics = Vec::new();

    immediate_children(entity, |entity, _span| match entity.get_kind() {
        EntityKind::ObjCSuperClassRef => {
            superclass = Some(
                entity
                    .get_reference()
                    .expect("ObjCSuperClassRef to reference entity"),
            );
        }
        EntityKind::TypeRef => {
            let name = entity.get_name().expect("typeref name");
            generics.push(name);
        }
        _ => {}
    });

    superclass.map(|entity| (entity, ItemIdentifier::new(&entity, context), generics))
}

/// Takes one of:
/// - `EntityKind::ObjCInterfaceDecl`
/// - `EntityKind::ObjCProtocolDecl`
/// - `EntityKind::ObjCCategoryDecl`
fn parse_objc_decl(
    entity: &Entity<'_>,
    superclass: bool,
    mut generics: Option<&mut Vec<String>>,
    get_data: impl Fn(&str) -> MethodData,
    context: &Context<'_>,
    library_unavailablility: &Unavailable,
) -> (BTreeSet<ItemIdentifier>, Vec<Method>, Vec<String>) {
    let mut protocols = BTreeSet::new();
    let mut methods = Vec::new();
    let mut designated_initializers = Vec::new();

    // Track seen properties, so that when methods are autogenerated by the
    // compiler from them, we can skip them
    let mut properties = HashSet::new();

    immediate_children(entity, |entity, span| match entity.get_kind() {
        EntityKind::ObjCExplicitProtocolImpl if generics.is_none() && !superclass => {
            // TODO NS_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION
        }
        EntityKind::ObjCIvarDecl | EntityKind::StructDecl | EntityKind::UnionDecl if superclass => {
            // Explicitly ignored
        }
        EntityKind::ObjCSuperClassRef | EntityKind::TypeRef if superclass => {
            // Parsed in parse_superclass
        }
        EntityKind::ObjCSubclassingRestricted if superclass => {
            // TODO: https://clang.llvm.org/docs/AttributeReference.html#objc-subclassing-restricted
        }
        EntityKind::ObjCRootClass => {
            debug!("parsing root class");
        }
        EntityKind::ObjCClassRef if generics.is_some() => {
            // debug!("ObjCClassRef: {:?}", entity.get_display_name());
        }
        EntityKind::TemplateTypeParameter => {
            if let Some(generics) = &mut generics {
                // TODO: Generics with bounds (like NSMeasurement<UnitType: NSUnit *>)
                // let ty = entity.get_type().expect("template type");
                let name = entity.get_name().expect("template name");
                generics.push(name);
            } else {
                error!("unsupported generics");
            }
        }
        EntityKind::ObjCProtocolRef => {
            let entity = entity
                .get_reference()
                .expect("ObjCProtocolRef to reference entity");
            protocols.insert(
                ItemIdentifier::new(&entity, context)
                    .map_name(|name| context.replace_protocol_name(name)),
            );
        }
        EntityKind::ObjCInstanceMethodDecl | EntityKind::ObjCClassMethodDecl => {
            drop(span);
            let partial = Method::partial(entity);

            if !properties.remove(&(partial.is_class, partial.fn_name.clone())) {
                let data = get_data(&partial.fn_name);
                if let Some((designated_initializer, method)) =
                    partial.parse(data, generics.is_none(), context, library_unavailablility)
                {
                    if designated_initializer {
                        designated_initializers.push(method.fn_name.clone());
                    }
                    methods.push(method);
                }
            }
        }
        EntityKind::ObjCPropertyDecl => {
            drop(span);
            let partial = Method::partial_property(entity);

            let getter_data = get_data(&partial.getter_name);
            let setter_data = partial
                .setter_name
                .as_ref()
                .map(|setter_name| get_data(setter_name));

            let (getter, setter) = partial.parse(
                getter_data,
                setter_data,
                generics.is_none(),
                context,
                library_unavailablility,
            );
            if let Some(getter) = getter {
                if !properties.insert((getter.is_class, getter.fn_name.clone())) {
                    error!(?setter, "already exisiting property");
                }
                methods.push(getter);
            }
            if let Some(setter) = setter {
                if !properties.insert((setter.is_class, setter.fn_name.clone())) {
                    error!(?setter, "already exisiting property");
                }
                methods.push(setter);
            }
        }
        EntityKind::VisibilityAttr => {
            // Already exposed as entity.get_visibility()
        }
        EntityKind::ObjCException if superclass => {
            // Maybe useful for knowing when to implement `Error` for the type
        }
        EntityKind::UnexposedAttr => {
            if let Some(attr) = UnexposedAttr::parse(&entity, context) {
                error!(?attr, "unknown attribute");
            }
        }
        _ => error!("unknown"),
    });

    if !properties.is_empty() {
        error!(
            ?methods,
            ?properties,
            "did not properly add methods to properties"
        );
    }

    (protocols, methods, designated_initializers)
}

#[derive(Debug, Clone, PartialEq)]
pub enum Stmt {
    /// @interface name: superclass <protocols*>
    /// ->
    /// extern_class!
    ClassDecl {
        id: ItemIdentifier,
        generics: Vec<String>,
        availability: Availability,
        superclasses: Vec<(ItemIdentifier, Vec<String>)>,
        designated_initializers: Vec<String>,
        derives: Derives,
        ownership: Ownership,
    },
    /// @interface class_name (name) <protocols*>
    /// ->
    /// extern_methods!
    Methods {
        cls: ItemIdentifier,
        generics: Vec<String>,
        /// For the categories that have a name (though some don't, see NSClipView)
        category: ItemIdentifier<Option<String>>,
        availability: Availability,
        superclasses: Vec<(ItemIdentifier, Vec<String>)>,
        methods: Vec<Method>,
        description: Option<String>,
    },
    /// @protocol name <protocols*>
    /// ->
    /// extern_protocol!
    ProtocolDecl {
        id: ItemIdentifier,
        availability: Availability,
        protocols: BTreeSet<ItemIdentifier>,
        methods: Vec<Method>,
    },
    /// @interface ty: _ <protocols*>
    /// @interface ty (_) <protocols*>
    ProtocolImpl {
        cls: ItemIdentifier,
        protocol: ItemIdentifier,
        generics: Vec<String>,
        availability: Availability,
    },
    /// struct name {
    ///     fields*
    /// };
    ///
    /// typedef struct {
    ///     fields*
    /// } name;
    ///
    /// typedef struct _name {
    ///     fields*
    /// } name;
    StructDecl {
        id: ItemIdentifier,
        // internal objc struct name (before typedef). shows up in encoding
        // and is used in message verification.
        encoding_name: Option<String>,
        availability: Availability,
        boxable: bool,
        fields: Vec<(String, Ty)>,
    },
    /// typedef NS_OPTIONS(type, name) {
    ///     variants*
    /// };
    ///
    /// typedef NS_ENUM(type, name) {
    ///     variants*
    /// };
    ///
    /// enum name {
    ///     variants*
    /// };
    ///
    /// enum {
    ///     variants*
    /// };
    EnumDecl {
        id: ItemIdentifier<Option<String>>,
        availability: Availability,
        ty: Ty,
        kind: Option<UnexposedAttr>,
        variants: Vec<(String, Availability, Expr)>,
    },
    /// static const ty name = expr;
    /// extern const ty name;
    VarDecl {
        id: ItemIdentifier,
        availability: Availability,
        ty: Ty,
        value: Option<Expr>,
    },
    /// extern ret name(args*);
    ///
    /// static inline ret name(args*) {
    ///     body
    /// }
    FnDecl {
        id: ItemIdentifier,
        availability: Availability,
        arguments: Vec<(String, Ty)>,
        result_type: Ty,
        // Some -> inline function.
        body: Option<()>,
        safe: bool,
    },
    /// typedef Type TypedefName;
    AliasDecl {
        id: ItemIdentifier,
        availability: Availability,
        ty: Ty,
        kind: Option<UnexposedAttr>,
    },
}

fn parse_struct(entity: &Entity<'_>, context: &Context<'_>) -> (bool, Vec<(String, Ty)>) {
    let mut boxable = false;
    let mut fields = Vec::new();

    immediate_children(entity, |entity, span| match entity.get_kind() {
        EntityKind::UnexposedAttr => {
            if let Some(attr) = UnexposedAttr::parse(&entity, context) {
                error!(?attr, "unknown attribute");
            }
        }
        EntityKind::FieldDecl => {
            drop(span);
            let name = entity.get_name().expect("struct field name");
            let _span = debug_span!("field", name).entered();

            let ty = entity.get_type().expect("struct field type");
            let ty = Ty::parse_struct_field(ty, context);

            if entity.is_bit_field() {
                error!("unsound struct bitfield");
            }

            fields.push((name, ty))
        }
        EntityKind::ObjCBoxable => {
            boxable = true;
        }
        EntityKind::UnionDecl => error!("can't handle unions in structs yet"),
        _ => error!("unknown"),
    });

    (boxable, fields)
}

fn parse_fn_param_children(entity: &Entity<'_>, context: &Context<'_>) {
    immediate_children(entity, |entity, _span| match entity.get_kind() {
        EntityKind::UnexposedAttr => {
            if let Some(attr) = UnexposedAttr::parse(&entity, context) {
                error!(?attr, "unknown attribute");
            }
        }
        EntityKind::ObjCClassRef | EntityKind::TypeRef | EntityKind::ObjCProtocolRef => {}
        EntityKind::NSConsumed => {
            error!("found NSConsumed, which requires manual handling");
        }
        kind => error!(?kind, "unknown"),
    });
}

impl Stmt {
    pub fn parse(
        entity: &Entity<'_>,
        context: &Context<'_>,
        library_unavailablility: &Unavailable,
    ) -> Vec<Self> {
        let _span = debug_span!(
            "stmt",
            kind = ?entity.get_kind(),
            dbg = entity.get_name(),
        )
        .entered();

        match entity.get_kind() {
            // These are inconsequential for us, since we resolve imports differently
            EntityKind::ObjCClassRef | EntityKind::ObjCProtocolRef => vec![],
            EntityKind::ObjCInterfaceDecl => {
                // entity.get_mangled_objc_names()
                let id = ItemIdentifier::new(entity, context);
                let data = context.class_data.get(&id.name);

                if data.map(|data| data.skipped).unwrap_or_default() {
                    return vec![];
                }

                let availability = Availability::parse(entity, context, library_unavailablility);
                let mut generics = Vec::new();

                let (_, methods, designated_initializers) = parse_objc_decl(
                    entity,
                    true,
                    Some(&mut generics),
                    |name| ClassData::get_method_data(data, name),
                    context,
                    library_unavailablility,
                );

                let mut protocols = Default::default();
                parse_protocols(entity, &mut protocols, context);

                let skipped_protocols = data
                    .map(|data| data.skipped_protocols.clone())
                    .unwrap_or_default();
                protocols.retain(|protocol| !skipped_protocols.contains(&protocol.name));

                let mut superclass_entity = *entity;
                let mut superclasses = vec![];

                while let Some((next_entity, superclass, generics)) =
                    parse_superclass(&superclass_entity, context)
                {
                    superclass_entity = next_entity;
                    superclasses.push((superclass, generics));
                }

                let methods = Self::Methods {
                    cls: id.clone(),
                    generics: generics.clone(),
                    category: ItemIdentifier::with_name(None, entity, context),
                    availability: availability.clone(),
                    superclasses: superclasses.clone(),
                    methods,
                    description: None,
                };

                if !data.map(|data| data.definition_skipped).unwrap_or_default() {
                    iter::once(Self::ClassDecl {
                        id: id.clone(),
                        generics: generics.clone(),
                        availability: availability.clone(),
                        superclasses,
                        designated_initializers,
                        derives: data.map(|data| data.derives.clone()).unwrap_or_default(),
                        ownership: data.map(|data| data.ownership.clone()).unwrap_or_default(),
                    })
                    .chain(protocols.into_iter().map(|protocol| Self::ProtocolImpl {
                        cls: id.clone(),
                        protocol,
                        generics: generics.clone(),
                        availability: availability.clone(),
                    }))
                    .chain(iter::once(methods))
                    .collect()
                } else {
                    vec![methods]
                }
            }
            EntityKind::ObjCCategoryDecl => {
                let category = ItemIdentifier::new_optional(entity, context);
                let availability = Availability::parse(entity, context, library_unavailablility);

                let mut cls = None;
                entity.visit_children(|entity, _parent| {
                    if entity.get_kind() == EntityKind::ObjCClassRef {
                        if cls.is_some() {
                            panic!("could not find unique category class")
                        }
                        let definition = entity
                            .get_definition()
                            .expect("category class ref definition");
                        cls = Some(ItemIdentifier::new(&definition, context));
                        EntityVisitResult::Break
                    } else {
                        EntityVisitResult::Continue
                    }
                });
                let cls = cls.expect("could not find category class");
                let data = context.class_data.get(&cls.name);

                if data.map(|data| data.skipped).unwrap_or_default() {
                    return vec![];
                }

                if let Some(category_name) = &category.name {
                    let category_data = data
                        .and_then(|data| data.categories.get(category_name))
                        .cloned()
                        .unwrap_or_default();

                    if category_data.skipped {
                        return vec![];
                    }
                }

                let mut generics = Vec::new();

                let (protocols, methods, designated_initializers) = parse_objc_decl(
                    entity,
                    false,
                    Some(&mut generics),
                    |name| ClassData::get_method_data(data, name),
                    context,
                    library_unavailablility,
                );

                if !designated_initializers.is_empty() {
                    warn!(
                        ?designated_initializers,
                        "designated initializer in category"
                    )
                }

                let mut superclass_entity = *entity;
                let mut superclasses = vec![];

                while let Some((next_entity, superclass, generics)) =
                    parse_superclass(&superclass_entity, context)
                {
                    superclass_entity = next_entity;
                    superclasses.push((superclass, generics));
                }

                iter::once(Self::Methods {
                    cls: cls.clone(),
                    generics: generics.clone(),
                    category,
                    availability: availability.clone(),
                    superclasses,
                    methods,
                    description: None,
                })
                .chain(protocols.into_iter().map(|protocol| Self::ProtocolImpl {
                    cls: cls.clone(),
                    generics: generics.clone(),
                    availability: availability.clone(),
                    protocol,
                }))
                .collect()
            }
            EntityKind::ObjCProtocolDecl => {
                let id = ItemIdentifier::new(entity, context)
                    .map_name(|name| context.replace_protocol_name(name));
                let data = context.protocol_data.get(&id.name);

                if data.map(|data| data.skipped).unwrap_or_default() {
                    return vec![];
                }

                let availability = Availability::parse(entity, context, library_unavailablility);

                let (protocols, methods, designated_initializers) = parse_objc_decl(
                    entity,
                    false,
                    None,
                    |name| {
                        data.and_then(|data| data.methods.get(name))
                            .copied()
                            .unwrap_or_default()
                    },
                    context,
                    library_unavailablility,
                );

                if !designated_initializers.is_empty() {
                    warn!(
                        ?designated_initializers,
                        "designated initializer in protocol"
                    )
                }

                vec![Self::ProtocolDecl {
                    id,
                    availability,
                    protocols,
                    methods,
                }]
            }
            EntityKind::TypedefDecl => {
                let id = ItemIdentifier::new(entity, context);
                let availability = Availability::parse(entity, context, library_unavailablility);
                let mut struct_ = None;
                let mut encoding_name = "?".to_string();
                let mut skip_struct = false;
                let mut kind = None;

                immediate_children(entity, |entity, _span| match entity.get_kind() {
                    EntityKind::UnexposedAttr => {
                        if let Some(attr) = UnexposedAttr::parse(&entity, context) {
                            if kind.is_some() {
                                panic!("got multiple unexposed attributes {kind:?}, {attr:?}");
                            }
                            kind = Some(attr);
                        }
                    }
                    EntityKind::StructDecl => {
                        if context
                            .struct_data
                            .get(&id.name)
                            .map(|data| data.skipped)
                            .unwrap_or_default()
                        {
                            skip_struct = true;
                            return;
                        }

                        if let Some(name) = entity.get_name() {
                            // if the struct has a name use it
                            // otherwise it will be the default "?"
                            encoding_name = name;
                        }

                        if encoding_name == "?" || encoding_name.starts_with('_') {
                            // If this struct doesn't have a name, or the
                            // name is private, let's parse it with the
                            // typedef name.
                            struct_ = Some(parse_struct(&entity, context))
                        } else {
                            skip_struct = true;
                        }
                    }
                    EntityKind::ObjCClassRef
                    | EntityKind::ObjCProtocolRef
                    | EntityKind::TypeRef
                    | EntityKind::ParmDecl => {}
                    _ => error!("unknown"),
                });

                if let Some((boxable, fields)) = struct_ {
                    assert_eq!(kind, None, "should not have parsed a kind");
                    return vec![Self::StructDecl {
                        id,
                        encoding_name: Some(encoding_name),
                        availability,
                        boxable,
                        fields,
                    }];
                }

                if skip_struct {
                    return vec![];
                }

                if context
                    .typedef_data
                    .get(&id.name)
                    .map(|data| data.skipped)
                    .unwrap_or_default()
                {
                    return vec![];
                }

                let ty = entity
                    .get_typedef_underlying_type()
                    .expect("typedef underlying type");
                if let Some(ty) = Ty::parse_typedef(ty, &id.name, context) {
                    vec![Self::AliasDecl {
                        id,
                        availability,
                        ty,
                        kind,
                    }]
                } else {
                    vec![]
                }
            }
            EntityKind::StructDecl => {
                if let Some(name) = entity.get_name() {
                    let availability =
                        Availability::parse(entity, context, library_unavailablility);
                    let id = ItemIdentifier::with_name(name, entity, context);

                    if context
                        .struct_data
                        .get(&id.name)
                        .map(|data| data.skipped)
                        .unwrap_or_default()
                    {
                        return vec![];
                    }

                    // See https://github.com/rust-lang/rust-bindgen/blob/95fd17b874910184cc0fcd33b287fa4e205d9d7a/bindgen/ir/comp.rs#L1392-L1408
                    if !entity.is_definition() {
                        return vec![];
                    }

                    if !id.name.starts_with('_') {
                        let (boxable, fields) = parse_struct(entity, context);
                        return vec![Self::StructDecl {
                            id,
                            encoding_name: None,
                            availability,
                            boxable,
                            fields,
                        }];
                    }
                }
                vec![]
            }
            EntityKind::EnumDecl => {
                // Enum declarations show up twice for some reason, but
                // luckily this flag is set on the least descriptive entity.
                if !entity.is_definition() {
                    return vec![];
                }

                let id = ItemIdentifier::new_optional(entity, context);

                let data = context
                    .enum_data
                    .get(id.name.as_deref().unwrap_or("anonymous"))
                    .cloned()
                    .unwrap_or_default();
                if data.skipped {
                    return vec![];
                }

                let availability = Availability::parse(entity, context, library_unavailablility);

                let ty = entity.get_enum_underlying_type().expect("enum type");
                let is_signed = ty.is_signed_integer();
                let ty = Ty::parse_enum(ty, context);
                let mut kind = None;
                let mut variants = Vec::new();

                immediate_children(entity, |entity, _span| match entity.get_kind() {
                    EntityKind::EnumConstantDecl => {
                        let name = entity.get_name().expect("enum constant name");
                        let availability =
                            Availability::parse(&entity, context, library_unavailablility);

                        if data
                            .constants
                            .get(&name)
                            .map(|data| data.skipped)
                            .unwrap_or_default()
                        {
                            return;
                        }

                        let pointer_width =
                            entity.get_translation_unit().get_target().pointer_width;

                        let val = Expr::from_val(
                            entity
                                .get_enum_constant_value()
                                .expect("enum constant value"),
                            is_signed,
                            pointer_width,
                        );
                        let expr = if data.use_value {
                            val
                        } else {
                            Expr::parse_enum_constant(&entity, context).unwrap_or(val)
                        };
                        variants.push((name, availability, expr));
                    }
                    EntityKind::UnexposedAttr => {
                        if let Some(attr) = UnexposedAttr::parse(&entity, context) {
                            if let Some(kind) = &kind {
                                assert_eq!(kind, &attr, "got differing enum kinds in {id:?}");
                            } else {
                                kind = Some(attr);
                            }
                        }
                    }
                    EntityKind::FlagEnum => {
                        let macro_ = UnexposedAttr::Options;
                        if let Some(kind) = &kind {
                            assert_eq!(kind, &macro_, "got differing enum kinds in {id:?}");
                        } else {
                            kind = Some(macro_);
                        }
                    }
                    EntityKind::VisibilityAttr => {
                        // Already exposed as entity.get_visibility()
                    }
                    _ => error!("unknown"),
                });

                if id.name.is_none() && variants.is_empty() {
                    return vec![];
                }

                vec![Self::EnumDecl {
                    id,
                    availability,
                    ty,
                    kind,
                    variants,
                }]
            }
            EntityKind::VarDecl => {
                let id = ItemIdentifier::new(entity, context);

                if context
                    .statics
                    .get(&id.name)
                    .map(|data| data.skipped)
                    .unwrap_or_default()
                {
                    return vec![];
                }

                let availability = Availability::parse(entity, context, library_unavailablility);
                let ty = entity.get_type().expect("var type");
                let ty = Ty::parse_static(ty, context);
                let mut value = None;

                immediate_children(entity, |entity, _span| match entity.get_kind() {
                    EntityKind::UnexposedAttr => {
                        if let Some(attr) = UnexposedAttr::parse(&entity, context) {
                            error!(?attr, "unknown attribute");
                        }
                    }
                    EntityKind::VisibilityAttr => {}
                    EntityKind::ObjCClassRef => {}
                    EntityKind::TypeRef => {}
                    _ if entity.is_expression() => {
                        if value.is_none() {
                            value = Some(Expr::parse_var(&entity));
                        } else {
                            panic!("got variable value twice")
                        }
                    }
                    _ => panic!("unknown vardecl child in {id:?}: {entity:?}"),
                });

                let value = match value {
                    Some(Some(expr)) => Some(expr),
                    Some(None) => {
                        warn!("skipped static");
                        return vec![];
                    }
                    None => None,
                };

                vec![Self::VarDecl {
                    id,
                    availability,
                    ty,
                    value,
                }]
            }
            EntityKind::FunctionDecl => {
                let id = ItemIdentifier::new(entity, context);

                let data = context.fns.get(&id.name).cloned().unwrap_or_default();

                if data.skipped {
                    return vec![];
                }

                if entity.is_variadic() {
                    warn!("can't handle variadic function");
                    return vec![];
                }

                let availability = Availability::parse(entity, context, library_unavailablility);
                let result_type = entity.get_result_type().expect("function result type");
                let result_type = Ty::parse_function_return(result_type, context);
                let mut arguments = Vec::new();

                if entity.is_static_method() {
                    warn!("unexpected static method");
                }

                immediate_children(entity, |entity, _span| match entity.get_kind() {
                    EntityKind::UnexposedAttr => {
                        if let Some(attr) = UnexposedAttr::parse(&entity, context) {
                            error!(?attr, "unknown attribute");
                        }
                    }
                    EntityKind::ObjCClassRef
                    | EntityKind::TypeRef
                    | EntityKind::ObjCProtocolRef => {}
                    EntityKind::ParmDecl => {
                        parse_fn_param_children(&entity, context);
                        // Could also be retrieved via. `get_arguments`
                        let name = entity.get_name().unwrap_or_else(|| "_".into());
                        let ty = entity.get_type().expect("function argument type");
                        let ty = Ty::parse_function_argument(ty, context);
                        arguments.push((name, ty))
                    }
                    EntityKind::VisibilityAttr => {
                        // CG_EXTERN or UIKIT_EXTERN
                    }
                    _ => error!("unknown"),
                });

                let body = if entity.is_inline_function() {
                    Some(())
                } else {
                    None
                };

                vec![Self::FnDecl {
                    id,
                    availability,
                    arguments,
                    result_type,
                    body,
                    safe: !data.unsafe_,
                }]
            }
            EntityKind::UnionDecl => {
                let id = ItemIdentifier::new_optional(entity, context);
                error!(
                    ?id,
                    has_attributes = ?entity.has_attributes(),
                    children = ?entity.get_children(),
                    "union",
                );
                vec![]
            }
            EntityKind::UnexposedDecl => {
                // `@compatibility_alias`, can be ignored (since we don't
                // need to support older SDK versions).
                vec![]
            }
            _ => {
                error!("unknown");
                vec![]
            }
        }
    }

    pub fn compare(&self, other: &Self) {
        if self != other {
            if let (
                Self::Methods {
                    methods: self_methods,
                    ..
                },
                Self::Methods {
                    methods: other_methods,
                    ..
                },
            ) = (&self, &other)
            {
                super::compare_slice(
                    self_methods,
                    other_methods,
                    |i, self_method, other_method| {
                        let _span = debug_span!("method", i).entered();
                        assert_eq!(self_method, other_method, "methods were not equal");
                    },
                );
            }

            panic!("statements were not equal:\n{self:#?}\n{other:#?}");
        }
    }

    pub fn visit_required_types(&self, mut f: impl FnMut(&ItemIdentifier)) {
        match self {
            Stmt::ClassDecl { id, .. } => {
                f(id);
            }
            Stmt::FnDecl {
                arguments,
                result_type,
                ..
            } => {
                for (_, arg) in arguments {
                    arg.visit_required_types(&mut f);
                }

                result_type.visit_required_types(&mut f);
            }
            _ => {}
        }
    }

    pub(crate) fn declared_types(&self) -> impl Iterator<Item = (&str, &Unavailable)> {
        match self {
            Stmt::ClassDecl {
                id, availability, ..
            } => Some((&*id.name, &availability.unavailable)),
            Stmt::Methods { .. } => None,
            Stmt::ProtocolDecl {
                id, availability, ..
            } => Some((&*id.name, &availability.unavailable)),
            Stmt::ProtocolImpl { .. } => None,
            Stmt::StructDecl {
                id, availability, ..
            } => Some((&*id.name, &availability.unavailable)),
            Stmt::EnumDecl {
                id, availability, ..
            } => id
                .name
                .as_deref()
                .map(|name| (name, &availability.unavailable)),
            Stmt::VarDecl {
                id, availability, ..
            } => Some((&*id.name, &availability.unavailable)),
            Stmt::FnDecl {
                id,
                body,
                availability,
                ..
            } if body.is_none() => Some((&*id.name, &availability.unavailable)),
            // TODO
            Stmt::FnDecl { .. } => None,
            Stmt::AliasDecl {
                id, availability, ..
            } => Some((&*id.name, &availability.unavailable)),
        }
        .into_iter()
        .chain({
            if let Stmt::EnumDecl {
                variants,
                availability,
                ..
            } = self
            {
                variants
                    .iter()
                    .map(|(name, _, _)| (&**name, &availability.unavailable))
                    .collect()
            } else {
                vec![]
            }
        })
    }
}

impl fmt::Display for Stmt {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let _span = debug_span!("stmt", discriminant = ?mem::discriminant(self)).entered();

        struct GenericTyHelper<'a>(&'a [String]);

        impl fmt::Display for GenericTyHelper<'_> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                if !self.0.is_empty() {
                    write!(f, "<")?;
                    for generic in self.0 {
                        write!(f, "{generic}, ")?;
                    }
                    for generic in self.0 {
                        write!(f, "{generic}Ownership, ")?;
                    }
                    write!(f, ">")?;
                }
                Ok(())
            }
        }

        struct GenericParamsHelper<'a>(&'a [String]);

        impl fmt::Display for GenericParamsHelper<'_> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                if !self.0.is_empty() {
                    write!(f, "<")?;
                    for generic in self.0 {
                        write!(f, "{generic}: Message, ")?;
                    }
                    for generic in self.0 {
                        write!(f, "{generic}Ownership: Ownership, ")?;
                    }
                    write!(f, ">")?;
                }
                Ok(())
            }
        }

        match self {
            Self::ClassDecl {
                id,
                generics,
                availability,
                superclasses,
                designated_initializers: _,
                derives,
                ownership: _,
            } => {
                let macro_name = if generics.is_empty() {
                    "extern_class"
                } else {
                    "__inner_extern_class"
                };

                writeln!(f, "{macro_name}!(")?;
                writeln!(f, "    {derives}")?;
                if let Some(feature) = id.feature() {
                    writeln!(f, "    #[cfg(feature = \"{feature}\")]")?;
                }
                write!(f, "{availability}")?;
                write!(f, "    pub struct {}", id.name)?;
                if !generics.is_empty() {
                    write!(f, "<")?;
                    for generic in generics {
                        write!(f, "{generic}: Message = Object, ")?;
                    }
                    for generic in generics {
                        write!(f, "{generic}Ownership: Ownership = Shared, ")?;
                    }
                    write!(f, ">")?;
                };
                if generics.is_empty() {
                    writeln!(f, ";")?;
                } else {
                    writeln!(f, " {{")?;
                    for (i, generic) in generics.iter().enumerate() {
                        // Invariant over the generic (for now)
                        writeln!(
                            f,
                            "_inner{i}: PhantomData<*mut ({generic}, {generic}Ownership)>,"
                        )?;
                    }
                    writeln!(f, "notunwindsafe: PhantomData<&'static mut ()>,")?;
                    writeln!(f, "}}")?;
                }

                writeln!(f)?;

                if let Some(feature) = id.feature() {
                    writeln!(f, "    #[cfg(feature = \"{feature}\")]")?;
                }
                writeln!(
                    f,
                    "    unsafe impl{} ClassType for {}{} {{",
                    GenericParamsHelper(generics),
                    id.name,
                    GenericTyHelper(generics),
                )?;
                let (superclass, rest) = superclasses.split_at(1);
                let (superclass, generics) =
                    superclass.get(0).expect("must have a least one superclass");
                if !rest.is_empty() {
                    write!(f, "    #[inherits(")?;
                    let mut iter = rest.iter();
                    // Using generics in here is not technically correct, but
                    // should work for our use-cases.
                    if let Some((superclass, generics)) = iter.next() {
                        write!(
                            f,
                            "{}{}",
                            superclass.path_in_relation_to(id),
                            GenericTyHelper(generics)
                        )?;
                    }
                    for (superclass, generics) in iter {
                        write!(
                            f,
                            ", {}{}",
                            superclass.path_in_relation_to(id),
                            GenericTyHelper(generics)
                        )?;
                    }
                    writeln!(f, ")]")?;
                }
                writeln!(
                    f,
                    "        type Super = {}{};",
                    superclass.path_in_relation_to(id),
                    GenericTyHelper(generics)
                )?;
                writeln!(f, "    }}")?;
                writeln!(f, ");")?;
            }
            Self::Methods {
                cls,
                generics,
                category,
                // TODO: Output `#[deprecated]` only on categories
                availability: _,
                superclasses,
                methods,
                description,
            } => {
                writeln!(f, "extern_methods!(")?;
                if let Some(description) = description {
                    writeln!(f, "    /// {description}")?;
                    if category.name.is_some() {
                        writeln!(f, "    ///")?;
                    }
                }
                if let Some(category_name) = &category.name {
                    writeln!(f, "    /// {category_name}")?;
                }
                if let Some(feature) = cls.feature() {
                    writeln!(f, "    #[cfg(feature = \"{feature}\")]")?;
                }
                writeln!(
                    f,
                    "    unsafe impl{} {}{} {{",
                    GenericParamsHelper(generics),
                    cls.path_in_relation_to(category),
                    GenericTyHelper(generics),
                )?;
                for method in methods {
                    // Use a set to deduplicate features, and to have them in
                    // a consistent order
                    let mut features = BTreeSet::new();
                    method.visit_required_types(|item| {
                        if cls.library == item.library && cls.name == item.name {
                            // The feature is guaranteed enabled if the class
                            // itself is enabled.
                            return;
                        }
                        for (superclass, _) in superclasses {
                            if superclass.library == item.library && superclass.name == item.name {
                                // Same for superclasses.
                                return;
                            }
                        }
                        if let Some(feature) = item.feature() {
                            features.insert(format!("feature = \"{feature}\""));
                        }
                    });
                    match features.len() {
                        0 => {}
                        1 => {
                            writeln!(f, "        #[cfg({})]", features.first().unwrap())?;
                        }
                        _ => {
                            writeln!(
                                f,
                                "        #[cfg(all({}))]",
                                features
                                    .iter()
                                    .map(|s| &**s)
                                    .collect::<Vec<&str>>()
                                    .join(",")
                            )?;
                        }
                    }

                    writeln!(f, "{method}")?;
                }
                writeln!(f, "    }}")?;
                writeln!(f, ");")?;
            }
            Self::ProtocolImpl {
                cls: _,
                generics: _,
                protocol,
                availability: _,
            } if protocol.name == "NSCopying" || protocol.name == "NSMutableCopying" => {
                // TODO
            }
            Self::ProtocolImpl {
                cls,
                generics,
                protocol,
                availability: _,
            } => {
                if let Some(feature) = cls.feature() {
                    writeln!(f, "#[cfg(feature = \"{feature}\")]")?;
                }
                writeln!(
                    f,
                    "unsafe impl{} {} for {}{} {{}}",
                    GenericParamsHelper(generics),
                    protocol.path_in_relation_to(cls),
                    cls.path(),
                    GenericTyHelper(generics),
                )?;
            }
            Self::ProtocolDecl {
                id,
                availability,
                protocols,
                methods,
            } => {
                writeln!(f, "extern_protocol!(")?;
                write!(f, "{availability}")?;

                write!(f, "    pub unsafe trait {}", id.name)?;
                if !protocols.is_empty() {
                    for (i, protocol) in protocols
                        .iter()
                        .filter(|protocol| {
                            protocol.name != "NSCopying" && protocol.name != "NSMutableCopying"
                        })
                        .enumerate()
                    {
                        if i == 0 {
                            write!(f, ": ")?;
                        } else {
                            write!(f, "+ ")?;
                        }
                        write!(f, "{}", protocol.path())?;
                    }
                }
                writeln!(f, " {{")?;

                for method in methods {
                    // Use a set to deduplicate features, and to have them in
                    // a consistent order
                    let mut features = BTreeSet::new();
                    method.visit_required_types(|item| {
                        if let Some(feature) = item.feature() {
                            features.insert(format!("feature = \"{feature}\""));
                        }
                    });
                    match features.len() {
                        0 => {}
                        1 => {
                            writeln!(f, "        #[cfg({})]", features.first().unwrap())?;
                        }
                        _ => {
                            writeln!(
                                f,
                                "        #[cfg(all({}))]",
                                features
                                    .iter()
                                    .map(|s| &**s)
                                    .collect::<Vec<&str>>()
                                    .join(",")
                            )?;
                        }
                    }
                    writeln!(f, "{method}")?;
                }
                writeln!(f, "    }}")?;
                writeln!(f)?;
                writeln!(f, "    unsafe impl ProtocolType for dyn {} {{}}", id.name)?;
                writeln!(f, ");")?;
            }
            Self::StructDecl {
                id,
                encoding_name,
                availability,
                boxable: _,
                fields,
            } => {
                writeln!(f, "extern_struct!(")?;
                if let Some(encoding_name) = encoding_name {
                    writeln!(f, "    #[encoding_name({encoding_name:?})]")?;
                }
                write!(f, "{availability}")?;
                writeln!(f, "    pub struct {} {{", id.name)?;
                for (name, ty) in fields {
                    write!(f, "        ")?;
                    if !name.starts_with('_') {
                        write!(f, "pub ")?;
                    }
                    let name = handle_reserved(name);
                    writeln!(f, "{name}: {ty},")?;
                }
                writeln!(f, "    }}")?;
                writeln!(f, ");")?;
            }
            Self::EnumDecl {
                id,
                availability,
                ty,
                kind,
                variants,
            } => {
                let macro_name = match kind {
                    None => "extern_enum",
                    Some(UnexposedAttr::Enum) => "ns_enum",
                    Some(UnexposedAttr::Options) => "ns_options",
                    Some(UnexposedAttr::ClosedEnum) => "ns_closed_enum",
                    Some(UnexposedAttr::ErrorEnum) => "ns_error_enum",
                    _ => panic!("invalid enum kind"),
                };
                writeln!(f, "{macro_name}!(")?;
                writeln!(f, "    #[underlying({ty})]")?;
                write!(f, "{availability}")?;
                writeln!(
                    f,
                    "    pub enum {} {{",
                    id.name.as_deref().unwrap_or("__anonymous__")
                )?;
                for (name, availability, expr) in variants {
                    write!(f, "{availability}")?;
                    writeln!(f, "        {name} = {expr},")?;
                }
                writeln!(f, "    }}")?;
                writeln!(f, ");")?;
            }
            Self::VarDecl {
                id,
                availability: _,
                ty,
                value: None,
            } => {
                writeln!(f, "extern_static!({}: {ty});", id.name)?;
            }
            Self::VarDecl {
                id,
                availability: _,
                ty,
                value: Some(expr),
            } => {
                writeln!(f, "extern_static!({}: {ty} = {expr});", id.name)?;
            }
            Self::FnDecl {
                id,
                availability,
                arguments,
                result_type,
                body,
                safe,
            } => {
                // Use a set to deduplicate features, and to have them in
                // a consistent order
                let mut features = BTreeSet::new();
                self.visit_required_types(|item| {
                    if let Some(feature) = item.feature() {
                        features.insert(format!("feature = \"{feature}\""));
                    }
                });

                if body.is_some() {
                    writeln!(f, "inline_fn!(")?;
                } else {
                    writeln!(f, "extern_fn!(")?;
                }

                match features.len() {
                    0 => {}
                    1 => {
                        writeln!(f, "    #[cfg({})]", features.first().unwrap())?;
                    }
                    _ => {
                        writeln!(
                            f,
                            "    #[cfg(all({}))]",
                            features
                                .iter()
                                .map(|s| &**s)
                                .collect::<Vec<&str>>()
                                .join(",")
                        )?;
                    }
                }

                let unsafe_ = if *safe { "" } else { " unsafe" };

                write!(f, "{availability}")?;
                write!(f, "    pub{unsafe_} fn {}(", id.name)?;
                for (param, arg_ty) in arguments {
                    let param = handle_reserved(&crate::to_snake_case(param));
                    write!(f, "{param}: {arg_ty},")?;
                }
                write!(f, "){result_type}")?;

                if body.is_some() {
                    writeln!(f, "{{")?;
                    writeln!(f, "        todo!()")?;
                    writeln!(f, "    }}")?;
                } else {
                    writeln!(f, ";")?;
                }

                writeln!(f, ");")?;
            }
            Self::AliasDecl {
                id,
                availability: _,
                ty,
                kind,
            } => {
                match kind {
                    Some(UnexposedAttr::TypedEnum) => {
                        writeln!(f, "typed_enum!(pub type {} = {ty};);", id.name)?;
                    }
                    Some(UnexposedAttr::TypedExtensibleEnum) => {
                        writeln!(f, "typed_extensible_enum!(pub type {} = {ty};);", id.name)?;
                    }
                    None | Some(UnexposedAttr::BridgedTypedef) => {
                        // "bridged" typedefs should just use a normal type
                        // alias.
                        writeln!(f, "pub type {} = {ty};", id.name)?;
                    }
                    kind => panic!("invalid alias kind {kind:?} for {ty:?}"),
                }
            }
        };
        Ok(())
    }
}
