framework = "AppKit"
crate = "objc2-app-kit"
required-crates = ["objc2", "objc2-foundation"]
undesired-default-dependencies = ["objc2-open-gl"] # OpenGL is deprecated
custom-lib-rs = true
macos = "10.0"
maccatalyst = "13.0"
gnustep = true

external.UTType.module = "UniformTypeIdentifiers.UTType"

class.NSFont.bridged-to = "CoreText.CTFont.CTFont"
class.NSFontCollection.bridged-to = "CoreText.CTFontCollection.CTFontCollection"
class.NSMutableFontCollection.bridged-to = "CoreText.CTFontCollection.CTMutableFontCollection"
class.NSFontDescriptor.bridged-to = "CoreText.CTFontDescriptor.CTFontDescriptor"
class.NSGlyphInfo.bridged-to = "CoreText.CTGlyphInfo.CTGlyphInfo"

# Unsure if `data` is really bound to 5, and if it's mutable or immutable.
fn.NSDrawBitmap.arguments.10.bounds = "unsafe"

# Make the `count` use `&mut NSInteger`.
class.NSView.methods."getRectsExposedDuringLiveResize:count:".arguments.1.bounds = "single"

# `objc_ownership` in .apinotes
class.NSBundle.methods."loadNibNamed:owner:topLevelObjects:".skipped = true
class.NSNib.methods."instantiateWithOwner:topLevelObjects:".skipped = true

# Return type `oneway void`
class.NSPasteboard.methods.releaseGlobally.skipped = true
class.NSView.methods.releaseGState.skipped = true
# + some more in IMServicePlugIn.framework

# Uses `NS_SWIFT_UI_ACTOR` on a static, which is hard to support.
#
# Will have to be a method that takes `MainThreadMarker`.
static.NSApp.skipped = true

# These protocol impls would return the wrong types
class.NSTextStorage.skipped-protocols = ["NSCopying", "NSMutableCopying"]

# Set counterparts
class.NSFontCollection.counterpart.mutable-subclass = "AppKit.NSFontCollection.NSMutableFontCollection"
class.NSMutableFontCollection.counterpart.immutable-superclass = "AppKit.NSFontCollection.NSFontCollection"
class.NSParagraphStyle.counterpart.mutable-subclass = "AppKit.NSParagraphStyle.NSMutableParagraphStyle"
class.NSMutableParagraphStyle.counterpart.immutable-superclass = "AppKit.NSParagraphStyle.NSParagraphStyle"

# Typedef that uses a generic from a class
typedef.NSCollectionViewDiffableDataSourceItemProvider.skipped = true
class.NSCollectionViewDiffableDataSource.methods."initWithCollectionView:itemProvider:".skipped = true

# Requires `MainThreadOnly`, which I'm not sure is a good idea here?
class.NSCollectionViewDiffableDataSource.skipped-protocols = ["NSCollectionViewDataSource"]
class.NSManagedObjectContext.skipped-protocols = ["NSEditor", "NSEditorRegistration"]

# Both protocols and classes
protocol.NSTextAttachmentCell.renamed = "NSTextAttachmentCellProtocol"
protocol.NSAccessibilityElement.renamed = "NSAccessibilityElementProtocol"

# Both property and method
class.NSDocument.methods."setDisplayName:".skipped = true

# References static in `const`, which isn't yet in MSRV.
const.NSOKButton.skipped = true
const.NSCancelButton.skipped = true
const.NSFileHandlingPanelCancelButton.skipped = true
const.NSFileHandlingPanelOKButton.skipped = true

# These subclass a generic struct, and hence the type parameter defaults to
# `AnyObject`, which is not PartialEq, Eq nor Hash.
class.NSLayoutXAxisAnchor.derives = "Debug"
class.NSLayoutYAxisAnchor.derives = "Debug"
class.NSLayoutDimension.derives = "Debug"

# Different definitions depending on target.
const.NSImageResizingModeTile.skipped = true
const.NSImageResizingModeStretch.skipped = true
const.NSTextAlignmentCenter.skipped = true
const.NSTextAlignmentRight.skipped = true

# Uses constants from IOKit
enum.NSPointingDeviceType.use-value = true
enum.NSEventButtonMask.use-value = true
enum.NSEventSubtype.use-value = true
static.NSNormalWindowLevel.use-value = true
static.NSFloatingWindowLevel.use-value = true
static.NSSubmenuWindowLevel.use-value = true
static.NSTornOffMenuWindowLevel.use-value = true
static.NSMainMenuWindowLevel.use-value = true
static.NSStatusWindowLevel.use-value = true
static.NSModalPanelWindowLevel.use-value = true
static.NSPopUpMenuWindowLevel.use-value = true
static.NSScreenSaverWindowLevel.use-value = true
static.NSDockWindowLevel.use-value = true

# Uses a pointer to SEL, which doesn't implement Encode yet
protocol.NSMenuDelegate.methods."menuHasKeyEquivalent:forEvent:target:action:".skipped = true

# Duplicated method
class.NSSlider.methods.isVertical.skipped = true
class.NSSliderCell.methods.isVertical.skipped = true
class.NSGestureRecognizer.methods.state.skipped = true

# Needs `Symbols` framework
class.NSImageView.categories.NSSymbolEffect.skipped = true

# Needs IconRef from HIServices / Carbon
class.NSImage.methods."initWithIconRef:".skipped = true

# QTKit
class.NSMovie.methods."initWithMovie:".skipped = true
class.NSMovie.methods.QTMovie.skipped = true

# Needs `cpu_type_t` from `<mach/machine.h>`.
class.NSWorkspaceOpenConfiguration.methods.architecture.skipped = true
class.NSWorkspaceOpenConfiguration.methods."setArchitecture:".skipped = true

# Unsure whether we really want AppKit to depend on Intents
protocol.NSApplicationDelegate.methods."application:handlerForIntent:".skipped = true

# We don't really want objc2-app-kit to depend on objc2-core-text
class.NSAdaptiveImageGlyph.skipped-protocols = ["CTAdaptiveImageProviding"]

# header-translator crashes when trying to figure out the return type of this.
class.NSTextView.methods."quickLookPreviewableItemsInRanges:".skipped = true

# Deprecated.
const.NSImageRepRegistryChangedNotification.skipped = true

# Custom-defined.
fn.NSApplicationMain.renamed = "__main"

###
### Main Thread Overrides
###

# Most things in AppKit is marked as MainThreadOnly automatically, but there are a few things we have to tweak
class.NSColorPicker.main-thread-only = true
class.NSController.main-thread-only = true
class.NSObjectController.main-thread-only = true
class.NSArrayController.main-thread-only = true
class.NSDictionaryController.main-thread-only = true
class.NSTreeController.main-thread-only = true
class.NSUserDefaultsController.main-thread-only = true
class.NSFontManager.main-thread-only = true
class.NSMenu.main-thread-only = true
class.NSMenuItem.main-thread-only = true
class.NSWindowTabGroup.main-thread-only = true
class.NSTextInputContext.main-thread-only = true

# Most methods on these require MainThreadMarker anyhow
protocol.NSDraggingInfo.requires-mainthreadonly = true
protocol.NSBrowserDelegate.requires-mainthreadonly = true
protocol.NSSplitViewDelegate.requires-mainthreadonly = true

# Accesses the shared application, and hence is main thread only (even though not marked so in Swift).
class.NSScreen.main-thread-only = true

# Documented as "Main Thread Only".
# > generally thread safe, although operations on views such as creating,
# > resizing, and moving should happen on the main thread.
# <https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaFundamentals/AddingBehaviortoaCocoaProgram/AddingBehaviorCocoa.html#//apple_ref/doc/uid/TP40002974-CH5-SW47>
#
# > If you want to use a thread to draw to a view, bracket all drawing code
# > between the lockFocusIfCanDraw and unlockFocus methods of NSView.
# <https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-123351-BBCFIIEB>
class.NSView.main-thread-only = true

# Documented as "Main Thread Only", but:
# > Thread safe in that you can create and manage them on a secondary
# > thread.
# <https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaFundamentals/AddingBehaviortoaCocoaProgram/AddingBehaviorCocoa.html#//apple_ref/doc/uid/TP40002974-CH5-SW47>
# <https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-123364>
#
# So could in theory be `Send`, and perhaps also `Sync` - but we would
# like interior mutability on windows, since that's just much easier, and
# in that case, they can't be!
class.NSWindow.main-thread-only = true

# TODO: This should probably be MainThreadOnly, or maybe +Send/Sync?
# class.NSAppearance.main-thread-only = true

# Documented Thread-Unsafe, but:
# > One thread can create an NSImage object, draw to the image buffer,
# > and pass it off to the main thread for drawing. The underlying image
# > cache is shared among all threads.
# <https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-126728>
#
# So really only unsafe to mutate on several threads.
# class.NSImage.sendable = false

# Documented as "Thread-Unsafe"
# class.NSResponder.sendable = false

###
### Fixing pointer bounds.
###

class.NSApplication.methods."searchString:inUserInterfaceItemString:searchRange:foundRange:".arguments.3.bounds = "single"

fn.NSApplicationMain.arguments.1.bounds.counted-by = "argc"

class.NSBezierPath.methods."drawPackedGlyphs:atPoint:".arguments.0.bounds = "null-terminated"
class.NSBezierPath.methods."getLineDash:count:phase:".arguments.0.bounds = "unsafe" # call method twice to get size of this
class.NSBezierPath.methods."getLineDash:count:phase:".arguments.1.bounds = "single"
class.NSBezierPath.methods."getLineDash:count:phase:".arguments.2.bounds = "single"
class.NSBezierPath.methods."setLineDash:count:phase:".arguments.0.bounds.counted-by = "count"
class.NSBezierPath.methods."appendBezierPathWithCGGlyphs:count:inFont:".arguments.0.bounds.counted-by = "count"
class.NSBezierPath.methods."appendBezierPathWithGlyphs:count:inFont:".arguments.0.bounds.counted-by = "count"
class.NSBezierPath.methods."appendBezierPathWithPackedGlyphs:".arguments.0.bounds = "null-terminated"

# Bitmap data size is a bit more complex, so let's mark it unsafe for now.
class.NSBitmapImageRep.methods."initWithBitmapDataPlanes:pixelsWide:pixelsHigh:bitsPerSample:samplesPerPixel:hasAlpha:isPlanar:colorSpaceName:bytesPerRow:bitsPerPixel:".arguments.0.bounds = "unsafe"
class.NSBitmapImageRep.methods."initWithBitmapDataPlanes:pixelsWide:pixelsHigh:bitsPerSample:samplesPerPixel:hasAlpha:isPlanar:colorSpaceName:bitmapFormat:bytesPerRow:bitsPerPixel:".arguments.0.bounds = "unsafe"
class.NSBitmapImageRep.methods.bitmapData.return.bounds = "unsafe"
class.NSBitmapImageRep.methods."getBitmapDataPlanes:".arguments.0.bounds = "unsafe"
class.NSBitmapImageRep.methods."getCompression:factor:".arguments.0.bounds = "single"
class.NSBitmapImageRep.methods."getCompression:factor:".arguments.1.bounds = "single"
class.NSBitmapImageRep.methods."getTIFFCompressionTypes:count:".arguments.0.bounds = "single" # Inner array counted by `num_types`
class.NSBitmapImageRep.methods."getTIFFCompressionTypes:count:".arguments.1.bounds = "single"

class.NSBrowser.methods."getRow:column:forPoint:".arguments.0.bounds = "single"
class.NSBrowser.methods."getRow:column:forPoint:".arguments.1.bounds = "single"
protocol.NSBrowserDelegate.methods."browser:validateDrop:proposedRow:column:dropOperation:".arguments.2.bounds = "single"
protocol.NSBrowserDelegate.methods."browser:validateDrop:proposedRow:column:dropOperation:".arguments.3.bounds = "single"
protocol.NSBrowserDelegate.methods."browser:validateDrop:proposedRow:column:dropOperation:".arguments.4.bounds = "single"

class.NSBundle.methods."loadNibFile:externalNameTable:withZone:".arguments.2.written = false
class.NSBundle.methods."loadNibFile:externalNameTable:withZone:".arguments.2.bounds = "single"

class.NSButton.methods."getPeriodicDelay:interval:".arguments.0.bounds = "single"
class.NSButton.methods."getPeriodicDelay:interval:".arguments.1.bounds = "single"
class.NSButtonCell.methods."getPeriodicDelay:interval:".arguments.0.bounds = "single"
class.NSButtonCell.methods."getPeriodicDelay:interval:".arguments.1.bounds = "single"

class.NSCell.methods."getPeriodicDelay:interval:".arguments.0.bounds = "single"
class.NSCell.methods."getPeriodicDelay:interval:".arguments.1.bounds = "single"

protocol.NSCollectionViewDelegate.methods."collectionView:validateDrop:proposedIndexPath:dropOperation:".arguments.3.bounds = "single"
protocol.NSCollectionViewDelegate.methods."collectionView:validateDrop:proposedIndex:dropOperation:".arguments.2.bounds = "single"
protocol.NSCollectionViewDelegate.methods."collectionView:validateDrop:proposedIndex:dropOperation:".arguments.3.bounds = "single"

class.NSColor.methods."colorWithColorSpace:components:count:".arguments.1.bounds.counted-by = "number_of_components"
class.NSColor.methods."getRed:green:blue:alpha:".arguments.0.bounds = "single"
class.NSColor.methods."getRed:green:blue:alpha:".arguments.1.bounds = "single"
class.NSColor.methods."getRed:green:blue:alpha:".arguments.2.bounds = "single"
class.NSColor.methods."getRed:green:blue:alpha:".arguments.3.bounds = "single"
class.NSColor.methods."getHue:saturation:brightness:alpha:".arguments.0.bounds = "single"
class.NSColor.methods."getHue:saturation:brightness:alpha:".arguments.1.bounds = "single"
class.NSColor.methods."getHue:saturation:brightness:alpha:".arguments.2.bounds = "single"
class.NSColor.methods."getHue:saturation:brightness:alpha:".arguments.3.bounds = "single"
class.NSColor.methods."getWhite:alpha:".arguments.0.bounds = "single"
class.NSColor.methods."getWhite:alpha:".arguments.1.bounds = "single"
class.NSColor.methods."getCyan:magenta:yellow:black:alpha:".arguments.0.bounds = "single"
class.NSColor.methods."getCyan:magenta:yellow:black:alpha:".arguments.1.bounds = "single"
class.NSColor.methods."getCyan:magenta:yellow:black:alpha:".arguments.2.bounds = "single"
class.NSColor.methods."getCyan:magenta:yellow:black:alpha:".arguments.3.bounds = "single"
class.NSColor.methods."getCyan:magenta:yellow:black:alpha:".arguments.4.bounds = "single"
class.NSColor.methods."getComponents:".arguments.0.bounds.counted-by = "self.numberOfComponents()"

protocol.NSControlTextEditingDelegate.methods."control:textView:completions:forPartialWordRange:indexOfSelectedItem:".arguments.4.bounds = "single"

protocol.NSDatePickerCellDelegate.methods."datePickerCell:validateProposedDateValue:timeInterval:".arguments.2.bounds = "single"

class.NSFont.methods."fontWithName:matrix:".arguments.1.bounds.counted-by = "6"
class.NSFont.methods.matrix.return.bounds.counted-by = "6"
class.NSFont.methods."getBoundingRects:forCGGlyphs:count:".arguments.1.bounds.counted-by = "glyph_count"
class.NSFont.methods."getAdvancements:forCGGlyphs:count:".arguments.1.bounds.counted-by = "glyph_count"
class.NSFont.methods."getBoundingRects:forGlyphs:count:".arguments.1.bounds.counted-by = "glyph_count"
class.NSFont.methods."getAdvancements:forGlyphs:count:".arguments.1.bounds.counted-by = "glyph_count"
fn.NSConvertGlyphsToPackedGlyphs.arguments.0.bounds.counted-by = "count"
fn.NSConvertGlyphsToPackedGlyphs.arguments.3.bounds.counted-by = "(4 * count) + 1"

class.NSGradient.methods."initWithColors:atLocations:colorSpace:".arguments.1.bounds.counted-by = "color_array.length()"
class.NSGradient.methods."getColor:location:atIndex:".arguments.1.bounds = "single"

# NSGraphics
fn.NSBestDepth.arguments.4.bounds = "single"
fn.NSAvailableWindowDepths.return.bounds = "null-terminated"
fn.NSRectFillList.arguments.0.bounds.counted-by = "count"
fn.NSRectFillListWithGrays.arguments.0.bounds.counted-by = "num"
fn.NSRectFillListWithGrays.arguments.1.bounds.counted-by = "num"
fn.NSRectFillListWithColors.arguments.0.bounds.counted-by = "num"
fn.NSRectFillListWithColors.arguments.1.bounds.counted-by = "num"
fn.NSRectFillListUsingOperation.arguments.0.bounds.counted-by = "count"
fn.NSRectFillListWithColorsUsingOperation.arguments.0.bounds.counted-by = "num"
fn.NSRectFillListWithColorsUsingOperation.arguments.1.bounds.counted-by = "num"
fn.NSRectClipList.arguments.0.bounds.counted-by = "count"
fn.NSDrawTiledRects.arguments.2.bounds.counted-by = "count"
fn.NSDrawTiledRects.arguments.3.bounds.counted-by = "count"
fn.NSGetWindowServerMemory.arguments.1.bounds = "single"
fn.NSGetWindowServerMemory.arguments.2.bounds = "single"
fn.NSDrawColorTiledRects.arguments.2.bounds.counted-by = "count"
fn.NSDrawColorTiledRects.arguments.3.bounds.counted-by = "count"
fn.NSCountWindows.arguments.0.bounds = "single"
fn.NSCountWindowsForContext.arguments.1.bounds = "single"

protocol.NSGlyphStorage.methods."insertGlyphs:length:forStartingGlyphAtIndex:characterIndex:".arguments.0.bounds.counted-by = "length"
class.NSGlyphGenerator.methods."generateGlyphsForGlyphStorage:desiredNumberOfCharacters:glyphIndex:characterIndex:".arguments.2.bounds = "single"
class.NSGlyphGenerator.methods."generateGlyphsForGlyphStorage:desiredNumberOfCharacters:glyphIndex:characterIndex:".arguments.3.bounds = "unsafe" # Unclear from docs

class.NSImageRep.methods."CGImageForProposedRect:context:hints:".arguments.0.bounds = "single"
class.NSImage.methods."CGImageForProposedRect:context:hints:".arguments.0.bounds = "single"

# TODO: class.NSLayoutManager.methods.*.bounds = "..."

class.NSMatrix.methods."getNumberOfRows:columns:".arguments.0.bounds = "single"
class.NSMatrix.methods."getNumberOfRows:columns:".arguments.1.bounds = "single"
class.NSMatrix.methods."getRow:column:ofCell:".arguments.0.bounds = "single"
class.NSMatrix.methods."getRow:column:ofCell:".arguments.1.bounds = "single"
class.NSMatrix.methods."getRow:column:forPoint:".arguments.0.bounds = "single"
class.NSMatrix.methods."getRow:column:forPoint:".arguments.1.bounds = "single"

class.NSMenu.methods.menuZone.return.bounds = "single"
class.NSMenu.methods."setMenuZone:".arguments.0.written = false
class.NSMenu.methods."setMenuZone:".arguments.0.bounds = "single"

class.NSView.methods."getRectsBeingDrawn:count:".arguments.0.bounds = "single" # inner counted by `*count`
class.NSView.methods."getRectsBeingDrawn:count:".arguments.1.bounds = "single"
class.NSView.methods."adjustPageWidthNew:left:right:limit:".arguments.0.bounds = "single"
class.NSView.methods."adjustPageHeightNew:top:bottom:limit:".arguments.0.bounds = "single"

class.NSWorkspace.methods."getFileSystemInfoForPath:isRemovable:isWritable:isUnmountable:description:type:".arguments.1.bounds = "single"
class.NSWorkspace.methods."getFileSystemInfoForPath:isRemovable:isWritable:isUnmountable:description:type:".arguments.2.bounds = "single"
class.NSWorkspace.methods."getFileSystemInfoForPath:isRemovable:isWritable:isUnmountable:description:type:".arguments.3.bounds = "single"
class.NSWorkspace.methods."performFileOperation:source:destination:files:tag:".arguments.4.bounds = "single"

fn.NSOpenGLGetOption.arguments.1.bounds = "single"
fn.NSOpenGLGetVersion.arguments.0.bounds = "single"
fn.NSOpenGLGetVersion.arguments.1.bounds = "single"
class.NSOpenGLPixelFormat.methods."initWithAttributes:".arguments.0.bounds = "null-terminated"
class.NSOpenGLPixelFormat.methods."getValues:forAttribute:forVirtualScreen:".arguments.0.bounds = "unsafe" # depends on attribute
class.NSOpenGLContext.methods."setValues:forParameter:".arguments.0.bounds = "unsafe" # depends on parameter
class.NSOpenGLContext.methods."getValues:forParameter:".arguments.0.bounds = "unsafe" # depends on parameter
class.NSOpenGLLayer.methods."canDrawInOpenGLContext:pixelFormat:forLayerTime:displayTime:".arguments.3.bounds = "single"
class.NSOpenGLLayer.methods."drawInOpenGLContext:pixelFormat:forLayerTime:displayTime:".arguments.3.bounds = "single"

protocol.NSSharingServiceDelegate.methods."sharingService:transitionImageForShareItem:contentRect:".arguments.2.bounds = "single"
protocol.NSSharingServiceDelegate.methods."sharingService:sourceWindowForShareItems:sharingContentScope:".arguments.2.bounds = "single"
protocol.NSSharingServiceDelegate.methods."anchoringViewForSharingService:showRelativeToRect:preferredEdge:".arguments.1.bounds = "single"
protocol.NSSharingServiceDelegate.methods."anchoringViewForSharingService:showRelativeToRect:preferredEdge:".arguments.2.bounds = "single"

class.NSSpellChecker.methods."checkSpellingOfString:startingAt:language:wrap:inSpellDocumentWithTag:wordCount:".arguments.5.bounds = "single"
class.NSSpellChecker.methods."checkString:range:types:options:inSpellDocumentWithTag:orthography:wordCount:".arguments.6.bounds = "single"

class.NSScreen.methods.supportedWindowDepths.return.bounds = "null-terminated"

protocol.NSTextFinderClient.methods."stringAtIndex:effectiveRange:endsWithSearchBoundary:".arguments.2.bounds = "single"
class.NSTextContainer.methods."lineFragmentRectForProposedRect:atIndex:writingDirection:remainingRect:".arguments.3.bounds = "single"

class.NSTextView.methods."completionsForPartialWordRange:indexOfSelectedItem:".arguments.1.bounds = "single"
protocol.NSTextViewDelegate.methods."textView:completions:forPartialWordRange:indexOfSelectedItem:".arguments.3.bounds = "single"
protocol.NSTextViewDelegate.methods."textView:willCheckTextInRange:options:types:".arguments.3.bounds = "single"

protocol.NSTokenFieldCellDelegate.methods."tokenFieldCell:completionsForSubstring:indexOfToken:indexOfSelectedItem:".arguments.3.bounds = "single"
protocol.NSTokenFieldDelegate.methods."tokenField:completionsForSubstring:indexOfToken:indexOfSelectedItem:".arguments.3.bounds = "single"

class.NSTypesetter.methods."layoutGlyphsInLayoutManager:startingAtGlyphIndex:maxNumberOfLineFragments:nextGlyphIndex:".arguments.3.bounds = "single"
class.NSTypesetter.methods."printingAdjustmentInLayoutManager:forNominallySpacedGlyphRange:packedGlyphs:count:".arguments.2.bounds.counted-by = "packed_glyphs_count"
class.NSTypesetter.methods."willSetLineFragmentRect:forGlyphRange:usedRect:baselineOffset:".arguments.1.bounds = "single"
class.NSTypesetter.methods."willSetLineFragmentRect:forGlyphRange:usedRect:baselineOffset:".arguments.2.bounds = "single"
class.NSTypesetter.methods."willSetLineFragmentRect:forGlyphRange:usedRect:baselineOffset:".arguments.3.bounds = "single"
class.NSTypesetter.methods."setLocation:withAdvancements:forStartOfGlyphRange:".arguments.1.bounds = "unsafe" # Unclear?
class.NSTypesetter.methods."setBidiLevels:forGlyphRange:".arguments.0.bounds.counted-by = "range.length"
class.NSTypesetter.methods."getGlyphsInRange:glyphs:characterIndexes:glyphInscriptions:elasticBits:bidiLevels:".arguments.1.bounds.counted-by = "glyphs_range.length"
class.NSTypesetter.methods."getGlyphsInRange:glyphs:characterIndexes:glyphInscriptions:elasticBits:bidiLevels:".arguments.2.bounds = "unsafe" # Unclear
class.NSTypesetter.methods."getGlyphsInRange:glyphs:characterIndexes:glyphInscriptions:elasticBits:bidiLevels:".arguments.3.bounds = "unsafe" # Unclear
class.NSTypesetter.methods."getGlyphsInRange:glyphs:characterIndexes:glyphInscriptions:elasticBits:bidiLevels:".arguments.4.bounds = "unsafe" # Unclear
class.NSTypesetter.methods."getGlyphsInRange:glyphs:characterIndexes:glyphInscriptions:elasticBits:bidiLevels:".arguments.5.bounds = "unsafe" # Unclear
class.NSTypesetter.methods."substituteGlyphsInRange:withGlyphs:".arguments.1.bounds.counted-by = "glyph_range.length"
class.NSATSTypesetter.methods."layoutParagraphAtPoint:".arguments.0.bounds = "single"
class.NSATSTypesetter.methods."getLineFragmentRect:usedRect:forParagraphSeparatorGlyphRange:atProposedOrigin:".arguments.0.bounds = "single"
class.NSATSTypesetter.methods."getLineFragmentRect:usedRect:forParagraphSeparatorGlyphRange:atProposedOrigin:".arguments.1.bounds = "single"
class.NSATSTypesetter.methods."willSetLineFragmentRect:forGlyphRange:usedRect:baselineOffset:".arguments.0.bounds = "single"
class.NSATSTypesetter.methods."willSetLineFragmentRect:forGlyphRange:usedRect:baselineOffset:".arguments.2.bounds = "single"
class.NSATSTypesetter.methods."willSetLineFragmentRect:forGlyphRange:usedRect:baselineOffset:".arguments.3.bounds = "single"
class.NSATSTypesetter.methods."getGlyphsInRange:glyphs:characterIndexes:glyphInscriptions:elasticBits:".arguments.1.bounds.counted-by = "glyphs_range.length"
class.NSATSTypesetter.methods."getGlyphsInRange:glyphs:characterIndexes:glyphInscriptions:elasticBits:".arguments.2.bounds = "unsafe" # Unclear
class.NSATSTypesetter.methods."getGlyphsInRange:glyphs:characterIndexes:glyphInscriptions:elasticBits:".arguments.3.bounds = "unsafe" # Unclear
class.NSATSTypesetter.methods."getGlyphsInRange:glyphs:characterIndexes:glyphInscriptions:elasticBits:".arguments.4.bounds = "unsafe" # Unclear

###
### Safety
###

# SAFETY: Apart from a few things like `-[NSWindow setReleasedWhenClosed:]`
# and `-[Xyz setTarget:]`, AppKit methods are generally well-behaved.
#
# AppKit is huge though, so I (madsmtm) have only skimmed it while reviewing.
unsafe-default-safety.documentation-is-reviewed = true
# AppKit is internally bounds-checked.
unsafe-default-safety.bounds-checked-internally = true

# Any modification of either the target or the action has to remain `unsafe`,
# as there's no way to guarantee that the action method is safe and of the
# correct type, and no way to verify that this property also holds if the
# event bubbles up.
#
# This unsafety of `Sel`+`AnyObject` is handled in `header-translator`.
# Verify with: `rg "pub fn setTarget\("`.
#
# class.NSMenuItem.methods."setTarget:".unsafe = true
# class.NSMenuItem.methods."setAction:".unsafe = true

# SAFETY: These methods taking `(id) sender` are safe, the sender is part of
# the target/action scheme to allow user code that overrides these to read the
# sender, but the system itself (probably) do not inspect the sender.
class.NSApplication.methods."hide:".unsafe = false
class.NSApplication.methods."unhide:".unsafe = false
class.NSApplication.methods."hideOtherApplications:".unsafe = false
class.NSApplication.methods."unhideAllApplications:".unsafe = false
class.NSApplication.methods."stop:".unsafe = false
class.NSApplication.methods."terminate:".unsafe = false
class.NSApplication.methods."orderFrontCharacterPalette:".unsafe = false
class.NSApplication.methods."arrangeInFront:".unsafe = false
class.NSApplication.methods."miniaturizeAll:".unsafe = false
class.NSApplication.methods."orderFrontStandardAboutPanel:".unsafe = false
class.NSWindow.methods."miniaturize:".unsafe = false
class.NSWindow.methods."deminiaturize:".unsafe = false
class.NSWindow.methods."zoom:".unsafe = false
class.NSWindow.methods."makeKeyAndOrderFront:".unsafe = false
class.NSWindow.methods."orderFront:".unsafe = false
class.NSWindow.methods."orderBack:".unsafe = false
class.NSWindow.methods."orderOut:".unsafe = false
class.NSWindow.methods."performClose:".unsafe = false
class.NSWindow.methods."performMiniaturize:".unsafe = false
class.NSWindow.methods."performZoom:".unsafe = false
class.NSWindow.methods."print:".unsafe = false
class.NSWindow.methods."toggleFullScreen:".unsafe = false
class.NSWindow.methods."selectNextKeyView:".unsafe = false
class.NSWindow.methods."selectPreviousKeyView:".unsafe = false
class.NSWindow.methods."toggleToolbarShown:".unsafe = false
class.NSWindow.methods."runToolbarCustomizationPalette:".unsafe = false
class.NSWindow.methods."selectNextTab:".unsafe = false
class.NSWindow.methods."selectPreviousTab:".unsafe = false
class.NSWindow.methods."moveTabToNewWindow:".unsafe = false
class.NSWindow.methods."mergeAllWindows:".unsafe = false
class.NSWindow.methods."toggleTabBar:".unsafe = false
class.NSWindow.methods."toggleTabOverview:".unsafe = false
# TODO: Add `NSResponder`, `NSView` etc. methods here as well?

# SAFETY: Re-entrancy here is safe, just very confusing.
# class.NSApplication.methods.run.unsafe = false

# NSWindow initializers are not safe, since by default, windows are released
# when closed, which means they are over-released unless you leak the window.
# As such, it is critical to memory safety that the user calls
# `window.setReleasedWhenClosed(false)` right after creating the window.
class.NSWindow.methods."setReleasedWhenClosed:".unsafe = true
class.NSWindow.methods.init.unsafe = true
class.NSWindow.methods.new.unsafe = true
class.NSWindow.methods."initWithContentRect:styleMask:backing:defer:".unsafe = true
class.NSWindow.methods."initWithContentRect:styleMask:backing:defer:screen:".unsafe = true
class.NSWindow.methods."initWithCoder:".unsafe = true
class.NSWindow.methods."initWithWindowRef:".unsafe = true

# SAFETY: The controller sets `releasedWhenClosed` to false.
class.NSWindow.methods."windowWithContentViewController:".unsafe = false

# SAFETY: NSPanel defaults to having `releasedWhenClosed` be false.
class.NSPanel.methods."initWithContentRect:styleMask:backing:defer:".unsafe = false
class.NSPanel.methods."initWithContentRect:styleMask:backing:defer:screen:".unsafe = false

# Closing the window is safe.
# class.NSWindow.methods.close.unsafe = false

# This changes the threading which -[NSView drawRect:] is called on, which
# is UB if done on a view that doesn't support this.
class.NSView.methods."setCanDrawConcurrently:".unsafe = true
class.NSWindow.methods."setAllowsConcurrentViewDrawing:".unsafe = true

# TODO(breaking): Might need to be unsafe, if this is truly unretained?
class.NSView.methods.window.unsafe = false

# Documentation says that you shouldn't create cycles (though unsure if UB?).
class.NSWindow.methods."addChildWindow:ordered:".unsafe = true
class.NSWindow.methods."setParentWindow:".unsafe = true
# NSView's `subviews` property / `addSubview:` etc. does this automatically.

# May send the animation and delegate to another thread (?)
class.NSAnimation.methods."setAnimationBlockingMode:".unsafe = true

# May not be safe?
class.NSProgressIndicator.methods."setUsesThreadedAnimation:".unsafe = true

# Block should be marked as NS_SWIFT_SENDABLE
class.NSColorSampler.methods."showSamplerWithSelectionHandler:".unsafe = true

# SAFETY: Setting `stronglyReferencesItems` to `false` breaks lifetime safety.
#
# This is the default for applications linked on macOS 10.12, but that's
# Rust's minimum supported macOS version, so that's fine.
class.NSOutlineView.methods."setStronglyReferencesItems:".unsafe = true

# These crash, should probably be marked `NS_UNAVAILABLE` in the header.
class.NSStatusBar.methods.new.skipped = true
class.NSStatusBar.methods.init.skipped = true

# Incorrectly overwritten, breaks type-safety.
class.NSTableView.methods.dataSource.unsafe = true
class.NSTableView.methods."setDataSource:".unsafe = true
class.NSTableView.methods.delegate.unsafe = true
class.NSTableView.methods."setDelegate:".unsafe = true
class.NSOutlineView.methods.dataSource.unsafe = true
class.NSOutlineView.methods."setDataSource:".unsafe = true
class.NSOutlineView.methods.delegate.unsafe = true
class.NSOutlineView.methods."setDelegate:".unsafe = true
class.NSTokenField.methods."setDelegate:".unsafe = true
class.NSComboBox.methods."setDelegate:".unsafe = true
class.NSSearchField.methods."setDelegate:".unsafe = true
class.NSTextField.methods."setDelegate:".unsafe = true
class.NSTextContentStorage.methods."setDelegate:".unsafe = true
class.NSTextContentManager.methods."setDelegate:".unsafe = true
class.NSSavePanel.methods.delegate.unsafe = true
class.NSSavePanel.methods."setDelegate:".unsafe = true
class.NSWindow.methods.delegate.unsafe = true
class.NSWindow.methods."setDelegate:".unsafe = true
class.NSComboButton.methods."setMenu:".unsafe = true
class.NSResponder.methods."setMenu:".unsafe = true
