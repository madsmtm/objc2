framework = "CoreFoundation"
crate = "objc2-core-foundation"
required-crates = []
custom-lib-rs = true
macos = "10.0"
maccatalyst = "13.0"
ios = "2.0"
tvos = "9.0"
watchos = "2.0"
visionos = "1.0"
gnustep = true

## Generic types
typedef.CFArrayRef.generics = ["T"]
typedef.CFBagRef.generics = ["T"]
typedef.CFBinaryHeapRef.generics = ["T"]
typedef.CFDictionaryRef.generics = ["K", "V"]
typedef.CFSetRef.generics = ["T"]
typedef.CFMutableArrayRef.generics = ["T"]
typedef.CFMutableBagRef.generics = ["T"]
typedef.CFMutableDictionaryRef.generics = ["K", "V"]
typedef.CFMutableSetRef.generics = ["T"]
# Not CFTreeRef

# Uses variadics
fn.CFStringCreateWithFormatAndArguments.skipped = true
fn.CFStringCreateStringWithValidatedFormatAndArguments.skipped = true
fn.CFStringAppendFormatAndArguments.skipped = true

# Name clash with containing module
enum.__CFByteOrder.skipped = true

# Needs FSRef from CoreServices, but CoreServices depends on CoreFoundation
# so we don't generate these to avoid a cyclic dependency.
fn.CFURLCreateFromFSRef.skipped = true
fn.CFURLGetFSRef.skipped = true

# Needs acl_t, which is not exposed by libc
fn.CFFileSecurityCopyAccessControlList.skipped = true
fn.CFFileSecuritySetAccessControlList.skipped = true

# Different definition depending on pointer width
typedef.CGFloat.skipped = true

# Custom definitions for slightly better docs now
struct.CGPoint.skipped = true
struct.CGSize.skipped = true
struct.CGRect.skipped = true

# Custom definition because it's special
typedef.CFTypeRef.skipped = true

# Implementation details
fn.__CFRangeMake.skipped = true
fn.__CFStringMakeConstantString.skipped = true

# Differs based on architecture
typedef.CFBundleRefNum.skipped = true
typedef.CFTypeID.skipped = true
typedef.CFOptionFlags.skipped = true
typedef.CFHashCode.skipped = true
typedef.CFIndex.skipped = true

# Custom-defined since they require manual handling.
# Use `CFRetained` to access these.
fn.CFAutorelease.skipped = true
fn.CFRetain.skipped = true
fn.CFRelease.skipped = true
fn.CFMakeCollectable.skipped = true # Simply returns the argument on macOS 10.12 or later

# Dependent on target endianness
fn.CFSwapInt16.skipped = true
fn.CFSwapInt32.skipped = true
fn.CFSwapInt64.skipped = true
fn.CFByteOrderGetCurrent.skipped = true
fn.CFSwapInt16BigToHost.skipped = true
fn.CFSwapInt32BigToHost.skipped = true
fn.CFSwapInt64BigToHost.skipped = true
fn.CFSwapInt16HostToBig.skipped = true
fn.CFSwapInt32HostToBig.skipped = true
fn.CFSwapInt64HostToBig.skipped = true
fn.CFSwapInt16LittleToHost.skipped = true
fn.CFSwapInt32LittleToHost.skipped = true
fn.CFSwapInt64LittleToHost.skipped = true
fn.CFSwapInt16HostToLittle.skipped = true
fn.CFSwapInt32HostToLittle.skipped = true
fn.CFSwapInt64HostToLittle.skipped = true
fn.CFConvertFloat32HostToSwapped.skipped = true
fn.CFConvertFloat32SwappedToHost.skipped = true
fn.CFConvertFloat64HostToSwapped.skipped = true
fn.CFConvertFloat64SwappedToHost.skipped = true
fn.CFConvertFloatHostToSwapped.skipped = true
fn.CFConvertFloatSwappedToHost.skipped = true
fn.CFConvertDoubleHostToSwapped.skipped = true
fn.CFConvertDoubleSwappedToHost.skipped = true

# Custom-defined inline functions
fn.CFRangeMake.skipped = true
fn.CFUserNotificationCheckBoxChecked.skipped = true
fn.CFUserNotificationSecureTextField.skipped = true
fn.CFUserNotificationPopUpSelection.skipped = true

# Conflicts with the Get variants.
fn.CFReadStreamCopyError.renamed = "copy_error"
fn.CFWriteStreamCopyError.renamed = "copy_error"

# Customized.
fn.CFDictionaryContainsKey.renamed = "contains_ptr_key"
fn.CFDictionaryContainsValue.renamed = "contains_ptr_value"
fn.CFURLCreateWithString.renamed = "__from_string"
fn.CFURLGetString.renamed = "__string"

##
## Fixing const-ness, nullability and bounds information.
##
## A lot of this is needed because Apple for some reason hasn't added
## nullability annotations to CoreFoundation.
##

fn.CFAllocatorCreate.arguments.1.written = false
fn.CFAllocatorCreate.arguments.1.bounds = "single"
fn.CFAllocatorCreateWithZone.arguments.1.bounds = "unsafe"
fn.CFAllocatorGetContext.arguments.1.bounds = "single"

fn.CFArrayCreate.arguments.1.bounds.counted-by = "numValues"
fn.CFArrayCreate.arguments.3.nullability = "nullable"
fn.CFArrayCreate.arguments.3.bounds = "single"
fn.CFArrayCreateCopy.arguments.1.nullability = "nonnull"
fn.CFArrayCreateMutable.arguments.2.nullability = "nullable"
fn.CFArrayCreateMutable.arguments.2.bounds = "single"
fn.CFArrayCreateMutableCopy.arguments.2.nullability = "nonnull"
fn.CFArrayGetValues.arguments.2.bounds.counted-by = "range.length"
fn.CFArrayReplaceValues.arguments.2.bounds.counted-by = "newCount"
fn.CFArrayAppendArray.arguments.1.nullability = "nonnull"

fn.CFAttributedStringCreate.arguments.1.nullability = "nonnull"
fn.CFAttributedStringCreate.arguments.2.nullability = "nullable" # Probably
fn.CFAttributedStringGetAttribute.arguments.2.nullability = "nonnull"
fn.CFAttributedStringGetAttribute.arguments.3.nullability = "nullable"
fn.CFAttributedStringGetAttribute.arguments.3.bounds = "single"
fn.CFAttributedStringGetAttributes.arguments.2.nullability = "nullable"
fn.CFAttributedStringGetAttributes.arguments.2.bounds = "single"
fn.CFAttributedStringGetAttributeAndLongestEffectiveRange.arguments.2.nullability = "nonnull"
fn.CFAttributedStringGetAttributeAndLongestEffectiveRange.arguments.4.nullability = "nullable"
fn.CFAttributedStringGetAttributeAndLongestEffectiveRange.arguments.4.bounds = "single"
fn.CFAttributedStringGetAttributesAndLongestEffectiveRange.arguments.3.nullability = "nullable"
fn.CFAttributedStringGetAttributesAndLongestEffectiveRange.arguments.3.bounds = "single"
fn.CFAttributedStringGetBidiLevelsAndResolvedDirections.arguments.3.bounds.counted-by = "range.length"
fn.CFAttributedStringGetBidiLevelsAndResolvedDirections.arguments.4.bounds.counted-by = "range.length"
fn.CFAttributedStringGetStatisticalWritingDirections.arguments.3.bounds.counted-by = "range.length"
fn.CFAttributedStringGetStatisticalWritingDirections.arguments.4.bounds.counted-by = "range.length"
fn.CFAttributedStringReplaceString.arguments.2.nullability = "nonnull"
fn.CFAttributedStringSetAttribute.arguments.2.nullability = "nonnull"
fn.CFAttributedStringSetAttribute.arguments.3.nullability = "nonnull"
fn.CFAttributedStringSetAttributes.arguments.2.nullability = "nonnull"
fn.CFAttributedStringRemoveAttribute.arguments.2.nullability = "nonnull"
fn.CFAttributedStringReplaceAttributedString.arguments.2.nullability = "nonnull"

fn.CFBagCreate.arguments.1.bounds.counted-by = "numValues"
fn.CFBagCreate.arguments.3.nullability = "nullable"
fn.CFBagCreate.arguments.3.bounds = "single"
fn.CFBagCreateMutable.arguments.2.nullability = "nullable"
fn.CFBagCreateMutable.arguments.2.bounds = "single"
fn.CFBagGetValueIfPresent.arguments.2.nullability = "nullable"
fn.CFBagGetValueIfPresent.arguments.2.bounds = "single"

fn.CFBinaryHeapCreate.arguments.2.nullability = "nullable"
fn.CFBinaryHeapCreate.arguments.2.bounds = "single"
fn.CFBinaryHeapCreate.arguments.3.nullability = "nullable"
fn.CFBinaryHeapCreate.arguments.3.bounds = "single"
fn.CFBinaryHeapCreateCopy.arguments.2.nullability = "nonnull"
fn.CFBinaryHeapGetMinimumIfPresent.arguments.1.nullability = "nonnull"
fn.CFBinaryHeapGetMinimumIfPresent.arguments.1.bounds = "single"
fn.CFBinaryHeapGetValues.arguments.1.bounds.counted-by = "self.count()"

# Counted by number of bits, not bytes.
fn.CFBitVectorCreate.arguments.1.bounds.counted-by = "(num_bits / 8).ceil()"
fn.CFBitVectorCreateCopy.arguments.1.nullability = "nonnull"
fn.CFBitVectorCreateMutableCopy.arguments.2.nullability = "nonnull"
fn.CFBitVectorGetBits.arguments.2.bounds.counted-by = "(range.length / 8).ceil()"

fn.CFBundleGetPackageInfo.arguments.1.nullability = "nullable"
fn.CFBundleGetPackageInfo.arguments.1.bounds = "single"
fn.CFBundleGetPackageInfo.arguments.2.nullability = "nullable"
fn.CFBundleGetPackageInfo.arguments.2.bounds = "single"
fn.CFBundleGetPackageInfoInDirectory.arguments.0.nullability = "nonnull"
fn.CFBundleGetPackageInfoInDirectory.arguments.1.nullability = "nullable"
fn.CFBundleGetPackageInfoInDirectory.arguments.1.bounds = "single"
fn.CFBundleGetPackageInfoInDirectory.arguments.2.nullability = "nullable"
fn.CFBundleGetPackageInfoInDirectory.arguments.2.bounds = "single"
fn.CFBundleCopyLocalizedStringForLocalizations.arguments.1.nullability = "nonnull"
fn.CFBundleCopyLocalizedStringForLocalizations.arguments.2.nullability = "nullable"
fn.CFBundleCopyLocalizedStringForLocalizations.arguments.3.nullability = "nonnull"
fn.CFBundleCopyLocalizedStringForLocalizations.arguments.4.nullability = "nonnull" # Unsure, but safe to default to
fn.CFBundleCopyPreferredLocalizationsFromArray.arguments.0.nullability = "nonnull"
fn.CFBundleCopyPreferredLocalizationsFromArray.arguments.1.nullability = "nullable"
fn.CFBundleGetFunctionPointersForNames.arguments.1.nullability = "nonnull"
fn.CFBundleGetFunctionPointersForNames.arguments.2.nullability = "nonnull"
fn.CFBundleGetFunctionPointersForNames.arguments.2.bounds = "single"
fn.CFBundleGetDataPointersForNames.arguments.1.nullability = "nonnull"
fn.CFBundleGetDataPointersForNames.arguments.2.bounds.counted-by = "symbol_names.count()"
fn.CFBundleOpenBundleResourceFiles.arguments.1.bounds.counted-by = "single"
fn.CFBundleOpenBundleResourceFiles.arguments.2.bounds.counted-by = "single"

fn.CFCalendarSetLocale.arguments.1.nullability = "nonnull"
fn.CFCalendarGetTimeRangeOfUnit.arguments.3.nullability = "nullable"
fn.CFCalendarGetTimeRangeOfUnit.arguments.3.bounds = "single"
fn.CFCalendarGetTimeRangeOfUnit.arguments.4.nullability = "nullable"
fn.CFCalendarGetTimeRangeOfUnit.arguments.4.bounds = "single"

fn.CFCharacterSetCreateWithCharactersInString.arguments.1.nullability = "nonnull"
fn.CFCharacterSetCreateWithBitmapRepresentation.arguments.1.nullability = "nonnull"
fn.CFCharacterSetCreateInvertedSet.arguments.1.nullability = "nonnull"
fn.CFCharacterSetIsSupersetOfSet.arguments.1.nullability = "nonnull"
fn.CFCharacterSetCreateBitmapRepresentation.arguments.1.nullability = "nonnull"
fn.CFCharacterSetAddCharactersInString.arguments.1.nullability = "nonnull"
fn.CFCharacterSetRemoveCharactersInString.arguments.1.nullability = "nonnull"
fn.CFCharacterSetUnion.arguments.1.nullability = "nonnull"
fn.CFCharacterSetIntersect.arguments.1.nullability = "nonnull"

fn.CFDataCreate.arguments.1.bounds.counted-by = "length"
fn.CFDataCreateWithBytesNoCopy.arguments.1.bounds.counted-by = "length"
fn.CFDataCreateMutableCopy.arguments.2.nullability = "nonnull"
fn.CFDataGetBytePtr.return.bounds.counted-by = "self.length()"
fn.CFDataGetMutableBytePtr.return.bounds.counted-by = "self.length()"
fn.CFDataGetBytes.arguments.2.bounds.counted-by = "range.length"
fn.CFDataAppendBytes.arguments.1.bounds.counted-by = "length"
fn.CFDataReplaceBytes.arguments.2.bounds.counted-by = "new_length"
fn.CFDataFind.arguments.1.nullability = "nonnull"

fn.CFDateCompare.arguments.1.nullability = "nonnull"
fn.CFGregorianDateGetAbsoluteTime.arguments.1.nullability = "nullable"
fn.CFAbsoluteTimeGetGregorianDate.arguments.1.nullability = "nullable"
fn.CFAbsoluteTimeAddGregorianUnits.arguments.1.nullability = "nullable"
fn.CFAbsoluteTimeGetDifferenceAsGregorianUnits.arguments.2.nullability = "nullable"
fn.CFAbsoluteTimeGetDayOfWeek.arguments.1.nullability = "nullable"
fn.CFAbsoluteTimeGetDayOfYear.arguments.1.nullability = "nullable"
fn.CFAbsoluteTimeGetWeekOfYear.arguments.1.nullability = "nullable"

fn.CFDateFormatterCreateDateFormatFromTemplate.arguments.1.nullability = "nonnull"
fn.CFDateFormatterCreateDateFormatFromTemplate.arguments.3.nullability = "nonnull"
fn.CFDateFormatterCreate.arguments.1.nullability = "nonnull"
fn.CFDateFormatterSetFormat.arguments.1.nullability = "nonnull"
fn.CFDateFormatterCreateStringWithDate.arguments.2.nullability = "nonnull"
fn.CFDateFormatterCreateDateFromString.arguments.2.nullability = "nonnull"
fn.CFDateFormatterCreateDateFromString.arguments.3.nullability = "nullable"
fn.CFDateFormatterCreateDateFromString.arguments.3.bounds = "single"
fn.CFDateFormatterGetAbsoluteTimeFromString.arguments.1.nullability = "nonnull"
fn.CFDateFormatterGetAbsoluteTimeFromString.arguments.2.nullability = "nullable"
fn.CFDateFormatterGetAbsoluteTimeFromString.arguments.2.bounds = "single"
fn.CFDateFormatterGetAbsoluteTimeFromString.arguments.3.nullability = "nonnull"
fn.CFDateFormatterGetAbsoluteTimeFromString.arguments.3.bounds = "single"
fn.CFDateFormatterSetProperty.arguments.1.nullability = "nonnull"
fn.CFDateFormatterSetProperty.arguments.2.nullability = "nullable"
fn.CFDateFormatterCopyProperty.arguments.1.nullability = "nonnull"

fn.CFDictionaryCreate.arguments.1.written = false
fn.CFDictionaryCreate.arguments.1.nullability = "nullable"
fn.CFDictionaryCreate.arguments.1.bounds.counted-by = "numValues"
fn.CFDictionaryCreate.arguments.2.written = false
fn.CFDictionaryCreate.arguments.2.nullability = "nullable"
fn.CFDictionaryCreate.arguments.2.bounds.counted-by = "numValues"
fn.CFDictionaryCreate.arguments.4.nullability = "nullable"
fn.CFDictionaryCreate.arguments.4.bounds = "single"
fn.CFDictionaryCreate.arguments.5.nullability = "nullable"
fn.CFDictionaryCreate.arguments.5.bounds = "single"
fn.CFDictionaryCreateMutable.arguments.2.nullability = "nullable"
fn.CFDictionaryCreateMutable.arguments.2.bounds = "single"
fn.CFDictionaryCreateMutable.arguments.3.nullability = "nullable"
fn.CFDictionaryCreateMutable.arguments.3.bounds = "single"
fn.CFDictionaryCreateMutableCopy.arguments.3.nullability = "nonnull"
fn.CFDictionaryGetValueIfPresent.arguments.2.nullability = "nullable"
fn.CFDictionaryGetValueIfPresent.arguments.2.bounds = "single"
fn.CFDictionaryGetKeysAndValues.arguments.1.bounds.counted-by = "self.count()"
fn.CFDictionaryGetKeysAndValues.arguments.2.bounds.counted-by = "self.count()"

fn.CFErrorCreate.arguments.1.nullability = "nonnull"
fn.CFErrorCreate.arguments.3.nullability = "nullable"
fn.CFErrorCreateWithUserInfoKeysAndValues.arguments.1.nullability = "nonnull"
fn.CFErrorCreateWithUserInfoKeysAndValues.arguments.3.bounds.counted-by = "num_user_info_values"
fn.CFErrorCreateWithUserInfoKeysAndValues.arguments.4.bounds.counted-by = "num_user_info_values"

fn.CFFileDescriptorCreate.arguments.4.nullability = "nullable" # Probably
fn.CFFileDescriptorCreate.arguments.4.bounds = "single"
fn.CFFileDescriptorGetContext.arguments.1.nullability = "nonnull"
fn.CFFileDescriptorGetContext.arguments.1.bounds = "single"

fn.CFFileSecurityCopyOwnerUUID.arguments.1.nullability = "nonnull"
fn.CFFileSecurityCopyOwnerUUID.arguments.1.bounds = "single"
fn.CFFileSecurityCopyGroupUUID.arguments.1.nullability = "nonnull"
fn.CFFileSecurityCopyGroupUUID.arguments.1.bounds = "single"
fn.CFFileSecurityGetOwner.arguments.1.nullability = "nonnull"
fn.CFFileSecurityGetOwner.arguments.1.bounds = "single"
fn.CFFileSecurityGetGroup.arguments.1.nullability = "nonnull"
fn.CFFileSecurityGetGroup.arguments.1.bounds = "single"
fn.CFFileSecurityGetMode.arguments.1.nullability = "nonnull"
fn.CFFileSecurityGetMode.arguments.1.bounds = "single"

fn.CFLocaleCreateLocaleIdentifierFromComponents.arguments.1.nullability = "nonnull"

fn.CFMachPortCreate.arguments.2.written = false
fn.CFMachPortCreate.arguments.2.nullability = "nullable" # Probably
fn.CFMachPortCreate.arguments.2.bounds = "single"
fn.CFMachPortCreate.arguments.3.nullability = "nullable"
fn.CFMachPortCreate.arguments.3.bounds = "single"
fn.CFMachPortCreateWithPort.arguments.3.written = false
fn.CFMachPortCreateWithPort.arguments.3.nullability = "nullable" # Probably
fn.CFMachPortCreateWithPort.arguments.3.bounds = "single"
fn.CFMachPortCreateWithPort.arguments.4.nullability = "nullable"
fn.CFMachPortCreateWithPort.arguments.4.bounds = "single"
fn.CFMachPortGetContext.arguments.1.nullability = "nonnull"
fn.CFMachPortGetContext.arguments.1.bounds = "single"

fn.CFMessagePortCreateLocal.arguments.3.written = false
fn.CFMessagePortCreateLocal.arguments.3.nullability = "nullable" # Probably
fn.CFMessagePortCreateLocal.arguments.3.bounds = "single"
fn.CFMessagePortCreateLocal.arguments.4.nullability = "nullable"
fn.CFMessagePortCreateLocal.arguments.4.bounds = "single"
fn.CFMessagePortGetContext.arguments.1.nullability = "nonnull"
fn.CFMessagePortGetContext.arguments.1.bounds = "single"
fn.CFMessagePortSendRequest.arguments.2.nullability = "nonnull"
fn.CFMessagePortSendRequest.arguments.5.nullability = "nullable"
fn.CFMessagePortSendRequest.arguments.6.nullability = "nonnull"
fn.CFMessagePortSendRequest.arguments.6.bounds = "single"
fn.CFMessagePortSetDispatchQueue.arguments.1.nullability = "nullable" # Maybe?

fn.CFNumberCompare.arguments.1.nullability = "nonnull"

fn.CFNumberFormatterCreate.arguments.1.nullability = "nonnull"
fn.CFNumberFormatterSetFormat.arguments.1.nullability = "nonnull"
fn.CFNumberFormatterCreateStringWithNumber.arguments.2.nullability = "nonnull"
fn.CFNumberFormatterCreateNumberFromString.arguments.2.nullability = "nonnull"
fn.CFNumberFormatterCreateNumberFromString.arguments.3.nullability = "nonnull"
fn.CFNumberFormatterCreateNumberFromString.arguments.3.bounds = "single"
fn.CFNumberFormatterGetValueFromString.arguments.1.nullability = "nonnull"
fn.CFNumberFormatterGetValueFromString.arguments.2.bounds.sized-by = "number_type.size()"
fn.CFNumberFormatterSetProperty.arguments.1.nullability = "nonnull"
fn.CFNumberFormatterSetProperty.arguments.2.nullability = "nullable"
fn.CFNumberFormatterCopyProperty.arguments.2.nullability = "nonnull"
fn.CFNumberFormatterGetDecimalInfoForCurrencyCode.arguments.0.nullability = "nonnull"
fn.CFNumberFormatterGetDecimalInfoForCurrencyCode.arguments.1.nullability = "nonnull"
fn.CFNumberFormatterGetDecimalInfoForCurrencyCode.arguments.1.bounds = "single"
fn.CFNumberFormatterGetDecimalInfoForCurrencyCode.arguments.2.nullability = "nonnull"
fn.CFNumberFormatterGetDecimalInfoForCurrencyCode.arguments.2.bounds = "single"

fn.CFPlugInInstanceGetInterfaceFunctionTable.arguments.1.nullability = "nonnull"
fn.CFPlugInInstanceGetInterfaceFunctionTable.arguments.2.nullability = "nonnull"
fn.CFPlugInInstanceCreateWithInstanceDataSize.arguments.3.nullability = "nonnull"

fn.CFPreferencesGetAppBooleanValue.arguments.2.bounds = "single"
fn.CFPreferencesGetAppIntegerValue.arguments.2.bounds = "single"

# typedef.CFPlugInInstanceGetInterfaceFunction.arguments.2.bounds = "single"
fn.CFPlugInInstanceGetInterfaceFunctionTable.arguments.2.bounds = "single"

fn.CFPropertyListCreateFromXMLData.arguments.3.bounds = "single"
fn.CFPropertyListWriteToStream.arguments.3.bounds = "single"
fn.CFPropertyListCreateFromStream.arguments.4.bounds = "single"
fn.CFPropertyListCreateFromStream.arguments.5.bounds = "single"
fn.CFPropertyListCreateWithData.arguments.3.bounds = "single"
fn.CFPropertyListCreateWithData.arguments.4.bounds = "single"
fn.CFPropertyListCreateWithStream.arguments.4.bounds = "single"
fn.CFPropertyListCreateWithStream.arguments.5.bounds = "single"
fn.CFPropertyListWrite.arguments.4.bounds = "single"
fn.CFPropertyListCreateData.arguments.4.bounds = "single"

fn.CFRunLoopPerformBlock.arguments.1.nullability = "nonnull"
fn.CFRunLoopPerformBlock.arguments.2.nullability = "nonnull"
fn.CFRunLoopSourceCreate.arguments.2.written = false
fn.CFRunLoopSourceCreate.arguments.2.nullability = "nonnull"
fn.CFRunLoopSourceCreate.arguments.2.bounds = "single"
fn.CFRunLoopSourceGetContext.arguments.1.nullability = "nonnull"
fn.CFRunLoopSourceGetContext.arguments.1.bounds = "single"
fn.CFRunLoopObserverCreate.arguments.5.written = false
fn.CFRunLoopObserverCreate.arguments.5.nullability = "nullable"
fn.CFRunLoopObserverCreate.arguments.5.bounds = "single"
fn.CFRunLoopObserverGetContext.arguments.1.nullability = "nonnull"
fn.CFRunLoopObserverGetContext.arguments.1.bounds = "single"
fn.CFRunLoopTimerCreate.arguments.6.written = false
fn.CFRunLoopTimerCreate.arguments.6.nullability = "nullable"
fn.CFRunLoopTimerCreate.arguments.6.bounds = "single"
fn.CFRunLoopTimerGetContext.arguments.1.nullability = "nonnull"
fn.CFRunLoopTimerGetContext.arguments.1.bounds = "single"

fn.CFSetCreate.arguments.1.bounds.counted-by = "num_values"
fn.CFSetCreate.arguments.3.bounds = "single"
fn.CFSetCreateMutable.arguments.2.bounds = "single"
fn.CFSetGetValueIfPresent.arguments.2.nullability = "nullable"
fn.CFSetGetValueIfPresent.arguments.2.bounds = "single"
fn.CFSetGetValues.arguments.1.bounds.counted-by = "self.count()"

fn.CFSocketCreate.arguments.6.bounds = "single"
fn.CFSocketCreateWithNative.arguments.4.bounds = "single"
fn.CFSocketCreateWithSocketSignature.arguments.1.bounds = "single"
fn.CFSocketCreateWithSocketSignature.arguments.4.bounds = "single"
fn.CFSocketCreateConnectedToSocketSignature.arguments.1.bounds = "single"
fn.CFSocketCreateConnectedToSocketSignature.arguments.4.bounds = "single"
fn.CFSocketGetContext.arguments.1.nullability = "nonnull"
fn.CFSocketGetContext.arguments.1.bounds = "single"
fn.CFSocketRegisterValue.arguments.0.nullability = "nullable"
fn.CFSocketRegisterValue.arguments.0.bounds = "single"
fn.CFSocketCopyRegisteredValue.arguments.0.nullability = "nullable"
fn.CFSocketCopyRegisteredValue.arguments.0.bounds = "single"
fn.CFSocketCopyRegisteredValue.arguments.3.bounds = "single"
fn.CFSocketCopyRegisteredValue.arguments.4.bounds = "single"
fn.CFSocketRegisterSocketSignature.arguments.0.nullability = "nullable"
fn.CFSocketRegisterSocketSignature.arguments.0.bounds = "single"
fn.CFSocketRegisterSocketSignature.arguments.3.bounds = "single"
fn.CFSocketCopyRegisteredSocketSignature.arguments.0.nullability = "nullable"
fn.CFSocketCopyRegisteredSocketSignature.arguments.0.bounds = "single"
fn.CFSocketCopyRegisteredSocketSignature.arguments.3.bounds = "single"
fn.CFSocketCopyRegisteredSocketSignature.arguments.4.bounds = "single"
fn.CFSocketUnregister.arguments.0.nullability = "nullable"
fn.CFSocketUnregister.arguments.0.bounds = "single"

fn.CFStreamCreateBoundPair.arguments.1.bounds = "single"
fn.CFStreamCreateBoundPair.arguments.2.bounds = "single"
fn.CFStreamCreatePairWithSocket.arguments.2.bounds = "single"
fn.CFStreamCreatePairWithSocket.arguments.3.bounds = "single"
fn.CFStreamCreatePairWithSocketToHost.arguments.3.bounds = "single"
fn.CFStreamCreatePairWithSocketToHost.arguments.4.bounds = "single"
fn.CFStreamCreatePairWithPeerSocketSignature.arguments.1.bounds = "single"
fn.CFStreamCreatePairWithPeerSocketSignature.arguments.2.bounds = "single"
fn.CFStreamCreatePairWithPeerSocketSignature.arguments.3.bounds = "single"
fn.CFReadStreamCreateWithBytesNoCopy.arguments.1.bounds.counted-by = "length"
fn.CFWriteStreamCreateWithBuffer.arguments.1.bounds.counted-by = "buffer_capacity"
fn.CFReadStreamRead.arguments.1.bounds.counted-by = "buffer_length"
fn.CFReadStreamGetBuffer.arguments.2.bounds = "single"
fn.CFReadStreamGetBuffer.return.bounds.counted-by = "num_bytes_read (if != -1)"
fn.CFWriteStreamWrite.arguments.1.bounds.counted-by = "buffer_length"
fn.CFReadStreamSetClient.arguments.3.written = false
fn.CFReadStreamSetClient.arguments.3.bounds = "single"
fn.CFWriteStreamSetClient.arguments.3.written = false
fn.CFWriteStreamSetClient.arguments.3.bounds = "single"

fn.CFStringCreateWithCString.arguments.1.nullability = "nonnull"
fn.CFStringCreateWithCString.arguments.1.bounds = "null-terminated"
fn.CFStringCreateWithBytes.arguments.1.bounds.counted-by = "num_bytes"
fn.CFStringCreateWithCharacters.arguments.1.bounds.counted-by = "num_chars"
fn.CFStringCreateWithCStringNoCopy.arguments.1.bounds = "null-terminated"
fn.CFStringCreateWithBytesNoCopy.arguments.1.bounds.counted-by = "num_bytes"
fn.CFStringCreateWithCharactersNoCopy.arguments.1.bounds.counted-by = "num_chars"
fn.CFStringCreateMutableWithExternalCharactersNoCopy.arguments.1.bounds.counted-by = "num_chars"
fn.CFStringGetCharacters.arguments.2.bounds.counted-by = "range.length"
fn.CFStringGetCString.arguments.1.bounds.counted-by = "buffer_size"
fn.CFStringGetCStringPtr.return.bounds.counted-by = "self.length()"
fn.CFStringGetCharactersPtr.return.bounds.counted-by = "self.length()"
fn.CFStringGetBytes.arguments.5.bounds.counted-by = "max_buf_len"
fn.CFStringGetBytes.arguments.7.nullability = "nullable"
fn.CFStringGetBytes.arguments.7.bounds = "single"
fn.CFStringGetFileSystemRepresentation.arguments.1.bounds.counted-by = "max_buf_len"
fn.CFStringCreateWithFileSystemRepresentation.arguments.1.bounds = "null-terminated"
fn.CFStringFindWithOptionsAndLocale.arguments.5.nullability = "nullable"
fn.CFStringFindWithOptionsAndLocale.arguments.5.bounds = "single"
fn.CFStringFindWithOptions.arguments.4.nullability = "nullable"
fn.CFStringFindWithOptions.arguments.4.bounds = "single"
fn.CFStringFindCharacterFromSet.arguments.4.nullability = "nullable"
fn.CFStringFindCharacterFromSet.arguments.4.bounds = "single"
fn.CFStringGetLineBounds.arguments.2.nullability = "nullable"
fn.CFStringGetLineBounds.arguments.2.bounds = "single"
fn.CFStringGetLineBounds.arguments.3.nullability = "nullable"
fn.CFStringGetLineBounds.arguments.3.bounds = "single"
fn.CFStringGetLineBounds.arguments.4.nullability = "nullable"
fn.CFStringGetLineBounds.arguments.4.bounds = "single"
fn.CFStringGetParagraphBounds.arguments.2.nullability = "nullable"
fn.CFStringGetParagraphBounds.arguments.2.bounds = "single"
fn.CFStringGetParagraphBounds.arguments.3.nullability = "nullable"
fn.CFStringGetParagraphBounds.arguments.3.bounds = "single"
fn.CFStringGetParagraphBounds.arguments.4.nullability = "nullable"
fn.CFStringGetParagraphBounds.arguments.4.bounds = "single"
fn.CFStringGetHyphenationLocationBeforeIndex.arguments.5.nullability = "nullable"
fn.CFStringGetHyphenationLocationBeforeIndex.arguments.5.bounds = "single"
fn.CFStringAppendCharacters.arguments.1.bounds.counted-by = "num_chars"
fn.CFStringAppendCString.arguments.1.bounds = "null-terminated"
fn.CFStringSetExternalCharactersNoCopy.arguments.1.bounds.counted-by = "capacity"
fn.CFStringTransform.arguments.1.nullability = "nullable"
fn.CFStringTransform.arguments.1.bounds = "single"
fn.CFStringGetListOfAvailableEncodings.return.bounds.terminated-by = "kCFStringEncodingInvalidId"
fn.CFStringInitInlineBuffer.arguments.1.nullability = "nonnull"
fn.CFStringInitInlineBuffer.arguments.1.bounds = "single"
fn.CFStringGetCharacterFromInlineBuffer.arguments.0.nullability = "nonnull"
fn.CFStringGetCharacterFromInlineBuffer.arguments.0.bounds = "single"
fn.CFStringGetSurrogatePairForLongCharacter.arguments.1.bounds.counted-by = "2"

fn.CFStringTokenizerGetCurrentSubTokens.arguments.1.bounds.counted-by = "max_range_length"

fn.CFTreeCreate.arguments.1.bounds = "single"
fn.CFTreeGetContext.arguments.1.nullability = "nonnull"
fn.CFTreeGetContext.arguments.1.bounds = "single"
fn.CFTreeGetChildren.arguments.1.bounds.counted-by = "self.child_count()"
fn.CFTreeSetContext.arguments.1.bounds = "single"

fn.CFURLCreateWithBytes.arguments.1.bounds.counted-by = "length"
fn.CFURLCreateAbsoluteURLWithBytes.arguments.1.bounds.counted-by = "length"
fn.CFURLCreateFromFileSystemRepresentation.arguments.1.bounds.counted-by = "buf_len"
fn.CFURLCreateFromFileSystemRepresentationRelativeToBase.arguments.1.bounds.counted-by = "buf_len"
fn.CFURLGetFileSystemRepresentation.arguments.2.bounds.counted-by = "max_buf_len"
fn.CFURLCopyStrictPath.arguments.1.bounds = "single"
fn.CFURLGetBytes.arguments.1.bounds.counted-by = "buffer_length"
fn.CFURLGetByteRangeForComponent.arguments.2.bounds = "single"
fn.CFURLCreateFileReferenceURL.arguments.2.bounds = "single"
fn.CFURLCreateFilePathURL.arguments.2.bounds = "single"
fn.CFURLCopyResourcePropertyForKey.arguments.3.bounds = "single"
fn.CFURLCopyResourcePropertiesForKeys.arguments.2.bounds = "single"
fn.CFURLSetResourcePropertyForKey.arguments.3.bounds = "single"
fn.CFURLSetResourcePropertiesForKeys.arguments.2.bounds = "single"
fn.CFURLResourceIsReachable.arguments.1.bounds = "single"
fn.CFURLCreateBookmarkData.arguments.5.bounds = "single"
fn.CFURLCreateByResolvingBookmarkData.arguments.5.bounds = "single"
fn.CFURLCreateByResolvingBookmarkData.arguments.6.bounds = "single"
fn.CFURLCreateBookmarkDataFromFile.arguments.2.bounds = "single"
fn.CFURLWriteBookmarkDataToFile.arguments.3.bounds = "single"
fn.CFURLCreateDataAndPropertiesFromResource.arguments.2.bounds = "single"
fn.CFURLCreateDataAndPropertiesFromResource.arguments.3.bounds = "single"
fn.CFURLCreateDataAndPropertiesFromResource.arguments.5.bounds = "single"
fn.CFURLWriteDataAndPropertiesToResource.arguments.3.bounds = "single"
fn.CFURLDestroyResource.arguments.1.bounds = "single"
fn.CFURLCreatePropertyFromResource.arguments.3.bounds = "single"
fn.CFURLEnumeratorGetNextURL.arguments.1.bounds = "single"
fn.CFURLEnumeratorGetNextURL.arguments.2.bounds = "single"

fn.CFUserNotificationCreate.arguments.3.bounds = "single"
fn.CFUserNotificationReceiveResponse.arguments.2.bounds = "single"
fn.CFUserNotificationDisplayAlert.arguments.10.bounds = "single"

fn.CFXMLParserCreate.arguments.5.nullability = "nonnull"
fn.CFXMLParserCreate.arguments.5.bounds = "single"
fn.CFXMLParserCreate.arguments.6.nullability = "nullable"
fn.CFXMLParserCreate.arguments.6.bounds = "single"
fn.CFXMLParserCreateWithDataFromURL.arguments.4.nullability = "nonnull"
fn.CFXMLParserCreateWithDataFromURL.arguments.4.bounds = "single"
fn.CFXMLParserCreateWithDataFromURL.arguments.5.nullability = "nullable"
fn.CFXMLParserCreateWithDataFromURL.arguments.5.bounds = "single"
fn.CFXMLParserGetContext.arguments.1.nullability = "nonnull"
fn.CFXMLParserGetContext.arguments.1.bounds = "single"
fn.CFXMLParserGetCallBacks.arguments.1.bounds = "single"
fn.CFXMLTreeCreateFromDataWithError.arguments.5.bounds = "single"

##
## Fixing generics.
##

# Key-value is same as for NSAttributedString.
fn.CFAttributedStringCreate.arguments.2.generics = ["CoreFoundation.CFString.CFString", "CoreFoundation.CFType"]
fn.CFAttributedStringGetAttributes.return.generics = ["CoreFoundation.CFString.CFString", "CoreFoundation.CFType"]
fn.CFAttributedStringGetAttributesAndLongestEffectiveRange.return.generics = ["CoreFoundation.CFString.CFString", "CoreFoundation.CFType"]
fn.CFAttributedStringSetAttributes.arguments.2.generics = ["CoreFoundation.CFString.CFString", "CoreFoundation.CFType"]

# Key being string for info dictionaries is same as NSBundle.infoDictionary.
fn.CFBundleGetAllBundles.return.generics = ["CoreFoundation.CFBundle.CFBundle"]
fn.CFBundleCreateBundlesFromDirectory.return.generics = ["CoreFoundation.CFBundle.CFBundle"]
fn.CFBundleGetInfoDictionary.return.generics = ["CoreFoundation.CFString.CFString", "CoreFoundation.CFPropertyList.CFPropertyList"]
fn.CFBundleGetLocalInfoDictionary.return.generics = ["CoreFoundation.CFString.CFString", "CoreFoundation.CFPropertyList.CFPropertyList"]
fn.CFBundleCopyInfoDictionaryInDirectory.return.generics = ["CoreFoundation.CFString.CFString", "CoreFoundation.CFPropertyList.CFPropertyList"]
fn.CFBundleCopyResourceURLsOfType.return.generics = ["CoreFoundation.CFURL.CFURL"]
fn.CFBundleCopyLocalizedStringForLocalizations.arguments.4.generics = ["CoreFoundation.CFString.CFString"]
fn.CFBundleCopyResourceURLsOfTypeInDirectory.return.generics = ["CoreFoundation.CFURL.CFURL"]
fn.CFBundleCopyBundleLocalizations.return.generics = ["CoreFoundation.CFString.CFString"]
fn.CFBundleCopyPreferredLocalizationsFromArray.arguments.0.generics = ["CoreFoundation.CFString.CFString"]
fn.CFBundleCopyPreferredLocalizationsFromArray.return.generics = ["CoreFoundation.CFString.CFString"]
fn.CFBundleCopyLocalizationsForPreferences.arguments.0.generics = ["CoreFoundation.CFString.CFString"]
fn.CFBundleCopyLocalizationsForPreferences.arguments.1.generics = ["CoreFoundation.CFString.CFString"]
fn.CFBundleCopyLocalizationsForPreferences.return.generics = ["CoreFoundation.CFString.CFString"]
fn.CFBundleCopyResourceURLsOfTypeForLocalization.return.generics = ["CoreFoundation.CFURL.CFURL"]
fn.CFBundleCopyInfoDictionaryForURL.return.generics = ["CoreFoundation.CFString.CFString", "CoreFoundation.CFPropertyList.CFPropertyList"]
fn.CFBundleCopyLocalizationsForURL.return.generics = ["CoreFoundation.CFString.CFString"]
fn.CFBundleCopyExecutableArchitecturesForURL.return.generics = ["CoreFoundation.CFNumber.CFNumber"]
fn.CFBundleCopyExecutableArchitectures.return.generics = ["CoreFoundation.CFNumber.CFNumber"]
fn.CFBundleGetFunctionPointersForNames.arguments.1.generics = ["CoreFoundation.CFString.CFString"]
fn.CFBundleGetDataPointersForNames.arguments.1.generics = ["CoreFoundation.CFString.CFString"]

# Key-value is same as for NSError.
fn.CFErrorCreate.arguments.3.generics = ["CoreFoundation.CFString.CFString", "CoreFoundation.CFType"]
fn.CFErrorCopyUserInfo.return.generics = ["CoreFoundation.CFString.CFString", "CoreFoundation.CFType"]

fn.CFLocaleCopyAvailableLocaleIdentifiers.return.generics = ["CoreFoundation.CFString.CFString"]
fn.CFLocaleCopyISOLanguageCodes.return.generics = ["CoreFoundation.CFString.CFString"]
fn.CFLocaleCopyISOCountryCodes.return.generics = ["CoreFoundation.CFString.CFString"]
fn.CFLocaleCopyISOCurrencyCodes.return.generics = ["CoreFoundation.CFString.CFString"]
fn.CFLocaleCopyCommonISOCurrencyCodes.return.generics = ["CoreFoundation.CFString.CFString"]
fn.CFLocaleCopyPreferredLanguages.return.generics = ["CoreFoundation.CFLocale.CFLocaleIdentifier"] # TODO: Somehow communicate that CFString is required for this to be available
fn.CFLocaleCreateComponentsFromLocaleIdentifier.return.generics = ["CoreFoundation.CFString.CFString", "CoreFoundation.CFString.CFString"]
fn.CFLocaleCreateLocaleIdentifierFromComponents.arguments.1.generics = ["CoreFoundation.CFString.CFString", "CoreFoundation.CFString.CFString"]

# `userInfo` dict generics are allowed to be anything, except if a "distributed" notification.
# typedef.CFNotificationCallback.arguments.4.generics = []
fn.CFNotificationCenterPostNotification.arguments.3.generics = []
fn.CFNotificationCenterPostNotificationWithOptions.arguments.3.generics = []

fn.CFPlugInFindFactoriesForPlugInType.return.generics = ["CoreFoundation.CFUUID.CFUUID"]
fn.CFPlugInFindFactoriesForPlugInTypeInPlugIn.return.generics = ["CoreFoundation.CFUUID.CFUUID"]

# Preferences are property lists
fn.CFPreferencesCopyMultiple.arguments.0.generics = ["CoreFoundation.CFString.CFString"]
fn.CFPreferencesCopyMultiple.return.generics = ["CoreFoundation.CFString.CFString", "CoreFoundation.CFType"]
fn.CFPreferencesSetMultiple.arguments.0.generics = ["CoreFoundation.CFString.CFString", "CoreFoundation.CFType"]
fn.CFPreferencesSetMultiple.arguments.1.generics = ["CoreFoundation.CFString.CFString"]
fn.CFPreferencesCopyKeyList.return.generics = ["CoreFoundation.CFString.CFString"]
fn.CFPreferencesCopyApplicationList.return.generics = [] # TODO: Maybe String?

fn.CFRunLoopCopyAllModes.return.generics = ["CoreFoundation.CFRunLoop.CFRunLoopMode"]

fn.CFStringCreateArrayWithFindResults.return.generics = [] # TODO: Pointers to CFRange.
fn.CFStringCreateByCombiningStrings.arguments.1.generics = ["CoreFoundation.CFString.CFString"]
fn.CFStringCreateArrayBySeparatingStrings.return.generics = ["CoreFoundation.CFString.CFString"]

# TODO: Unclear type.
fn.CFStringTokenizerGetCurrentSubTokens.arguments.3.generics = []

fn.CFTimeZoneCopyKnownNames.return.generics = ["CoreFoundation.CFString.CFString"]
fn.CFTimeZoneCopyAbbreviationDictionary.return.generics = ["CoreFoundation.CFString.CFString", "CoreFoundation.CFString.CFString"]
fn.CFTimeZoneSetAbbreviationDictionary.arguments.0.generics = ["CoreFoundation.CFString.CFString", "CoreFoundation.CFString.CFString"]

# Resource property keys are CFString keys.
# See also `-[NSURL bookmarkDataWithOptions:includingResourceValuesForKeys:relativeToURL:error:]`.
fn.CFURLCopyResourcePropertiesForKeys.arguments.1.generics = ["CoreFoundation.CFString.CFString"]
fn.CFURLCopyResourcePropertiesForKeys.return.generics = ["CoreFoundation.CFString.CFString", "CoreFoundation.CFType"]
fn.CFURLSetResourcePropertiesForKeys.arguments.1.generics = ["CoreFoundation.CFString.CFString", "CoreFoundation.CFType"]
fn.CFURLCreateBookmarkData.arguments.3.generics = ["CoreFoundation.CFString.CFString"]
fn.CFURLCreateByResolvingBookmarkData.arguments.4.generics = ["CoreFoundation.CFString.CFString"]
fn.CFURLCreateResourcePropertiesForKeysFromBookmarkData.arguments.1.generics = ["CoreFoundation.CFString.CFString"]
fn.CFURLCreateResourcePropertiesForKeysFromBookmarkData.return.generics = ["CoreFoundation.CFString.CFString", "CoreFoundation.CFType"]

fn.CFURLCreateDataAndPropertiesFromResource.arguments.3.generics = ["CoreFoundation.CFString.CFString", "CoreFoundation.CFType"]
fn.CFURLCreateDataAndPropertiesFromResource.arguments.4.generics = ["CoreFoundation.CFString.CFString"]
fn.CFURLWriteDataAndPropertiesToResource.arguments.2.generics = ["CoreFoundation.CFString.CFString", "CoreFoundation.CFType"]

fn.CFURLEnumeratorCreateForDirectoryURL.arguments.3.generics = ["CoreFoundation.CFString.CFString"]
fn.CFURLEnumeratorCreateForMountedVolumes.arguments.2.generics = ["CoreFoundation.CFString.CFString"]

fn.CFUserNotificationCreate.arguments.4.generics = ["CoreFoundation.CFString.CFString", "CoreFoundation.CFType"]
fn.CFUserNotificationGetResponseDictionary.return.generics = ["CoreFoundation.CFString.CFString", "CoreFoundation.CFType"]
fn.CFUserNotificationUpdate.arguments.3.generics = ["CoreFoundation.CFString.CFString", "CoreFoundation.CFType"]

# TODO: Support this in `header-translator`
# struct.CFXMLElementInfo.fields.0.generics = [...]
# struct.CFXMLElementInfo.fields.1.generics = [...]

# TODO.
fn.CFXMLTreeCreateFromDataWithError.arguments.5.generics = []
fn.CFXMLCreateStringByEscapingEntities.arguments.2.generics = []
fn.CFXMLCreateStringByUnescapingEntities.arguments.2.generics = []

##
## Safety
##

# SAFETY: CoreFoundation is a bit complex when it comes to safety.
# See the comments below for safety considerations. Certain things are also
# handled in `header-translator`.
#
# TODO(breaking): Instead of marking most of these safe, mark the correct
# nullability instead.
#
# TODO(breaking): Generally, review these again.
unsafe-default-safety.documentation-is-reviewed = true
# Generally not guaranteed to be bounds-checked.
# TODO(breaking): Change to `true`.
unsafe-default-safety.bounds-checked-internally = true

# CFArray
fn.CFArrayCreateMutableCopy.unsafe = true # UB if capacity not large enough
fn.CFArrayGetCount.unsafe = false
fn.CFArrayGetValueAtIndex.unsafe = true # UB if index out of bounds
fn.CFArrayRemoveValueAtIndex.unsafe = true # UB if index out of bounds
fn.CFArrayRemoveAllValues.unsafe = false
fn.CFArrayExchangeValuesAtIndices.unsafe = true # UB if index out of bounds
fn.CFArrayAppendArray.unsafe = true # UB if range out of bounds

# CFAttributedString
fn.CFAttributedStringCreate.unsafe = true # CFDictionary can contain anything
fn.CFAttributedStringCreateWithSubstring.unsafe = true # range must be in bounds
fn.CFAttributedStringCreateCopy.unsafe = false
fn.CFAttributedStringCreateMutableCopy.unsafe = false
fn.CFAttributedStringCreateMutable.unsafe = false
fn.CFAttributedStringReplaceString.unsafe = true # range must be in bounds
fn.CFAttributedStringGetMutableString.unsafe = false
fn.CFAttributedStringSetAttributes.unsafe = true # range must be in bounds
fn.CFAttributedStringSetAttribute.unsafe = true # range must be in bounds
fn.CFAttributedStringRemoveAttribute.unsafe = true # range must be in bounds
fn.CFAttributedStringReplaceAttributedString.unsafe = true # range must be in bounds
fn.CFAttributedStringBeginEditing.unsafe = false
fn.CFAttributedStringEndEditing.unsafe = false

# CFBase
fn.CFAllocatorSetDefault.unsafe = false
fn.CFAllocatorGetDefault.unsafe = false
fn.CFAllocatorAllocateBytes.unsafe = false
fn.CFAllocatorAllocate.unsafe = false
fn.CFAllocatorGetPreferredSizeForSize.unsafe = false
fn.CFGetTypeID.unsafe = false
fn.CFCopyTypeIDDescription.unsafe = false
fn.CFGetRetainCount.unsafe = false
fn.CFEqual.unsafe = false
fn.CFHash.unsafe = false
fn.CFCopyDescription.unsafe = false
fn.CFGetAllocator.unsafe = false

# CFBundle
fn.CFBundleGetMainBundle.unsafe = false
fn.CFBundleGetBundleWithIdentifier.unsafe = false
fn.CFBundleGetAllBundles.unsafe = true # Not thread-safe
fn.CFBundleCreate.unsafe = false
fn.CFBundleCreateBundlesFromDirectory.unsafe = false
fn.CFBundleGetValueForInfoDictionaryKey.unsafe = false
fn.CFBundleCopySupportFilesDirectoryURL.unsafe = false
fn.CFBundleCopyResourcesDirectoryURL.unsafe = false
fn.CFBundleCopyPrivateFrameworksURL.unsafe = false
fn.CFBundleCopySharedFrameworksURL.unsafe = false
fn.CFBundleCopySharedSupportURL.unsafe = false
fn.CFBundleCopyBuiltInPlugInsURL.unsafe = false
fn.CFBundleCopyInfoDictionaryInDirectory.unsafe = false
fn.CFBundleCopyResourceURL.unsafe = false
fn.CFBundleCopyResourceURLsOfType.unsafe = false
fn.CFBundleCopyLocalizedString.unsafe = false
fn.CFBundleCopyResourceURLInDirectory.unsafe = false
fn.CFBundleCopyResourceURLsOfTypeInDirectory.unsafe = false
fn.CFBundleCopyBundleLocalizations.unsafe = false
fn.CFBundleCopyPreferredLocalizationsFromArray.unsafe = true # CFArray can contain anything
fn.CFBundleCopyLocalizationsForPreferences.unsafe = true # CFArray can contain anything
fn.CFBundleCopyResourceURLForLocalization.unsafe = false
fn.CFBundleCopyResourceURLsOfTypeForLocalization.unsafe = false
fn.CFBundleCopyInfoDictionaryForURL.unsafe = false
fn.CFBundleCopyLocalizationsForURL.unsafe = false
fn.CFBundleCopyExecutableArchitecturesForURL.unsafe = false
fn.CFBundleCopyExecutableURL.unsafe = false
fn.CFBundleCopyExecutableArchitectures.unsafe = false
fn.CFBundleLoadExecutable.unsafe = true # See below
fn.CFBundleUnloadExecutable.unsafe = true # Seems wildly unsafe?
fn.CFBundleGetFunctionPointerForName.unsafe = false
fn.CFBundleGetDataPointerForName.unsafe = false
fn.CFBundleCopyAuxiliaryExecutableURL.unsafe = false
fn.CFBundleIsExecutableLoadable.unsafe = false
fn.CFBundleIsExecutableLoadableForURL.unsafe = false
fn.CFBundleIsArchitectureLoadable.unsafe = false
fn.CFBundleGetPlugIn.unsafe = false

# CFCalendar
fn.CFCalendarCopyCurrent.unsafe = false # Returns a new instance, so still safe to modify
fn.CFCalendarCreateWithIdentifier.unsafe = false
fn.CFCalendarSetLocale.unsafe = true
fn.CFCalendarSetTimeZone.unsafe = false

# CFData
fn.CFDataCreateCopy.unsafe = false
fn.CFDataCreateMutable.unsafe = false
fn.CFDataGetMutableBytePtr.unsafe = false
fn.CFDataSetLength.unsafe = false
fn.CFDataIncreaseLength.unsafe = false
fn.CFDataDeleteBytes.unsafe = false

# CFDate
fn.CFDateCreate.unsafe = false
fn.CFDateGetTimeIntervalSinceDate.unsafe = false

# CFDictionary
fn.CFDictionaryCreateCopy.unsafe = false
fn.CFDictionaryCreateMutableCopy.unsafe = true # UB if capacity not large enough
fn.CFDictionaryGetCount.unsafe = false
fn.CFDictionaryRemoveAllValues.unsafe = false

# CFFileDescriptor
fn.CFFileDescriptorCreate.unsafe = true # Callout / context must be sendable
fn.CFFileDescriptorGetNativeDescriptor.unsafe = false
fn.CFFileDescriptorCreateRunLoopSource.unsafe = false

# CFFileSecurity
fn.CFFileSecurityCreate.unsafe = false
fn.CFFileSecurityCreateCopy.unsafe = false
fn.CFFileSecuritySetOwnerUUID.unsafe = false
fn.CFFileSecuritySetGroupUUID.unsafe = false

# CFLocale
fn.CFLocaleCreateCanonicalLanguageIdentifierFromString.unsafe = false
fn.CFLocaleCreateCanonicalLocaleIdentifierFromString.unsafe = false
fn.CFLocaleCreateCanonicalLocaleIdentifierFromScriptManagerCodes.unsafe = false
fn.CFLocaleCreateLocaleIdentifierFromWindowsLocaleCode.unsafe = false
fn.CFLocaleGetWindowsLocaleCodeFromLocaleIdentifier.unsafe = false
fn.CFLocaleGetLanguageCharacterDirection.unsafe = false
fn.CFLocaleGetLanguageLineDirection.unsafe = false
fn.CFLocaleCreateComponentsFromLocaleIdentifier.unsafe = false
fn.CFLocaleCreate.unsafe = false
fn.CFLocaleCreateCopy.unsafe = false
fn.CFLocaleGetValue.unsafe = false
fn.CFLocaleCopyDisplayNameForPropertyValue.unsafe = false

# CFMachPort
fn.CFMachPortSetInvalidationCallBack.unsafe = true # Callback must be sendable
fn.CFMachPortCreateRunLoopSource.unsafe = false

# CFMessagePort
fn.CFMessagePortCreateRemote.unsafe = false
fn.CFMessagePortSetName.unsafe = false
fn.CFMessagePortSetInvalidationCallBack.unsafe = true # Callback must be sendable
fn.CFMessagePortCreateRunLoopSource.unsafe = false

# CFPlugIn
fn.CFPlugInCreate.unsafe = false
fn.CFPlugInGetBundle.unsafe = false
fn.CFPlugInSetLoadOnDemand.unsafe = false
fn.CFPlugInIsLoadOnDemand.unsafe = false
fn.CFPlugInFindFactoriesForPlugInType.unsafe = false
fn.CFPlugInFindFactoriesForPlugInTypeInPlugIn.unsafe = false
fn.CFPlugInInstanceCreate.unsafe = false
fn.CFPlugInRegisterFactoryFunction.unsafe = false # TODO(breaking): Make this unsafe
fn.CFPlugInRegisterFactoryFunctionByName.unsafe = false
fn.CFPlugInUnregisterFactory.unsafe = false
fn.CFPlugInRegisterPlugInType.unsafe = false
fn.CFPlugInUnregisterPlugInType.unsafe = false
fn.CFPlugInAddInstanceForFactory.unsafe = false
fn.CFPlugInRemoveInstanceForFactory.unsafe = false
fn.CFPlugInInstanceGetFactoryName.unsafe = false
fn.CFPlugInInstanceGetInstanceData.unsafe = false
fn.CFPlugInInstanceCreateWithInstanceDataSize.unsafe = true # Callbacks, must be sendable?

# TODO(breaking): Maybe mark this as `unsafe`?
fn.CFPreferencesCopyMultiple.unsafe = false

# CFRunLoop
fn.CFRunLoopGetCurrent.unsafe = false
fn.CFRunLoopGetMain.unsafe = false
fn.CFRunLoopCopyCurrentMode.unsafe = false
fn.CFRunLoopCopyAllModes.unsafe = false
fn.CFRunLoopAddCommonMode.unsafe = false
fn.CFRunLoopGetNextTimerFireDate.unsafe = false
fn.CFRunLoopRun.unsafe = false # Can be run recursively
fn.CFRunLoopRunInMode.unsafe = false
fn.CFRunLoopIsWaiting.unsafe = false
fn.CFRunLoopWakeUp.unsafe = false
fn.CFRunLoopStop.unsafe = false
fn.CFRunLoopPerformBlock.unsafe = true # Block must be sendable
fn.CFRunLoopContainsSource.unsafe = false
fn.CFRunLoopAddSource.unsafe = false
fn.CFRunLoopRemoveSource.unsafe = false
fn.CFRunLoopContainsObserver.unsafe = false
fn.CFRunLoopAddObserver.unsafe = false
fn.CFRunLoopRemoveObserver.unsafe = false
fn.CFRunLoopContainsTimer.unsafe = false
fn.CFRunLoopAddTimer.unsafe = false
fn.CFRunLoopRemoveTimer.unsafe = false
fn.CFRunLoopSourceCreate.unsafe = true # Context must be sendable
fn.CFRunLoopSourceGetOrder.unsafe = false
fn.CFRunLoopSourceInvalidate.unsafe = false
fn.CFRunLoopSourceIsValid.unsafe = false
fn.CFRunLoopSourceSignal.unsafe = false
fn.CFRunLoopObserverCreate.unsafe = true # Callout / context must be sendable
fn.CFRunLoopObserverCreateWithHandler.unsafe = true # Handler must be sendable
fn.CFRunLoopObserverGetActivities.unsafe = false
fn.CFRunLoopObserverDoesRepeat.unsafe = false
fn.CFRunLoopObserverGetOrder.unsafe = false
fn.CFRunLoopObserverInvalidate.unsafe = false
fn.CFRunLoopObserverIsValid.unsafe = false
fn.CFRunLoopTimerCreate.unsafe = true # Callout / context must be sendable
fn.CFRunLoopTimerCreateWithHandler.unsafe = true # Handler must be sendable
fn.CFRunLoopTimerGetNextFireDate.unsafe = false
fn.CFRunLoopTimerSetNextFireDate.unsafe = false
fn.CFRunLoopTimerGetInterval.unsafe = false
fn.CFRunLoopTimerDoesRepeat.unsafe = false
fn.CFRunLoopTimerGetOrder.unsafe = false
fn.CFRunLoopTimerInvalidate.unsafe = false
fn.CFRunLoopTimerIsValid.unsafe = false
fn.CFRunLoopTimerGetTolerance.unsafe = false
fn.CFRunLoopTimerSetTolerance.unsafe = true # Not thread safe?

# CFSet
fn.CFSetCreateCopy.unsafe = false
fn.CFSetCreateMutableCopy.unsafe = true # UB if capacity not large enough
fn.CFSetGetCount.unsafe = false
fn.CFSetRemoveAllValues.unsafe = false

# CFSocket
fn.CFSocketCreate.unsafe = true # Callout/context must be sendable
fn.CFSocketCreateWithNative.unsafe = true # Callout/context must be sendable
fn.CFSocketCreateWithSocketSignature.unsafe = true # Callout/context must be sendable
fn.CFSocketSetAddress.unsafe = false
fn.CFSocketConnectToAddress.unsafe = false
fn.CFSocketCreateRunLoopSource.unsafe = false
fn.CFSocketSendData.unsafe = false
fn.CFSocketSetDefaultNameRegistryPortNumber.unsafe = false
fn.CFSocketGetDefaultNameRegistryPortNumber.unsafe = false

# CFStream
fn.CFWriteStreamCreateWithAllocatedBuffers.unsafe = false
fn.CFReadStreamCreateWithFile.unsafe = false
fn.CFWriteStreamCreateWithFile.unsafe = false
fn.CFReadStreamCopyProperty.unsafe = false
fn.CFWriteStreamCopyProperty.unsafe = false
fn.CFReadStreamSetProperty.unsafe = true # CFType can be anything
fn.CFWriteStreamSetProperty.unsafe = true # CFType can be anything
fn.CFReadStreamScheduleWithRunLoop.unsafe = false
fn.CFWriteStreamScheduleWithRunLoop.unsafe = false
fn.CFReadStreamUnscheduleFromRunLoop.unsafe = false
fn.CFWriteStreamUnscheduleFromRunLoop.unsafe = false

# CFString
fn.CFStringCreateWithSubstring.unsafe = true # Unsure if range out of bounds is UB
fn.CFStringCreateCopy.unsafe = false
fn.CFStringCreateMutable.unsafe = false
fn.CFStringCreateMutableCopy.unsafe = false
fn.CFStringGetCharacterAtIndex.unsafe = true # Maybe UB if out of bounds?
fn.CFStringCreateFromExternalRepresentation.unsafe = false
fn.CFStringCreateExternalRepresentation.unsafe = false
fn.CFStringCompareWithOptionsAndLocale.unsafe = true # Unsure if range out of bounds is UB
fn.CFStringCompareWithOptions.unsafe = true # Unsure if range out of bounds is UB
fn.CFStringCompare.unsafe = false
fn.CFStringCreateArrayWithFindResults.unsafe = true # Unsure if range out of bounds is UB
fn.CFStringFind.unsafe = false
fn.CFStringHasPrefix.unsafe = false
fn.CFStringHasSuffix.unsafe = false
fn.CFStringGetRangeOfComposedCharactersAtIndex.unsafe = true # UB if out of bounds
fn.CFStringIsHyphenationAvailableForLocale.unsafe = false
fn.CFStringCreateByCombiningStrings.unsafe = true # CFArray can contain anything
fn.CFStringCreateArrayBySeparatingStrings.unsafe = false
fn.CFStringAppend.unsafe = false
fn.CFStringInsert.unsafe = true # Maybe UB if out of bounds?
fn.CFStringDelete.unsafe = true # Unsure if range out of bounds is UB
fn.CFStringReplace.unsafe = true # Unsure if range out of bounds is UB
fn.CFStringReplaceAll.unsafe = false
fn.CFStringFindAndReplace.unsafe = true # Unsure if range out of bounds is UB
fn.CFStringPad.unsafe = true # Maybe UB if out of bounds?
fn.CFStringTrim.unsafe = false
fn.CFStringTrimWhitespace.unsafe = false
fn.CFStringLowercase.unsafe = false
fn.CFStringUppercase.unsafe = false
fn.CFStringCapitalize.unsafe = false
fn.CFStringNormalize.unsafe = true # Maybe UB if CFStringNormalizationForm is not valid?
fn.CFStringFold.unsafe = false
fn.CFStringIsEncodingAvailable.unsafe = false
fn.CFStringGetListOfAvailableEncodings.unsafe = false
fn.CFStringGetNameOfEncoding.unsafe = false
fn.CFShow.unsafe = false
fn.CFShowStr.unsafe = false

# CFTimeZone
fn.CFTimeZoneCreateWithTimeIntervalFromGMT.unsafe = false
fn.CFTimeZoneCreateWithName.unsafe = false
fn.CFTimeZoneCopyLocalizedName.unsafe = false
fn.CFTimeZoneCreate.unsafe = true # Unsure

# CFURL
fn.CFURLCreateData.unsafe = false
fn.CFURLCreateWithString.unsafe = false
fn.CFURLCreateWithFileSystemPath.unsafe = false
fn.CFURLCreateWithFileSystemPathRelativeToBase.unsafe = false
fn.CFURLCopyAbsoluteURL.unsafe = false
fn.CFURLCopyParameterString.unsafe = false
fn.CFURLCopyQueryString.unsafe = false
fn.CFURLCopyFragment.unsafe = false
fn.CFURLCreateCopyAppendingPathComponent.unsafe = false
fn.CFURLCreateCopyDeletingLastPathComponent.unsafe = false
fn.CFURLCreateCopyAppendingPathExtension.unsafe = false
fn.CFURLCreateCopyDeletingPathExtension.unsafe = false
fn.CFURLCreateStringByReplacingPercentEscapes.unsafe = false
fn.CFURLClearResourcePropertyCacheForKey.unsafe = false
fn.CFURLClearResourcePropertyCache.unsafe = false
fn.CFURLSetTemporaryResourcePropertyForKey.unsafe = false

# Documentation says these must be balanced.
fn.CFURLStartAccessingSecurityScopedResource.unsafe = true
fn.CFURLStopAccessingSecurityScopedResource.unsafe = true

# CFUserNotification
fn.CFUserNotificationGetResponseValue.unsafe = true # Unsure about key/idx
fn.CFUserNotificationGetResponseDictionary.unsafe = false
fn.CFUserNotificationCreateRunLoopSource.unsafe = true # Callback must be sendable
fn.CFUserNotificationDisplayNotice.unsafe = false

# CFUUID
fn.CFUUIDCreate.unsafe = false
fn.CFUUIDCreateWithBytes.unsafe = false
fn.CFUUIDCreateFromString.unsafe = false
fn.CFUUIDCreateString.unsafe = false
fn.CFUUIDGetConstantUUIDWithBytes.unsafe = false
fn.CFUUIDCreateFromUUIDBytes.unsafe = false

# UB if out of bounds.
fn.CFCharacterSetHasMemberInPlane.unsafe = true
