framework = "CoreText"
crate = "objc2-core-text"
required-crates = ["objc2-core-foundation"]
custom-lib-rs = true
macos = "10.8"
maccatalyst = "13.0"
ios = "3.2"
tvos = "9.0"
watchos = "2.0"
visionos = "1.0"

# Unknown calling convention / ABI
fn.CTRubyAnnotationCreate.skipped = true
typedef.BslnBaselineRecord.skipped = true

# Needs ATSFontRef from ATS framework
fn.CTFontGetPlatformFont.skipped = true
fn.CTFontCreateWithPlatformFont.skipped = true

# Emits -1 on an unsigned type
const.kCTFontUIFontNone.use-value = true
const.kCTRubyAlignmentInvalid.use-value = true
const.kCTRubyOverhangInvalid.use-value = true

# Emits 0x80000000 on an int
const.kMORTLigLastAction.use-value = true
const.kMORXCoverVertical.use-value = true
const.kKERXVertical.use-value = true

##
## Safety
##

# SAFETY: CoreText is generally well-behaved. It even often documents things
# like "if X is valid, then this returns Y, otherwise it returns Z".
unsafe-default-safety.documentation-is-reviewed = true
# SAFETY: CoreText is bounds-checked, at least for cases where it can be
# (e.g. where we're not working with raw pointers).
#
# Examples:
# - `CTRunGetImageBounds` returns `CGRectNull` if range is invalid.
# - `CTTypesetterCreateLineWithOffset`: "otherwise the call will fail".
# - `CTRunGetStringIndices` takes buffer pointer, so ofc. isn't safe.
unsafe-default-safety.bounds-checked-internally = true

# TODO(breaking): Mark this as nullable? `CTRunDelegateCreate` creates it from
# a nullable parameter.
fn.CTRunDelegateGetRefCon.unsafe = true
